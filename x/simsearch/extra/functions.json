[
  {
    "id": 1,
    "text": "func Example() {\n\tconst src = `\n// This is scanned code.\nif a \u003e 10 {\n\tsomeParsable = text\n}`\n\n\tvar s scanner.Scanner\n\ts.Init(strings.NewReader(src))\n\ts.Filename = \"example\"\n\tfor tok := s.Scan(); tok != scanner.EOF; tok = s.Scan() {\n\t\tfmt.Printf(\"%s: %s\\n\", s.Position, s.TokenText())\n\t}\n\n\t// Output:\n\t// example:3:1: if\n\t// example:3:4: a\n\t// example:3:6: \u003e\n\t// example:3:8: 10\n\t// example:3:11: {\n\t// example:4:2: someParsable\n\t// example:4:15: =\n\t// example:4:17: text\n\t// example:5:1: }\n}",
    "filename": "/usr/local/go/src/text/scanner/example_test.go",
    "line": 14
  },
  {
    "id": 2,
    "text": "func Example_isIdentRune() {\n\tconst src = \"%var1 var2%\"\n\n\tvar s scanner.Scanner\n\ts.Init(strings.NewReader(src))\n\ts.Filename = \"default\"\n\n\tfor tok := s.Scan(); tok != scanner.EOF; tok = s.Scan() {\n\t\tfmt.Printf(\"%s: %s\\n\", s.Position, s.TokenText())\n\t}\n\n\tfmt.Println()\n\ts.Init(strings.NewReader(src))\n\ts.Filename = \"percent\"\n\n\t// treat leading '%' as part of an identifier\n\ts.IsIdentRune = func(ch rune, i int) bool {\n\t\treturn ch == '%' \u0026\u0026 i == 0 || unicode.IsLetter(ch) || unicode.IsDigit(ch) \u0026\u0026 i \u003e 0\n\t}\n\n\tfor tok := s.Scan(); tok != scanner.EOF; tok = s.Scan() {\n\t\tfmt.Printf(\"%s: %s\\n\", s.Position, s.TokenText())\n\t}\n\n\t// Output:\n\t// default:1:1: %\n\t// default:1:2: var1\n\t// default:1:7: var2\n\t// default:1:11: %\n\t//\n\t// percent:1:1: %var1\n\t// percent:1:7: var2\n\t// percent:1:11: %\n}",
    "filename": "/usr/local/go/src/text/scanner/example_test.go",
    "line": 40
  },
  {
    "id": 3,
    "text": "func Example_mode() {\n\tconst src = `\n    // Comment begins at column 5.\n\nThis line should not be included in the output.\n\n/*\nThis multiline comment\nshould be extracted in\nits entirety.\n*/\n`\n\n\tvar s scanner.Scanner\n\ts.Init(strings.NewReader(src))\n\ts.Filename = \"comments\"\n\ts.Mode ^= scanner.SkipComments // don't skip comments\n\n\tfor tok := s.Scan(); tok != scanner.EOF; tok = s.Scan() {\n\t\ttxt := s.TokenText()\n\t\tif strings.HasPrefix(txt, \"//\") || strings.HasPrefix(txt, \"/*\") {\n\t\t\tfmt.Printf(\"%s: %s\\n\", s.Position, txt)\n\t\t}\n\t}\n\n\t// Output:\n\t// comments:2:5: // Comment begins at column 5.\n\t// comments:6:1: /*\n\t// This multiline comment\n\t// should be extracted in\n\t// its entirety.\n\t// */\n}",
    "filename": "/usr/local/go/src/text/scanner/example_test.go",
    "line": 75
  },
  {
    "id": 4,
    "text": "func Example_whitespace() {\n\t// tab-separated values\n\tconst src = `aa\tab\tac\tad\nba\tbb\tbc\tbd\nca\tcb\tcc\tcd\nda\tdb\tdc\tdd`\n\n\tvar (\n\t\tcol, row int\n\t\ts        scanner.Scanner\n\t\ttsv      [4][4]string // large enough for example above\n\t)\n\ts.Init(strings.NewReader(src))\n\ts.Whitespace ^= 1\u003c\u003c'\\t' | 1\u003c\u003c'\\n' // don't skip tabs and new lines\n\n\tfor tok := s.Scan(); tok != scanner.EOF; tok = s.Scan() {\n\t\tswitch tok {\n\t\tcase '\\n':\n\t\t\trow++\n\t\t\tcol = 0\n\t\tcase '\\t':\n\t\t\tcol++\n\t\tdefault:\n\t\t\ttsv[row][col] = s.TokenText()\n\t\t}\n\t}\n\n\tfmt.Print(tsv)\n\n\t// Output:\n\t// [[aa ab ac ad] [ba bb bc bd] [ca cb cc cd] [da db dc dd]]\n}",
    "filename": "/usr/local/go/src/text/scanner/example_test.go",
    "line": 109
  },
  {
    "id": 5,
    "text": "func (pos *Position) IsValid() bool { return pos.Line \u003e 0 }",
    "filename": "/usr/local/go/src/text/scanner/scanner.go",
    "line": 36
  },
  {
    "id": 6,
    "text": "func (pos Position) String() string {\n\ts := pos.Filename\n\tif s == \"\" {\n\t\ts = \"\u003cinput\u003e\"\n\t}\n\tif pos.IsValid() {\n\t\ts += fmt.Sprintf(\":%d:%d\", pos.Line, pos.Column)\n\t}\n\treturn s\n}",
    "filename": "/usr/local/go/src/text/scanner/scanner.go",
    "line": 38
  },
  {
    "id": 7,
    "text": "func TokenString(tok rune) string {\n\tif s, found := tokenString[tok]; found {\n\t\treturn s\n\t}\n\treturn fmt.Sprintf(\"%q\", string(tok))\n}",
    "filename": "/usr/local/go/src/text/scanner/scanner.go",
    "line": 102
  },
  {
    "id": 8,
    "text": "func (s *Scanner) Init(src io.Reader) *Scanner {\n\ts.src = src\n\n\t// initialize source buffer\n\t// (the first call to next() will fill it by calling src.Read)\n\ts.srcBuf[0] = utf8.RuneSelf // sentinel\n\ts.srcPos = 0\n\ts.srcEnd = 0\n\n\t// initialize source position\n\ts.srcBufOffset = 0\n\ts.line = 1\n\ts.column = 0\n\ts.lastLineLen = 0\n\ts.lastCharLen = 0\n\n\t// initialize token text buffer\n\t// (required for first call to next()).\n\ts.tokPos = -1\n\n\t// initialize one character look-ahead\n\ts.ch = -2 // no char read yet, not EOF\n\n\t// initialize public fields\n\ts.Error = nil\n\ts.ErrorCount = 0\n\ts.Mode = GoTokens\n\ts.Whitespace = GoWhitespace\n\ts.Line = 0 // invalidate token position\n\n\treturn s\n}",
    "filename": "/usr/local/go/src/text/scanner/scanner.go",
    "line": 181
  },
  {
    "id": 9,
    "text": "func (s *Scanner) next() rune {\n\tch, width := rune(s.srcBuf[s.srcPos]), 1\n\n\tif ch \u003e= utf8.RuneSelf {\n\t\t// uncommon case: not ASCII or not enough bytes\n\t\tfor s.srcPos+utf8.UTFMax \u003e s.srcEnd \u0026\u0026 !utf8.FullRune(s.srcBuf[s.srcPos:s.srcEnd]) {\n\t\t\t// not enough bytes: read some more, but first\n\t\t\t// save away token text if any\n\t\t\tif s.tokPos \u003e= 0 {\n\t\t\t\ts.tokBuf.Write(s.srcBuf[s.tokPos:s.srcPos])\n\t\t\t\ts.tokPos = 0\n\t\t\t\t// s.tokEnd is set by Scan()\n\t\t\t}\n\t\t\t// move unread bytes to beginning of buffer\n\t\t\tcopy(s.srcBuf[0:], s.srcBuf[s.srcPos:s.srcEnd])\n\t\t\ts.srcBufOffset += s.srcPos\n\t\t\t// read more bytes\n\t\t\t// (an io.Reader must return io.EOF when it reaches\n\t\t\t// the end of what it is reading - simply returning\n\t\t\t// n == 0 will make this loop retry forever; but the\n\t\t\t// error is in the reader implementation in that case)\n\t\t\ti := s.srcEnd - s.srcPos\n\t\t\tn, err := s.src.Read(s.srcBuf[i:bufLen])\n\t\t\ts.srcPos = 0\n\t\t\ts.srcEnd = i + n\n\t\t\ts.srcBuf[s.srcEnd] = utf8.RuneSelf // sentinel\n\t\t\tif err != nil {\n\t\t\t\tif err != io.EOF {\n\t\t\t\t\ts.error(err.Error())\n\t\t\t\t}\n\t\t\t\tif s.srcEnd == 0 {\n\t\t\t\t\tif s.lastCharLen \u003e 0 {\n\t\t\t\t\t\t// previous character was not EOF\n\t\t\t\t\t\ts.column++\n\t\t\t\t\t}\n\t\t\t\t\ts.lastCharLen = 0\n\t\t\t\t\treturn EOF\n\t\t\t\t}\n\t\t\t\t// If err == EOF, we won't be getting more\n\t\t\t\t// bytes; break to avoid infinite loop. If\n\t\t\t\t// err is something else, we don't know if\n\t\t\t\t// we can get more bytes; thus also break.\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\t// at least one byte\n\t\tch = rune(s.srcBuf[s.srcPos])\n\t\tif ch \u003e= utf8.RuneSelf {\n\t\t\t// uncommon case: not ASCII\n\t\t\tch, width = utf8.DecodeRune(s.srcBuf[s.srcPos:s.srcEnd])\n\t\t\tif ch == utf8.RuneError \u0026\u0026 width == 1 {\n\t\t\t\t// advance for correct error position\n\t\t\t\ts.srcPos += width\n\t\t\t\ts.lastCharLen = width\n\t\t\t\ts.column++\n\t\t\t\ts.error(\"invalid UTF-8 encoding\")\n\t\t\t\treturn ch\n\t\t\t}\n\t\t}\n\t}\n\n\t// advance\n\ts.srcPos += width\n\ts.lastCharLen = width\n\ts.column++\n\n\t// special situations\n\tswitch ch {\n\tcase 0:\n\t\t// for compatibility with other tools\n\t\ts.error(\"invalid character NUL\")\n\tcase '\\n':\n\t\ts.line++\n\t\ts.lastLineLen = s.column\n\t\ts.column = 0\n\t}\n\n\treturn ch\n}",
    "filename": "/usr/local/go/src/text/scanner/scanner.go",
    "line": 218
  },
  {
    "id": 10,
    "text": "func (s *Scanner) Next() rune {\n\ts.tokPos = -1 // don't collect token text\n\ts.Line = 0    // invalidate token position\n\tch := s.Peek()\n\tif ch != EOF {\n\t\ts.ch = s.next()\n\t}\n\treturn ch\n}",
    "filename": "/usr/local/go/src/text/scanner/scanner.go",
    "line": 304
  },
  {
    "id": 11,
    "text": "func (s *Scanner) Peek() rune {\n\tif s.ch == -2 {\n\t\t// this code is only run for the very first character\n\t\ts.ch = s.next()\n\t\tif s.ch == '\\uFEFF' {\n\t\t\ts.ch = s.next() // ignore BOM\n\t\t}\n\t}\n\treturn s.ch\n}",
    "filename": "/usr/local/go/src/text/scanner/scanner.go",
    "line": 317
  },
  {
    "id": 12,
    "text": "func (s *Scanner) error(msg string) {\n\ts.tokEnd = s.srcPos - s.lastCharLen // make sure token text is terminated\n\ts.ErrorCount++\n\tif s.Error != nil {\n\t\ts.Error(s, msg)\n\t\treturn\n\t}\n\tpos := s.Position\n\tif !pos.IsValid() {\n\t\tpos = s.Pos()\n\t}\n\tfmt.Fprintf(os.Stderr, \"%s: %s\\n\", pos, msg)\n}",
    "filename": "/usr/local/go/src/text/scanner/scanner.go",
    "line": 328
  },
  {
    "id": 13,
    "text": "func (s *Scanner) errorf(format string, args ...any) {\n\ts.error(fmt.Sprintf(format, args...))\n}",
    "filename": "/usr/local/go/src/text/scanner/scanner.go",
    "line": 342
  },
  {
    "id": 14,
    "text": "func (s *Scanner) isIdentRune(ch rune, i int) bool {\n\tif s.IsIdentRune != nil {\n\t\treturn ch != EOF \u0026\u0026 s.IsIdentRune(ch, i)\n\t}\n\treturn ch == '_' || unicode.IsLetter(ch) || unicode.IsDigit(ch) \u0026\u0026 i \u003e 0\n}",
    "filename": "/usr/local/go/src/text/scanner/scanner.go",
    "line": 346
  },
  {
    "id": 15,
    "text": "func (s *Scanner) scanIdentifier() rune {\n\t// we know the zero'th rune is OK; start scanning at the next one\n\tch := s.next()\n\tfor i := 1; s.isIdentRune(ch, i); i++ {\n\t\tch = s.next()\n\t}\n\treturn ch\n}",
    "filename": "/usr/local/go/src/text/scanner/scanner.go",
    "line": 353
  },
  {
    "id": 16,
    "text": "func lower(ch rune) rune     { return ('a' - 'A') | ch }",
    "filename": "/usr/local/go/src/text/scanner/scanner.go",
    "line": 362
  },
  {
    "id": 17,
    "text": "func isDecimal(ch rune) bool { return '0' \u003c= ch \u0026\u0026 ch \u003c= '9' }",
    "filename": "/usr/local/go/src/text/scanner/scanner.go",
    "line": 363
  },
  {
    "id": 18,
    "text": "func isHex(ch rune) bool     { return '0' \u003c= ch \u0026\u0026 ch \u003c= '9' || 'a' \u003c= lower(ch) \u0026\u0026 lower(ch) \u003c= 'f' }",
    "filename": "/usr/local/go/src/text/scanner/scanner.go",
    "line": 364
  },
  {
    "id": 19,
    "text": "func (s *Scanner) digits(ch0 rune, base int, invalid *rune) (ch rune, digsep int) {\n\tch = ch0\n\tif base \u003c= 10 {\n\t\tmax := rune('0' + base)\n\t\tfor isDecimal(ch) || ch == '_' {\n\t\t\tds := 1\n\t\t\tif ch == '_' {\n\t\t\t\tds = 2\n\t\t\t} else if ch \u003e= max \u0026\u0026 *invalid == 0 {\n\t\t\t\t*invalid = ch\n\t\t\t}\n\t\t\tdigsep |= ds\n\t\t\tch = s.next()\n\t\t}\n\t} else {\n\t\tfor isHex(ch) || ch == '_' {\n\t\t\tds := 1\n\t\t\tif ch == '_' {\n\t\t\t\tds = 2\n\t\t\t}\n\t\t\tdigsep |= ds\n\t\t\tch = s.next()\n\t\t}\n\t}\n\treturn\n}",
    "filename": "/usr/local/go/src/text/scanner/scanner.go",
    "line": 372
  },
  {
    "id": 20,
    "text": "func (s *Scanner) scanNumber(ch rune, seenDot bool) (rune, rune) {\n\tbase := 10         // number base\n\tprefix := rune(0)  // one of 0 (decimal), '0' (0-octal), 'x', 'o', or 'b'\n\tdigsep := 0        // bit 0: digit present, bit 1: '_' present\n\tinvalid := rune(0) // invalid digit in literal, or 0\n\n\t// integer part\n\tvar tok rune\n\tvar ds int\n\tif !seenDot {\n\t\ttok = Int\n\t\tif ch == '0' {\n\t\t\tch = s.next()\n\t\t\tswitch lower(ch) {\n\t\t\tcase 'x':\n\t\t\t\tch = s.next()\n\t\t\t\tbase, prefix = 16, 'x'\n\t\t\tcase 'o':\n\t\t\t\tch = s.next()\n\t\t\t\tbase, prefix = 8, 'o'\n\t\t\tcase 'b':\n\t\t\t\tch = s.next()\n\t\t\t\tbase, prefix = 2, 'b'\n\t\t\tdefault:\n\t\t\t\tbase, prefix = 8, '0'\n\t\t\t\tdigsep = 1 // leading 0\n\t\t\t}\n\t\t}\n\t\tch, ds = s.digits(ch, base, \u0026invalid)\n\t\tdigsep |= ds\n\t\tif ch == '.' \u0026\u0026 s.Mode\u0026ScanFloats != 0 {\n\t\t\tch = s.next()\n\t\t\tseenDot = true\n\t\t}\n\t}\n\n\t// fractional part\n\tif seenDot {\n\t\ttok = Float\n\t\tif prefix == 'o' || prefix == 'b' {\n\t\t\ts.error(\"invalid radix point in \" + litname(prefix))\n\t\t}\n\t\tch, ds = s.digits(ch, base, \u0026invalid)\n\t\tdigsep |= ds\n\t}\n\n\tif digsep\u00261 == 0 {\n\t\ts.error(litname(prefix) + \" has no digits\")\n\t}\n\n\t// exponent\n\tif e := lower(ch); (e == 'e' || e == 'p') \u0026\u0026 s.Mode\u0026ScanFloats != 0 {\n\t\tswitch {\n\t\tcase e == 'e' \u0026\u0026 prefix != 0 \u0026\u0026 prefix != '0':\n\t\t\ts.errorf(\"%q exponent requires decimal mantissa\", ch)\n\t\tcase e == 'p' \u0026\u0026 prefix != 'x':\n\t\t\ts.errorf(\"%q exponent requires hexadecimal mantissa\", ch)\n\t\t}\n\t\tch = s.next()\n\t\ttok = Float\n\t\tif ch == '+' || ch == '-' {\n\t\t\tch = s.next()\n\t\t}\n\t\tch, ds = s.digits(ch, 10, nil)\n\t\tdigsep |= ds\n\t\tif ds\u00261 == 0 {\n\t\t\ts.error(\"exponent has no digits\")\n\t\t}\n\t} else if prefix == 'x' \u0026\u0026 tok == Float {\n\t\ts.error(\"hexadecimal mantissa requires a 'p' exponent\")\n\t}\n\n\tif tok == Int \u0026\u0026 invalid != 0 {\n\t\ts.errorf(\"invalid digit %q in %s\", invalid, litname(prefix))\n\t}\n\n\tif digsep\u00262 != 0 {\n\t\ts.tokEnd = s.srcPos - s.lastCharLen // make sure token text is terminated\n\t\tif i := invalidSep(s.TokenText()); i \u003e= 0 {\n\t\t\ts.error(\"'_' must separate successive digits\")\n\t\t}\n\t}\n\n\treturn tok, ch\n}",
    "filename": "/usr/local/go/src/text/scanner/scanner.go",
    "line": 399
  },
  {
    "id": 21,
    "text": "func litname(prefix rune) string {\n\tswitch prefix {\n\tdefault:\n\t\treturn \"decimal literal\"\n\tcase 'x':\n\t\treturn \"hexadecimal literal\"\n\tcase 'o', '0':\n\t\treturn \"octal literal\"\n\tcase 'b':\n\t\treturn \"binary literal\"\n\t}\n}",
    "filename": "/usr/local/go/src/text/scanner/scanner.go",
    "line": 485
  },
  {
    "id": 22,
    "text": "func invalidSep(x string) int {\n\tx1 := ' ' // prefix char, we only care if it's 'x'\n\td := '.'  // digit, one of '_', '0' (a digit), or '.' (anything else)\n\ti := 0\n\n\t// a prefix counts as a digit\n\tif len(x) \u003e= 2 \u0026\u0026 x[0] == '0' {\n\t\tx1 = lower(rune(x[1]))\n\t\tif x1 == 'x' || x1 == 'o' || x1 == 'b' {\n\t\t\td = '0'\n\t\t\ti = 2\n\t\t}\n\t}\n\n\t// mantissa and exponent\n\tfor ; i \u003c len(x); i++ {\n\t\tp := d // previous digit\n\t\td = rune(x[i])\n\t\tswitch {\n\t\tcase d == '_':\n\t\t\tif p != '0' {\n\t\t\t\treturn i\n\t\t\t}\n\t\tcase isDecimal(d) || x1 == 'x' \u0026\u0026 isHex(d):\n\t\t\td = '0'\n\t\tdefault:\n\t\t\tif p == '_' {\n\t\t\t\treturn i - 1\n\t\t\t}\n\t\t\td = '.'\n\t\t}\n\t}\n\tif d == '_' {\n\t\treturn len(x) - 1\n\t}\n\n\treturn -1\n}",
    "filename": "/usr/local/go/src/text/scanner/scanner.go",
    "line": 499
  },
  {
    "id": 23,
    "text": "func digitVal(ch rune) int {\n\tswitch {\n\tcase '0' \u003c= ch \u0026\u0026 ch \u003c= '9':\n\t\treturn int(ch - '0')\n\tcase 'a' \u003c= lower(ch) \u0026\u0026 lower(ch) \u003c= 'f':\n\t\treturn int(lower(ch) - 'a' + 10)\n\t}\n\treturn 16 // larger than any legal digit val\n}",
    "filename": "/usr/local/go/src/text/scanner/scanner.go",
    "line": 538
  },
  {
    "id": 24,
    "text": "func (s *Scanner) scanDigits(ch rune, base, n int) rune {\n\tfor n \u003e 0 \u0026\u0026 digitVal(ch) \u003c base {\n\t\tch = s.next()\n\t\tn--\n\t}\n\tif n \u003e 0 {\n\t\ts.error(\"invalid char escape\")\n\t}\n\treturn ch\n}",
    "filename": "/usr/local/go/src/text/scanner/scanner.go",
    "line": 548
  },
  {
    "id": 25,
    "text": "func (s *Scanner) scanEscape(quote rune) rune {\n\tch := s.next() // read character after '/'\n\tswitch ch {\n\tcase 'a', 'b', 'f', 'n', 'r', 't', 'v', '\\\\', quote:\n\t\t// nothing to do\n\t\tch = s.next()\n\tcase '0', '1', '2', '3', '4', '5', '6', '7':\n\t\tch = s.scanDigits(ch, 8, 3)\n\tcase 'x':\n\t\tch = s.scanDigits(s.next(), 16, 2)\n\tcase 'u':\n\t\tch = s.scanDigits(s.next(), 16, 4)\n\tcase 'U':\n\t\tch = s.scanDigits(s.next(), 16, 8)\n\tdefault:\n\t\ts.error(\"invalid char escape\")\n\t}\n\treturn ch\n}",
    "filename": "/usr/local/go/src/text/scanner/scanner.go",
    "line": 559
  },
  {
    "id": 26,
    "text": "func (s *Scanner) scanString(quote rune) (n int) {\n\tch := s.next() // read character after quote\n\tfor ch != quote {\n\t\tif ch == '\\n' || ch \u003c 0 {\n\t\t\ts.error(\"literal not terminated\")\n\t\t\treturn\n\t\t}\n\t\tif ch == '\\\\' {\n\t\t\tch = s.scanEscape(quote)\n\t\t} else {\n\t\t\tch = s.next()\n\t\t}\n\t\tn++\n\t}\n\treturn\n}",
    "filename": "/usr/local/go/src/text/scanner/scanner.go",
    "line": 579
  },
  {
    "id": 27,
    "text": "func (s *Scanner) scanRawString() {\n\tch := s.next() // read character after '`'\n\tfor ch != '`' {\n\t\tif ch \u003c 0 {\n\t\t\ts.error(\"literal not terminated\")\n\t\t\treturn\n\t\t}\n\t\tch = s.next()\n\t}\n}",
    "filename": "/usr/local/go/src/text/scanner/scanner.go",
    "line": 596
  },
  {
    "id": 28,
    "text": "func (s *Scanner) scanChar() {\n\tif s.scanString('\\'') != 1 {\n\t\ts.error(\"invalid char literal\")\n\t}\n}",
    "filename": "/usr/local/go/src/text/scanner/scanner.go",
    "line": 607
  },
  {
    "id": 29,
    "text": "func (s *Scanner) scanComment(ch rune) rune {\n\t// ch == '/' || ch == '*'\n\tif ch == '/' {\n\t\t// line comment\n\t\tch = s.next() // read character after \"//\"\n\t\tfor ch != '\\n' \u0026\u0026 ch \u003e= 0 {\n\t\t\tch = s.next()\n\t\t}\n\t\treturn ch\n\t}\n\n\t// general comment\n\tch = s.next() // read character after \"/*\"\n\tfor {\n\t\tif ch \u003c 0 {\n\t\t\ts.error(\"comment not terminated\")\n\t\t\tbreak\n\t\t}\n\t\tch0 := ch\n\t\tch = s.next()\n\t\tif ch0 == '*' \u0026\u0026 ch == '/' {\n\t\t\tch = s.next()\n\t\t\tbreak\n\t\t}\n\t}\n\treturn ch\n}",
    "filename": "/usr/local/go/src/text/scanner/scanner.go",
    "line": 613
  },
  {
    "id": 30,
    "text": "func (s *Scanner) Scan() rune {\n\tch := s.Peek()\n\n\t// reset token text position\n\ts.tokPos = -1\n\ts.Line = 0\n\nredo:\n\t// skip white space\n\tfor s.Whitespace\u0026(1\u003c\u003cuint(ch)) != 0 {\n\t\tch = s.next()\n\t}\n\n\t// start collecting token text\n\ts.tokBuf.Reset()\n\ts.tokPos = s.srcPos - s.lastCharLen\n\n\t// set token position\n\t// (this is a slightly optimized version of the code in Pos())\n\ts.Offset = s.srcBufOffset + s.tokPos\n\tif s.column \u003e 0 {\n\t\t// common case: last character was not a '\\n'\n\t\ts.Line = s.line\n\t\ts.Column = s.column\n\t} else {\n\t\t// last character was a '\\n'\n\t\t// (we cannot be at the beginning of the source\n\t\t// since we have called next() at least once)\n\t\ts.Line = s.line - 1\n\t\ts.Column = s.lastLineLen\n\t}\n\n\t// determine token value\n\ttok := ch\n\tswitch {\n\tcase s.isIdentRune(ch, 0):\n\t\tif s.Mode\u0026ScanIdents != 0 {\n\t\t\ttok = Ident\n\t\t\tch = s.scanIdentifier()\n\t\t} else {\n\t\t\tch = s.next()\n\t\t}\n\tcase isDecimal(ch):\n\t\tif s.Mode\u0026(ScanInts|ScanFloats) != 0 {\n\t\t\ttok, ch = s.scanNumber(ch, false)\n\t\t} else {\n\t\t\tch = s.next()\n\t\t}\n\tdefault:\n\t\tswitch ch {\n\t\tcase EOF:\n\t\t\tbreak\n\t\tcase '\"':\n\t\t\tif s.Mode\u0026ScanStrings != 0 {\n\t\t\t\ts.scanString('\"')\n\t\t\t\ttok = String\n\t\t\t}\n\t\t\tch = s.next()\n\t\tcase '\\'':\n\t\t\tif s.Mode\u0026ScanChars != 0 {\n\t\t\t\ts.scanChar()\n\t\t\t\ttok = Char\n\t\t\t}\n\t\t\tch = s.next()\n\t\tcase '.':\n\t\t\tch = s.next()\n\t\t\tif isDecimal(ch) \u0026\u0026 s.Mode\u0026ScanFloats != 0 {\n\t\t\t\ttok, ch = s.scanNumber(ch, true)\n\t\t\t}\n\t\tcase '/':\n\t\t\tch = s.next()\n\t\t\tif (ch == '/' || ch == '*') \u0026\u0026 s.Mode\u0026ScanComments != 0 {\n\t\t\t\tif s.Mode\u0026SkipComments != 0 {\n\t\t\t\t\ts.tokPos = -1 // don't collect token text\n\t\t\t\t\tch = s.scanComment(ch)\n\t\t\t\t\tgoto redo\n\t\t\t\t}\n\t\t\t\tch = s.scanComment(ch)\n\t\t\t\ttok = Comment\n\t\t\t}\n\t\tcase '`':\n\t\t\tif s.Mode\u0026ScanRawStrings != 0 {\n\t\t\t\ts.scanRawString()\n\t\t\t\ttok = RawString\n\t\t\t}\n\t\t\tch = s.next()\n\t\tdefault:\n\t\t\tch = s.next()\n\t\t}\n\t}\n\n\t// end of token text\n\ts.tokEnd = s.srcPos - s.lastCharLen\n\n\ts.ch = ch\n\treturn tok\n}",
    "filename": "/usr/local/go/src/text/scanner/scanner.go",
    "line": 646
  },
  {
    "id": 31,
    "text": "func (s *Scanner) Pos() (pos Position) {\n\tpos.Filename = s.Filename\n\tpos.Offset = s.srcBufOffset + s.srcPos - s.lastCharLen\n\tswitch {\n\tcase s.column \u003e 0:\n\t\t// common case: last character was not a '\\n'\n\t\tpos.Line = s.line\n\t\tpos.Column = s.column\n\tcase s.lastLineLen \u003e 0:\n\t\t// last character was a '\\n'\n\t\tpos.Line = s.line - 1\n\t\tpos.Column = s.lastLineLen\n\tdefault:\n\t\t// at the beginning of the source\n\t\tpos.Line = 1\n\t\tpos.Column = 1\n\t}\n\treturn\n}",
    "filename": "/usr/local/go/src/text/scanner/scanner.go",
    "line": 748
  },
  {
    "id": 32,
    "text": "func (s *Scanner) TokenText() string {\n\tif s.tokPos \u003c 0 {\n\t\t// no token text\n\t\treturn \"\"\n\t}\n\n\tif s.tokEnd \u003c s.tokPos {\n\t\t// if EOF was reached, s.tokEnd is set to -1 (s.srcPos == 0)\n\t\ts.tokEnd = s.tokPos\n\t}\n\t// s.tokEnd \u003e= s.tokPos\n\n\tif s.tokBuf.Len() == 0 {\n\t\t// common case: the entire token text is still in srcBuf\n\t\treturn string(s.srcBuf[s.tokPos:s.tokEnd])\n\t}\n\n\t// part of the token text was saved in tokBuf: save the rest in\n\t// tokBuf as well and return its content\n\ts.tokBuf.Write(s.srcBuf[s.tokPos:s.tokEnd])\n\ts.tokPos = s.tokEnd // ensure idempotency of TokenText() call\n\treturn s.tokBuf.String()\n}",
    "filename": "/usr/local/go/src/text/scanner/scanner.go",
    "line": 770
  },
  {
    "id": 33,
    "text": "func (r *StringReader) Read(p []byte) (n int, err error) {\n\tif r.step \u003c len(r.data) {\n\t\ts := r.data[r.step]\n\t\tn = copy(p, s)\n\t\tr.step++\n\t} else {\n\t\terr = io.EOF\n\t}\n\treturn\n}",
    "filename": "/usr/local/go/src/text/scanner/scanner_test.go",
    "line": 22
  },
  {
    "id": 34,
    "text": "func readRuneSegments(t *testing.T, segments []string) {\n\tgot := \"\"\n\twant := strings.Join(segments, \"\")\n\ts := new(Scanner).Init(\u0026StringReader{data: segments})\n\tfor {\n\t\tch := s.Next()\n\t\tif ch == EOF {\n\t\t\tbreak\n\t\t}\n\t\tgot += string(ch)\n\t}\n\tif got != want {\n\t\tt.Errorf(\"segments=%v got=%s want=%s\", segments, got, want)\n\t}\n}",
    "filename": "/usr/local/go/src/text/scanner/scanner_test.go",
    "line": 33
  },
  {
    "id": 35,
    "text": "func TestNext(t *testing.T) {\n\tfor _, s := range segmentList {\n\t\treadRuneSegments(t, s)\n\t}\n}",
    "filename": "/usr/local/go/src/text/scanner/scanner_test.go",
    "line": 60
  },
  {
    "id": 36,
    "text": "func makeSource(pattern string) *bytes.Buffer {\n\tvar buf bytes.Buffer\n\tfor _, k := range tokenList {\n\t\tfmt.Fprintf(\u0026buf, pattern, k.text)\n\t}\n\treturn \u0026buf\n}",
    "filename": "/usr/local/go/src/text/scanner/scanner_test.go",
    "line": 228
  },
  {
    "id": 37,
    "text": "func checkTok(t *testing.T, s *Scanner, line int, got, want rune, text string) {\n\tif got != want {\n\t\tt.Fatalf(\"tok = %s, want %s for %q\", TokenString(got), TokenString(want), text)\n\t}\n\tif s.Line != line {\n\t\tt.Errorf(\"line = %d, want %d for %q\", s.Line, line, text)\n\t}\n\tstext := s.TokenText()\n\tif stext != text {\n\t\tt.Errorf(\"text = %q, want %q\", stext, text)\n\t} else {\n\t\t// check idempotency of TokenText() call\n\t\tstext = s.TokenText()\n\t\tif stext != text {\n\t\t\tt.Errorf(\"text = %q, want %q (idempotency check)\", stext, text)\n\t\t}\n\t}\n}",
    "filename": "/usr/local/go/src/text/scanner/scanner_test.go",
    "line": 236
  },
  {
    "id": 38,
    "text": "func checkTokErr(t *testing.T, s *Scanner, line int, want rune, text string) {\n\tprevCount := s.ErrorCount\n\tcheckTok(t, s, line, s.Scan(), want, text)\n\tif s.ErrorCount != prevCount+1 {\n\t\tt.Fatalf(\"want error for %q\", text)\n\t}\n}",
    "filename": "/usr/local/go/src/text/scanner/scanner_test.go",
    "line": 255
  },
  {
    "id": 39,
    "text": "func countNewlines(s string) int {\n\tn := 0\n\tfor _, ch := range s {\n\t\tif ch == '\\n' {\n\t\t\tn++\n\t\t}\n\t}\n\treturn n\n}",
    "filename": "/usr/local/go/src/text/scanner/scanner_test.go",
    "line": 263
  },
  {
    "id": 40,
    "text": "func testScan(t *testing.T, mode uint) {\n\ts := new(Scanner).Init(makeSource(\" \\t%s\\n\"))\n\ts.Mode = mode\n\ttok := s.Scan()\n\tline := 1\n\tfor _, k := range tokenList {\n\t\tif mode\u0026SkipComments == 0 || k.tok != Comment {\n\t\t\tcheckTok(t, s, line, tok, k.tok, k.text)\n\t\t\ttok = s.Scan()\n\t\t}\n\t\tline += countNewlines(k.text) + 1 // each token is on a new line\n\t}\n\tcheckTok(t, s, line, tok, EOF, \"\")\n}",
    "filename": "/usr/local/go/src/text/scanner/scanner_test.go",
    "line": 273
  },
  {
    "id": 41,
    "text": "func TestScan(t *testing.T) {\n\ttestScan(t, GoTokens)\n\ttestScan(t, GoTokens\u0026^SkipComments)\n}",
    "filename": "/usr/local/go/src/text/scanner/scanner_test.go",
    "line": 288
  },
  {
    "id": 42,
    "text": "func TestInvalidExponent(t *testing.T) {\n\tconst src = \"1.5e 1.5E 1e+ 1e- 1.5z\"\n\ts := new(Scanner).Init(strings.NewReader(src))\n\ts.Error = func(s *Scanner, msg string) {\n\t\tconst want = \"exponent has no digits\"\n\t\tif msg != want {\n\t\t\tt.Errorf(\"%s: got error %q; want %q\", s.TokenText(), msg, want)\n\t\t}\n\t}\n\tcheckTokErr(t, s, 1, Float, \"1.5e\")\n\tcheckTokErr(t, s, 1, Float, \"1.5E\")\n\tcheckTokErr(t, s, 1, Float, \"1e+\")\n\tcheckTokErr(t, s, 1, Float, \"1e-\")\n\tcheckTok(t, s, 1, s.Scan(), Float, \"1.5\")\n\tcheckTok(t, s, 1, s.Scan(), Ident, \"z\")\n\tcheckTok(t, s, 1, s.Scan(), EOF, \"\")\n\tif s.ErrorCount != 4 {\n\t\tt.Errorf(\"%d errors, want 4\", s.ErrorCount)\n\t}\n}",
    "filename": "/usr/local/go/src/text/scanner/scanner_test.go",
    "line": 293
  },
  {
    "id": 43,
    "text": "func TestPosition(t *testing.T) {\n\tsrc := makeSource(\"\\t\\t\\t\\t%s\\n\")\n\ts := new(Scanner).Init(src)\n\ts.Mode = GoTokens \u0026^ SkipComments\n\ts.Scan()\n\tpos := Position{\"\", 4, 1, 5}\n\tfor _, k := range tokenList {\n\t\tif s.Offset != pos.Offset {\n\t\t\tt.Errorf(\"offset = %d, want %d for %q\", s.Offset, pos.Offset, k.text)\n\t\t}\n\t\tif s.Line != pos.Line {\n\t\t\tt.Errorf(\"line = %d, want %d for %q\", s.Line, pos.Line, k.text)\n\t\t}\n\t\tif s.Column != pos.Column {\n\t\t\tt.Errorf(\"column = %d, want %d for %q\", s.Column, pos.Column, k.text)\n\t\t}\n\t\tpos.Offset += 4 + len(k.text) + 1     // 4 tabs + token bytes + newline\n\t\tpos.Line += countNewlines(k.text) + 1 // each token is on a new line\n\t\ts.Scan()\n\t}\n\t// make sure there were no token-internal errors reported by scanner\n\tif s.ErrorCount != 0 {\n\t\tt.Errorf(\"%d errors\", s.ErrorCount)\n\t}\n}",
    "filename": "/usr/local/go/src/text/scanner/scanner_test.go",
    "line": 314
  },
  {
    "id": 44,
    "text": "func TestScanZeroMode(t *testing.T) {\n\tsrc := makeSource(\"%s\\n\")\n\tstr := src.String()\n\ts := new(Scanner).Init(src)\n\ts.Mode = 0       // don't recognize any token classes\n\ts.Whitespace = 0 // don't skip any whitespace\n\ttok := s.Scan()\n\tfor i, ch := range str {\n\t\tif tok != ch {\n\t\t\tt.Fatalf(\"%d. tok = %s, want %s\", i, TokenString(tok), TokenString(ch))\n\t\t}\n\t\ttok = s.Scan()\n\t}\n\tif tok != EOF {\n\t\tt.Fatalf(\"tok = %s, want EOF\", TokenString(tok))\n\t}\n\tif s.ErrorCount != 0 {\n\t\tt.Errorf(\"%d errors\", s.ErrorCount)\n\t}\n}",
    "filename": "/usr/local/go/src/text/scanner/scanner_test.go",
    "line": 340
  },
  {
    "id": 45,
    "text": "func testScanSelectedMode(t *testing.T, mode uint, class rune) {\n\tsrc := makeSource(\"%s\\n\")\n\ts := new(Scanner).Init(src)\n\ts.Mode = mode\n\ttok := s.Scan()\n\tfor tok != EOF {\n\t\tif tok \u003c 0 \u0026\u0026 tok != class {\n\t\t\tt.Fatalf(\"tok = %s, want %s\", TokenString(tok), TokenString(class))\n\t\t}\n\t\ttok = s.Scan()\n\t}\n\tif s.ErrorCount != 0 {\n\t\tt.Errorf(\"%d errors\", s.ErrorCount)\n\t}\n}",
    "filename": "/usr/local/go/src/text/scanner/scanner_test.go",
    "line": 361
  },
  {
    "id": 46,
    "text": "func TestScanSelectedMask(t *testing.T) {\n\ttestScanSelectedMode(t, 0, 0)\n\ttestScanSelectedMode(t, ScanIdents, Ident)\n\t// Don't test ScanInts and ScanNumbers since some parts of\n\t// the floats in the source look like (invalid) octal ints\n\t// and ScanNumbers may return either Int or Float.\n\ttestScanSelectedMode(t, ScanChars, Char)\n\ttestScanSelectedMode(t, ScanStrings, String)\n\ttestScanSelectedMode(t, SkipComments, 0)\n\ttestScanSelectedMode(t, ScanComments, Comment)\n}",
    "filename": "/usr/local/go/src/text/scanner/scanner_test.go",
    "line": 377
  },
  {
    "id": 47,
    "text": "func TestScanCustomIdent(t *testing.T) {\n\tconst src = \"faab12345 a12b123 a12 3b\"\n\ts := new(Scanner).Init(strings.NewReader(src))\n\t// ident = ( 'a' | 'b' ) { digit } .\n\t// digit = '0' .. '3' .\n\t// with a maximum length of 4\n\ts.IsIdentRune = func(ch rune, i int) bool {\n\t\treturn i == 0 \u0026\u0026 (ch == 'a' || ch == 'b') || 0 \u003c i \u0026\u0026 i \u003c 4 \u0026\u0026 '0' \u003c= ch \u0026\u0026 ch \u003c= '3'\n\t}\n\tcheckTok(t, s, 1, s.Scan(), 'f', \"f\")\n\tcheckTok(t, s, 1, s.Scan(), Ident, \"a\")\n\tcheckTok(t, s, 1, s.Scan(), Ident, \"a\")\n\tcheckTok(t, s, 1, s.Scan(), Ident, \"b123\")\n\tcheckTok(t, s, 1, s.Scan(), Int, \"45\")\n\tcheckTok(t, s, 1, s.Scan(), Ident, \"a12\")\n\tcheckTok(t, s, 1, s.Scan(), Ident, \"b123\")\n\tcheckTok(t, s, 1, s.Scan(), Ident, \"a12\")\n\tcheckTok(t, s, 1, s.Scan(), Int, \"3\")\n\tcheckTok(t, s, 1, s.Scan(), Ident, \"b\")\n\tcheckTok(t, s, 1, s.Scan(), EOF, \"\")\n}",
    "filename": "/usr/local/go/src/text/scanner/scanner_test.go",
    "line": 389
  },
  {
    "id": 48,
    "text": "func TestScanNext(t *testing.T) {\n\tconst BOM = '\\uFEFF'\n\tBOMs := string(BOM)\n\ts := new(Scanner).Init(strings.NewReader(BOMs + \"if a == bcd /* com\" + BOMs + \"ment */ {\\n\\ta += c\\n}\" + BOMs + \"// line comment ending in eof\"))\n\tcheckTok(t, s, 1, s.Scan(), Ident, \"if\") // the first BOM is ignored\n\tcheckTok(t, s, 1, s.Scan(), Ident, \"a\")\n\tcheckTok(t, s, 1, s.Scan(), '=', \"=\")\n\tcheckTok(t, s, 0, s.Next(), '=', \"\")\n\tcheckTok(t, s, 0, s.Next(), ' ', \"\")\n\tcheckTok(t, s, 0, s.Next(), 'b', \"\")\n\tcheckTok(t, s, 1, s.Scan(), Ident, \"cd\")\n\tcheckTok(t, s, 1, s.Scan(), '{', \"{\")\n\tcheckTok(t, s, 2, s.Scan(), Ident, \"a\")\n\tcheckTok(t, s, 2, s.Scan(), '+', \"+\")\n\tcheckTok(t, s, 0, s.Next(), '=', \"\")\n\tcheckTok(t, s, 2, s.Scan(), Ident, \"c\")\n\tcheckTok(t, s, 3, s.Scan(), '}', \"}\")\n\tcheckTok(t, s, 3, s.Scan(), BOM, BOMs)\n\tcheckTok(t, s, 3, s.Scan(), -1, \"\")\n\tif s.ErrorCount != 0 {\n\t\tt.Errorf(\"%d errors\", s.ErrorCount)\n\t}\n}",
    "filename": "/usr/local/go/src/text/scanner/scanner_test.go",
    "line": 411
  },
  {
    "id": 49,
    "text": "func TestScanWhitespace(t *testing.T) {\n\tvar buf bytes.Buffer\n\tvar ws uint64\n\t// start at 1, NUL character is not allowed\n\tfor ch := byte(1); ch \u003c ' '; ch++ {\n\t\tbuf.WriteByte(ch)\n\t\tws |= 1 \u003c\u003c ch\n\t}\n\tconst orig = 'x'\n\tbuf.WriteByte(orig)\n\n\ts := new(Scanner).Init(\u0026buf)\n\ts.Mode = 0\n\ts.Whitespace = ws\n\ttok := s.Scan()\n\tif tok != orig {\n\t\tt.Errorf(\"tok = %s, want %s\", TokenString(tok), TokenString(orig))\n\t}\n}",
    "filename": "/usr/local/go/src/text/scanner/scanner_test.go",
    "line": 435
  },
  {
    "id": 50,
    "text": "func testError(t *testing.T, src, pos, msg string, tok rune) {\n\ts := new(Scanner).Init(strings.NewReader(src))\n\terrorCalled := false\n\ts.Error = func(s *Scanner, m string) {\n\t\tif !errorCalled {\n\t\t\t// only look at first error\n\t\t\tif p := s.Pos().String(); p != pos {\n\t\t\t\tt.Errorf(\"pos = %q, want %q for %q\", p, pos, src)\n\t\t\t}\n\t\t\tif m != msg {\n\t\t\t\tt.Errorf(\"msg = %q, want %q for %q\", m, msg, src)\n\t\t\t}\n\t\t\terrorCalled = true\n\t\t}\n\t}\n\ttk := s.Scan()\n\tif tk != tok {\n\t\tt.Errorf(\"tok = %s, want %s for %q\", TokenString(tk), TokenString(tok), src)\n\t}\n\tif !errorCalled {\n\t\tt.Errorf(\"error handler not called for %q\", src)\n\t}\n\tif s.ErrorCount == 0 {\n\t\tt.Errorf(\"count = %d, want \u003e 0 for %q\", s.ErrorCount, src)\n\t}\n}",
    "filename": "/usr/local/go/src/text/scanner/scanner_test.go",
    "line": 455
  },
  {
    "id": 51,
    "text": "func TestError(t *testing.T) {\n\ttestError(t, \"\\x00\", \"\u003cinput\u003e:1:1\", \"invalid character NUL\", 0)\n\ttestError(t, \"\\x80\", \"\u003cinput\u003e:1:1\", \"invalid UTF-8 encoding\", utf8.RuneError)\n\ttestError(t, \"\\xff\", \"\u003cinput\u003e:1:1\", \"invalid UTF-8 encoding\", utf8.RuneError)\n\n\ttestError(t, \"a\\x00\", \"\u003cinput\u003e:1:2\", \"invalid character NUL\", Ident)\n\ttestError(t, \"ab\\x80\", \"\u003cinput\u003e:1:3\", \"invalid UTF-8 encoding\", Ident)\n\ttestError(t, \"abc\\xff\", \"\u003cinput\u003e:1:4\", \"invalid UTF-8 encoding\", Ident)\n\n\ttestError(t, `\"a`+\"\\x00\", \"\u003cinput\u003e:1:3\", \"invalid character NUL\", String)\n\ttestError(t, `\"ab`+\"\\x80\", \"\u003cinput\u003e:1:4\", \"invalid UTF-8 encoding\", String)\n\ttestError(t, `\"abc`+\"\\xff\", \"\u003cinput\u003e:1:5\", \"invalid UTF-8 encoding\", String)\n\n\ttestError(t, \"`a\"+\"\\x00\", \"\u003cinput\u003e:1:3\", \"invalid character NUL\", RawString)\n\ttestError(t, \"`ab\"+\"\\x80\", \"\u003cinput\u003e:1:4\", \"invalid UTF-8 encoding\", RawString)\n\ttestError(t, \"`abc\"+\"\\xff\", \"\u003cinput\u003e:1:5\", \"invalid UTF-8 encoding\", RawString)\n\n\ttestError(t, `'\\\"'`, \"\u003cinput\u003e:1:3\", \"invalid char escape\", Char)\n\ttestError(t, `\"\\'\"`, \"\u003cinput\u003e:1:3\", \"invalid char escape\", String)\n\n\ttestError(t, `01238`, \"\u003cinput\u003e:1:6\", \"invalid digit '8' in octal literal\", Int)\n\ttestError(t, `01238123`, \"\u003cinput\u003e:1:9\", \"invalid digit '8' in octal literal\", Int)\n\ttestError(t, `0x`, \"\u003cinput\u003e:1:3\", \"hexadecimal literal has no digits\", Int)\n\ttestError(t, `0xg`, \"\u003cinput\u003e:1:3\", \"hexadecimal literal has no digits\", Int)\n\ttestError(t, `'aa'`, \"\u003cinput\u003e:1:4\", \"invalid char literal\", Char)\n\ttestError(t, `1.5e`, \"\u003cinput\u003e:1:5\", \"exponent has no digits\", Float)\n\ttestError(t, `1.5E`, \"\u003cinput\u003e:1:5\", \"exponent has no digits\", Float)\n\ttestError(t, `1.5e+`, \"\u003cinput\u003e:1:6\", \"exponent has no digits\", Float)\n\ttestError(t, `1.5e-`, \"\u003cinput\u003e:1:6\", \"exponent has no digits\", Float)\n\n\ttestError(t, `'`, \"\u003cinput\u003e:1:2\", \"literal not terminated\", Char)\n\ttestError(t, `'`+\"\\n\", \"\u003cinput\u003e:1:2\", \"literal not terminated\", Char)\n\ttestError(t, `\"abc`, \"\u003cinput\u003e:1:5\", \"literal not terminated\", String)\n\ttestError(t, `\"abc`+\"\\n\", \"\u003cinput\u003e:1:5\", \"literal not terminated\", String)\n\ttestError(t, \"`abc\\n\", \"\u003cinput\u003e:2:1\", \"literal not terminated\", RawString)\n\ttestError(t, `/*/`, \"\u003cinput\u003e:1:4\", \"comment not terminated\", EOF)\n}",
    "filename": "/usr/local/go/src/text/scanner/scanner_test.go",
    "line": 482
  },
  {
    "id": 52,
    "text": "func (errReader) Read(b []byte) (int, error) {\n\treturn 0, io.ErrNoProgress // some error that is not io.EOF\n}",
    "filename": "/usr/local/go/src/text/scanner/scanner_test.go",
    "line": 523
  },
  {
    "id": 53,
    "text": "func TestIOError(t *testing.T) {\n\ts := new(Scanner).Init(errReader{})\n\terrorCalled := false\n\ts.Error = func(s *Scanner, msg string) {\n\t\tif !errorCalled {\n\t\t\tif want := io.ErrNoProgress.Error(); msg != want {\n\t\t\t\tt.Errorf(\"msg = %q, want %q\", msg, want)\n\t\t\t}\n\t\t\terrorCalled = true\n\t\t}\n\t}\n\ttok := s.Scan()\n\tif tok != EOF {\n\t\tt.Errorf(\"tok = %s, want EOF\", TokenString(tok))\n\t}\n\tif !errorCalled {\n\t\tt.Errorf(\"error handler not called\")\n\t}\n}",
    "filename": "/usr/local/go/src/text/scanner/scanner_test.go",
    "line": 527
  },
  {
    "id": 54,
    "text": "func checkPos(t *testing.T, got, want Position) {\n\tif got.Offset != want.Offset || got.Line != want.Line || got.Column != want.Column {\n\t\tt.Errorf(\"got offset, line, column = %d, %d, %d; want %d, %d, %d\",\n\t\t\tgot.Offset, got.Line, got.Column, want.Offset, want.Line, want.Column)\n\t}\n}",
    "filename": "/usr/local/go/src/text/scanner/scanner_test.go",
    "line": 547
  },
  {
    "id": 55,
    "text": "func checkNextPos(t *testing.T, s *Scanner, offset, line, column int, char rune) {\n\tif ch := s.Next(); ch != char {\n\t\tt.Errorf(\"ch = %s, want %s\", TokenString(ch), TokenString(char))\n\t}\n\twant := Position{Offset: offset, Line: line, Column: column}\n\tcheckPos(t, s.Pos(), want)\n}",
    "filename": "/usr/local/go/src/text/scanner/scanner_test.go",
    "line": 554
  },
  {
    "id": 56,
    "text": "func checkScanPos(t *testing.T, s *Scanner, offset, line, column int, char rune) {\n\twant := Position{Offset: offset, Line: line, Column: column}\n\tcheckPos(t, s.Pos(), want)\n\tif ch := s.Scan(); ch != char {\n\t\tt.Errorf(\"ch = %s, want %s\", TokenString(ch), TokenString(char))\n\t\tif string(ch) != s.TokenText() {\n\t\t\tt.Errorf(\"tok = %q, want %q\", s.TokenText(), string(ch))\n\t\t}\n\t}\n\tcheckPos(t, s.Position, want)\n}",
    "filename": "/usr/local/go/src/text/scanner/scanner_test.go",
    "line": 562
  },
  {
    "id": 57,
    "text": "func TestPos(t *testing.T) {\n\t// corner case: empty source\n\ts := new(Scanner).Init(strings.NewReader(\"\"))\n\tcheckPos(t, s.Pos(), Position{Offset: 0, Line: 1, Column: 1})\n\ts.Peek() // peek doesn't affect the position\n\tcheckPos(t, s.Pos(), Position{Offset: 0, Line: 1, Column: 1})\n\n\t// corner case: source with only a newline\n\ts = new(Scanner).Init(strings.NewReader(\"\\n\"))\n\tcheckPos(t, s.Pos(), Position{Offset: 0, Line: 1, Column: 1})\n\tcheckNextPos(t, s, 1, 2, 1, '\\n')\n\t// after EOF position doesn't change\n\tfor i := 10; i \u003e 0; i-- {\n\t\tcheckScanPos(t, s, 1, 2, 1, EOF)\n\t}\n\tif s.ErrorCount != 0 {\n\t\tt.Errorf(\"%d errors\", s.ErrorCount)\n\t}\n\n\t// corner case: source with only a single character\n\ts = new(Scanner).Init(strings.NewReader(\"本\"))\n\tcheckPos(t, s.Pos(), Position{Offset: 0, Line: 1, Column: 1})\n\tcheckNextPos(t, s, 3, 1, 2, '本')\n\t// after EOF position doesn't change\n\tfor i := 10; i \u003e 0; i-- {\n\t\tcheckScanPos(t, s, 3, 1, 2, EOF)\n\t}\n\tif s.ErrorCount != 0 {\n\t\tt.Errorf(\"%d errors\", s.ErrorCount)\n\t}\n\n\t// positions after calling Next\n\ts = new(Scanner).Init(strings.NewReader(\"  foo६४  \\n\\n本語\\n\"))\n\tcheckNextPos(t, s, 1, 1, 2, ' ')\n\ts.Peek() // peek doesn't affect the position\n\tcheckNextPos(t, s, 2, 1, 3, ' ')\n\tcheckNextPos(t, s, 3, 1, 4, 'f')\n\tcheckNextPos(t, s, 4, 1, 5, 'o')\n\tcheckNextPos(t, s, 5, 1, 6, 'o')\n\tcheckNextPos(t, s, 8, 1, 7, '६')\n\tcheckNextPos(t, s, 11, 1, 8, '४')\n\tcheckNextPos(t, s, 12, 1, 9, ' ')\n\tcheckNextPos(t, s, 13, 1, 10, ' ')\n\tcheckNextPos(t, s, 14, 2, 1, '\\n')\n\tcheckNextPos(t, s, 15, 3, 1, '\\n')\n\tcheckNextPos(t, s, 18, 3, 2, '本')\n\tcheckNextPos(t, s, 21, 3, 3, '語')\n\tcheckNextPos(t, s, 22, 4, 1, '\\n')\n\t// after EOF position doesn't change\n\tfor i := 10; i \u003e 0; i-- {\n\t\tcheckScanPos(t, s, 22, 4, 1, EOF)\n\t}\n\tif s.ErrorCount != 0 {\n\t\tt.Errorf(\"%d errors\", s.ErrorCount)\n\t}\n\n\t// positions after calling Scan\n\ts = new(Scanner).Init(strings.NewReader(\"abc\\n本語\\n\\nx\"))\n\ts.Mode = 0\n\ts.Whitespace = 0\n\tcheckScanPos(t, s, 0, 1, 1, 'a')\n\ts.Peek() // peek doesn't affect the position\n\tcheckScanPos(t, s, 1, 1, 2, 'b')\n\tcheckScanPos(t, s, 2, 1, 3, 'c')\n\tcheckScanPos(t, s, 3, 1, 4, '\\n')\n\tcheckScanPos(t, s, 4, 2, 1, '本')\n\tcheckScanPos(t, s, 7, 2, 2, '語')\n\tcheckScanPos(t, s, 10, 2, 3, '\\n')\n\tcheckScanPos(t, s, 11, 3, 1, '\\n')\n\tcheckScanPos(t, s, 12, 4, 1, 'x')\n\t// after EOF position doesn't change\n\tfor i := 10; i \u003e 0; i-- {\n\t\tcheckScanPos(t, s, 13, 4, 2, EOF)\n\t}\n\tif s.ErrorCount != 0 {\n\t\tt.Errorf(\"%d errors\", s.ErrorCount)\n\t}\n}",
    "filename": "/usr/local/go/src/text/scanner/scanner_test.go",
    "line": 574
  },
  {
    "id": 58,
    "text": "func (r *countReader) Read([]byte) (int, error) {\n\t*r++\n\treturn 0, io.EOF\n}",
    "filename": "/usr/local/go/src/text/scanner/scanner_test.go",
    "line": 655
  },
  {
    "id": 59,
    "text": "func TestNextEOFHandling(t *testing.T) {\n\tvar r countReader\n\n\t// corner case: empty source\n\ts := new(Scanner).Init(\u0026r)\n\n\ttok := s.Next()\n\tif tok != EOF {\n\t\tt.Error(\"1) EOF not reported\")\n\t}\n\n\ttok = s.Peek()\n\tif tok != EOF {\n\t\tt.Error(\"2) EOF not reported\")\n\t}\n\n\tif r != 1 {\n\t\tt.Errorf(\"scanner called Read %d times, not once\", r)\n\t}\n}",
    "filename": "/usr/local/go/src/text/scanner/scanner_test.go",
    "line": 660
  },
  {
    "id": 60,
    "text": "func TestScanEOFHandling(t *testing.T) {\n\tvar r countReader\n\n\t// corner case: empty source\n\ts := new(Scanner).Init(\u0026r)\n\n\ttok := s.Scan()\n\tif tok != EOF {\n\t\tt.Error(\"1) EOF not reported\")\n\t}\n\n\ttok = s.Peek()\n\tif tok != EOF {\n\t\tt.Error(\"2) EOF not reported\")\n\t}\n\n\tif r != 1 {\n\t\tt.Errorf(\"scanner called Read %d times, not once\", r)\n\t}\n}",
    "filename": "/usr/local/go/src/text/scanner/scanner_test.go",
    "line": 681
  },
  {
    "id": 61,
    "text": "func TestIssue29723(t *testing.T) {\n\ts := new(Scanner).Init(strings.NewReader(`x \"`))\n\ts.Error = func(s *Scanner, _ string) {\n\t\tgot := s.TokenText() // this call shouldn't panic\n\t\tconst want = `\"`\n\t\tif got != want {\n\t\t\tt.Errorf(\"got %q; want %q\", got, want)\n\t\t}\n\t}\n\tfor r := s.Scan(); r != EOF; r = s.Scan() {\n\t}\n}",
    "filename": "/usr/local/go/src/text/scanner/scanner_test.go",
    "line": 702
  },
  {
    "id": 62,
    "text": "func TestNumbers(t *testing.T) {\n\tfor _, test := range []struct {\n\t\ttok              rune\n\t\tsrc, tokens, err string\n\t}{\n\t\t// binaries\n\t\t{Int, \"0b0\", \"0b0\", \"\"},\n\t\t{Int, \"0b1010\", \"0b1010\", \"\"},\n\t\t{Int, \"0B1110\", \"0B1110\", \"\"},\n\n\t\t{Int, \"0b\", \"0b\", \"binary literal has no digits\"},\n\t\t{Int, \"0b0190\", \"0b0190\", \"invalid digit '9' in binary literal\"},\n\t\t{Int, \"0b01a0\", \"0b01 a0\", \"\"}, // only accept 0-9\n\n\t\t// binary floats (invalid)\n\t\t{Float, \"0b.\", \"0b.\", \"invalid radix point in binary literal\"},\n\t\t{Float, \"0b.1\", \"0b.1\", \"invalid radix point in binary literal\"},\n\t\t{Float, \"0b1.0\", \"0b1.0\", \"invalid radix point in binary literal\"},\n\t\t{Float, \"0b1e10\", \"0b1e10\", \"'e' exponent requires decimal mantissa\"},\n\t\t{Float, \"0b1P-1\", \"0b1P-1\", \"'P' exponent requires hexadecimal mantissa\"},\n\n\t\t// octals\n\t\t{Int, \"0o0\", \"0o0\", \"\"},\n\t\t{Int, \"0o1234\", \"0o1234\", \"\"},\n\t\t{Int, \"0O1234\", \"0O1234\", \"\"},\n\n\t\t{Int, \"0o\", \"0o\", \"octal literal has no digits\"},\n\t\t{Int, \"0o8123\", \"0o8123\", \"invalid digit '8' in octal literal\"},\n\t\t{Int, \"0o1293\", \"0o1293\", \"invalid digit '9' in octal literal\"},\n\t\t{Int, \"0o12a3\", \"0o12 a3\", \"\"}, // only accept 0-9\n\n\t\t// octal floats (invalid)\n\t\t{Float, \"0o.\", \"0o.\", \"invalid radix point in octal literal\"},\n\t\t{Float, \"0o.2\", \"0o.2\", \"invalid radix point in octal literal\"},\n\t\t{Float, \"0o1.2\", \"0o1.2\", \"invalid radix point in octal literal\"},\n\t\t{Float, \"0o1E+2\", \"0o1E+2\", \"'E' exponent requires decimal mantissa\"},\n\t\t{Float, \"0o1p10\", \"0o1p10\", \"'p' exponent requires hexadecimal mantissa\"},\n\n\t\t// 0-octals\n\t\t{Int, \"0\", \"0\", \"\"},\n\t\t{Int, \"0123\", \"0123\", \"\"},\n\n\t\t{Int, \"08123\", \"08123\", \"invalid digit '8' in octal literal\"},\n\t\t{Int, \"01293\", \"01293\", \"invalid digit '9' in octal literal\"},\n\t\t{Int, \"0F.\", \"0 F .\", \"\"}, // only accept 0-9\n\t\t{Int, \"0123F.\", \"0123 F .\", \"\"},\n\t\t{Int, \"0123456x\", \"0123456 x\", \"\"},\n\n\t\t// decimals\n\t\t{Int, \"1\", \"1\", \"\"},\n\t\t{Int, \"1234\", \"1234\", \"\"},\n\n\t\t{Int, \"1f\", \"1 f\", \"\"}, // only accept 0-9\n\n\t\t// decimal floats\n\t\t{Float, \"0.\", \"0.\", \"\"},\n\t\t{Float, \"123.\", \"123.\", \"\"},\n\t\t{Float, \"0123.\", \"0123.\", \"\"},\n\n\t\t{Float, \".0\", \".0\", \"\"},\n\t\t{Float, \".123\", \".123\", \"\"},\n\t\t{Float, \".0123\", \".0123\", \"\"},\n\n\t\t{Float, \"0.0\", \"0.0\", \"\"},\n\t\t{Float, \"123.123\", \"123.123\", \"\"},\n\t\t{Float, \"0123.0123\", \"0123.0123\", \"\"},\n\n\t\t{Float, \"0e0\", \"0e0\", \"\"},\n\t\t{Float, \"123e+0\", \"123e+0\", \"\"},\n\t\t{Float, \"0123E-1\", \"0123E-1\", \"\"},\n\n\t\t{Float, \"0.e+1\", \"0.e+1\", \"\"},\n\t\t{Float, \"123.E-10\", \"123.E-10\", \"\"},\n\t\t{Float, \"0123.e123\", \"0123.e123\", \"\"},\n\n\t\t{Float, \".0e-1\", \".0e-1\", \"\"},\n\t\t{Float, \".123E+10\", \".123E+10\", \"\"},\n\t\t{Float, \".0123E123\", \".0123E123\", \"\"},\n\n\t\t{Float, \"0.0e1\", \"0.0e1\", \"\"},\n\t\t{Float, \"123.123E-10\", \"123.123E-10\", \"\"},\n\t\t{Float, \"0123.0123e+456\", \"0123.0123e+456\", \"\"},\n\n\t\t{Float, \"0e\", \"0e\", \"exponent has no digits\"},\n\t\t{Float, \"0E+\", \"0E+\", \"exponent has no digits\"},\n\t\t{Float, \"1e+f\", \"1e+ f\", \"exponent has no digits\"},\n\t\t{Float, \"0p0\", \"0p0\", \"'p' exponent requires hexadecimal mantissa\"},\n\t\t{Float, \"1.0P-1\", \"1.0P-1\", \"'P' exponent requires hexadecimal mantissa\"},\n\n\t\t// hexadecimals\n\t\t{Int, \"0x0\", \"0x0\", \"\"},\n\t\t{Int, \"0x1234\", \"0x1234\", \"\"},\n\t\t{Int, \"0xcafef00d\", \"0xcafef00d\", \"\"},\n\t\t{Int, \"0XCAFEF00D\", \"0XCAFEF00D\", \"\"},\n\n\t\t{Int, \"0x\", \"0x\", \"hexadecimal literal has no digits\"},\n\t\t{Int, \"0x1g\", \"0x1 g\", \"\"},\n\n\t\t// hexadecimal floats\n\t\t{Float, \"0x0p0\", \"0x0p0\", \"\"},\n\t\t{Float, \"0x12efp-123\", \"0x12efp-123\", \"\"},\n\t\t{Float, \"0xABCD.p+0\", \"0xABCD.p+0\", \"\"},\n\t\t{Float, \"0x.0189P-0\", \"0x.0189P-0\", \"\"},\n\t\t{Float, \"0x1.ffffp+1023\", \"0x1.ffffp+1023\", \"\"},\n\n\t\t{Float, \"0x.\", \"0x.\", \"hexadecimal literal has no digits\"},\n\t\t{Float, \"0x0.\", \"0x0.\", \"hexadecimal mantissa requires a 'p' exponent\"},\n\t\t{Float, \"0x.0\", \"0x.0\", \"hexadecimal mantissa requires a 'p' exponent\"},\n\t\t{Float, \"0x1.1\", \"0x1.1\", \"hexadecimal mantissa requires a 'p' exponent\"},\n\t\t{Float, \"0x1.1e0\", \"0x1.1e0\", \"hexadecimal mantissa requires a 'p' exponent\"},\n\t\t{Float, \"0x1.2gp1a\", \"0x1.2 gp1a\", \"hexadecimal mantissa requires a 'p' exponent\"},\n\t\t{Float, \"0x0p\", \"0x0p\", \"exponent has no digits\"},\n\t\t{Float, \"0xeP-\", \"0xeP-\", \"exponent has no digits\"},\n\t\t{Float, \"0x1234PAB\", \"0x1234P AB\", \"exponent has no digits\"},\n\t\t{Float, \"0x1.2p1a\", \"0x1.2p1 a\", \"\"},\n\n\t\t// separators\n\t\t{Int, \"0b_1000_0001\", \"0b_1000_0001\", \"\"},\n\t\t{Int, \"0o_600\", \"0o_600\", \"\"},\n\t\t{Int, \"0_466\", \"0_466\", \"\"},\n\t\t{Int, \"1_000\", \"1_000\", \"\"},\n\t\t{Float, \"1_000.000_1\", \"1_000.000_1\", \"\"},\n\t\t{Int, \"0x_f00d\", \"0x_f00d\", \"\"},\n\t\t{Float, \"0x_f00d.0p1_2\", \"0x_f00d.0p1_2\", \"\"},\n\n\t\t{Int, \"0b__1000\", \"0b__1000\", \"'_' must separate successive digits\"},\n\t\t{Int, \"0o60___0\", \"0o60___0\", \"'_' must separate successive digits\"},\n\t\t{Int, \"0466_\", \"0466_\", \"'_' must separate successive digits\"},\n\t\t{Float, \"1_.\", \"1_.\", \"'_' must separate successive digits\"},\n\t\t{Float, \"0._1\", \"0._1\", \"'_' must separate successive digits\"},\n\t\t{Float, \"2.7_e0\", \"2.7_e0\", \"'_' must separate successive digits\"},\n\t\t{Int, \"0x___0\", \"0x___0\", \"'_' must separate successive digits\"},\n\t\t{Float, \"0x1.0_p0\", \"0x1.0_p0\", \"'_' must separate successive digits\"},\n\t} {\n\t\ts := new(Scanner).Init(strings.NewReader(test.src))\n\t\tvar err string\n\t\ts.Error = func(s *Scanner, msg string) {\n\t\t\tif err == \"\" {\n\t\t\t\terr = msg\n\t\t\t}\n\t\t}\n\n\t\tfor i, want := range strings.Split(test.tokens, \" \") {\n\t\t\terr = \"\"\n\t\t\ttok := s.Scan()\n\t\t\tlit := s.TokenText()\n\t\t\tif i == 0 {\n\t\t\t\tif tok != test.tok {\n\t\t\t\t\tt.Errorf(\"%q: got token %s; want %s\", test.src, TokenString(tok), TokenString(test.tok))\n\t\t\t\t}\n\t\t\t\tif err != test.err {\n\t\t\t\t\tt.Errorf(\"%q: got error %q; want %q\", test.src, err, test.err)\n\t\t\t\t}\n\t\t\t}\n\t\t\tif lit != want {\n\t\t\t\tt.Errorf(\"%q: got literal %q (%s); want %s\", test.src, lit, TokenString(tok), want)\n\t\t\t}\n\t\t}\n\n\t\t// make sure we read all\n\t\tif tok := s.Scan(); tok != EOF {\n\t\t\tt.Errorf(\"%q: got %s; want EOF\", test.src, TokenString(tok))\n\t\t}\n\t}\n}",
    "filename": "/usr/local/go/src/text/scanner/scanner_test.go",
    "line": 715
  },
  {
    "id": 63,
    "text": "func TestIssue30320(t *testing.T) {\n\tfor _, test := range []struct {\n\t\tin, want string\n\t\tmode     uint\n\t}{\n\t\t{\"foo01.bar31.xx-0-1-1-0\", \"01 31 0 1 1 0\", ScanInts},\n\t\t{\"foo0/12/0/5.67\", \"0 12 0 5 67\", ScanInts},\n\t\t{\"xxx1e0yyy\", \"1 0\", ScanInts},\n\t\t{\"1_2\", \"1_2\", ScanInts},\n\t\t{\"xxx1.0yyy2e3ee\", \"1 0 2 3\", ScanInts},\n\t\t{\"xxx1.0yyy2e3ee\", \"1.0 2e3\", ScanFloats},\n\t} {\n\t\tgot := extractInts(test.in, test.mode)\n\t\tif got != test.want {\n\t\t\tt.Errorf(\"%q: got %q; want %q\", test.in, got, test.want)\n\t\t}\n\t}\n}",
    "filename": "/usr/local/go/src/text/scanner/scanner_test.go",
    "line": 881
  },
  {
    "id": 64,
    "text": "func extractInts(t string, mode uint) (res string) {\n\tvar s Scanner\n\ts.Init(strings.NewReader(t))\n\ts.Mode = mode\n\tfor {\n\t\tswitch tok := s.Scan(); tok {\n\t\tcase Int, Float:\n\t\t\tif len(res) \u003e 0 {\n\t\t\t\tres += \" \"\n\t\t\t}\n\t\t\tres += s.TokenText()\n\t\tcase EOF:\n\t\t\treturn\n\t\t}\n\t}\n}",
    "filename": "/usr/local/go/src/text/scanner/scanner_test.go",
    "line": 900
  },
  {
    "id": 65,
    "text": "func TestIssue50909(t *testing.T) {\n\tvar s Scanner\n\ts.Init(strings.NewReader(\"hello \\n\\nworld\\n!\\n\"))\n\ts.IsIdentRune = func(ch rune, _ int) bool { return ch != '\\n' }\n\n\tr := \"\"\n\tn := 0\n\tfor s.Scan() != EOF \u0026\u0026 n \u003c 10 {\n\t\tr += s.TokenText()\n\t\tn++\n\t}\n\n\tconst R = \"hello world!\"\n\tconst N = 3\n\tif r != R || n != N {\n\t\tt.Errorf(\"got %q (n = %d); want %q (n = %d)\", r, n, R, N)\n\t}\n}",
    "filename": "/usr/local/go/src/text/scanner/scanner_test.go",
    "line": 917
  },
  {
    "id": 66,
    "text": "func ExampleWriter_Init() {\n\tw := new(tabwriter.Writer)\n\n\t// Format in tab-separated columns with a tab stop of 8.\n\tw.Init(os.Stdout, 0, 8, 0, '\\t', 0)\n\tfmt.Fprintln(w, \"a\\tb\\tc\\td\\t.\")\n\tfmt.Fprintln(w, \"123\\t12345\\t1234567\\t123456789\\t.\")\n\tfmt.Fprintln(w)\n\tw.Flush()\n\n\t// Format right-aligned in space-separated columns of minimal width 5\n\t// and at least one blank of padding (so wider column entries do not\n\t// touch each other).\n\tw.Init(os.Stdout, 5, 0, 1, ' ', tabwriter.AlignRight)\n\tfmt.Fprintln(w, \"a\\tb\\tc\\td\\t.\")\n\tfmt.Fprintln(w, \"123\\t12345\\t1234567\\t123456789\\t.\")\n\tfmt.Fprintln(w)\n\tw.Flush()\n\n\t// output:\n\t// a\tb\tc\td\t\t.\n\t// 123\t12345\t1234567\t123456789\t.\n\t//\n\t//     a     b       c         d.\n\t//   123 12345 1234567 123456789.\n}",
    "filename": "/usr/local/go/src/text/tabwriter/example_test.go",
    "line": 13
  },
  {
    "id": 67,
    "text": "func Example_elastic() {\n\t// Observe how the b's and the d's, despite appearing in the\n\t// second cell of each line, belong to different columns.\n\tw := tabwriter.NewWriter(os.Stdout, 0, 0, 1, '.', tabwriter.AlignRight|tabwriter.Debug)\n\tfmt.Fprintln(w, \"a\\tb\\tc\")\n\tfmt.Fprintln(w, \"aa\\tbb\\tcc\")\n\tfmt.Fprintln(w, \"aaa\\t\") // trailing tab\n\tfmt.Fprintln(w, \"aaaa\\tdddd\\teeee\")\n\tw.Flush()\n\n\t// output:\n\t// ....a|..b|c\n\t// ...aa|.bb|cc\n\t// ..aaa|\n\t// .aaaa|.dddd|eeee\n}",
    "filename": "/usr/local/go/src/text/tabwriter/example_test.go",
    "line": 40
  },
  {
    "id": 68,
    "text": "func Example_trailingTab() {\n\t// Observe that the third line has no trailing tab,\n\t// so its final cell is not part of an aligned column.\n\tconst padding = 3\n\tw := tabwriter.NewWriter(os.Stdout, 0, 0, padding, '-', tabwriter.AlignRight|tabwriter.Debug)\n\tfmt.Fprintln(w, \"a\\tb\\taligned\\t\")\n\tfmt.Fprintln(w, \"aa\\tbb\\taligned\\t\")\n\tfmt.Fprintln(w, \"aaa\\tbbb\\tunaligned\") // no trailing tab\n\tfmt.Fprintln(w, \"aaaa\\tbbbb\\taligned\\t\")\n\tw.Flush()\n\n\t// output:\n\t// ------a|------b|---aligned|\n\t// -----aa|-----bb|---aligned|\n\t// ----aaa|----bbb|unaligned\n\t// ---aaaa|---bbbb|---aligned|\n}",
    "filename": "/usr/local/go/src/text/tabwriter/example_test.go",
    "line": 57
  },
  {
    "id": 69,
    "text": "func (b *Writer) addLine(flushed bool) {\n\t// Grow slice instead of appending,\n\t// as that gives us an opportunity\n\t// to re-use an existing []cell.\n\tif n := len(b.lines) + 1; n \u003c= cap(b.lines) {\n\t\tb.lines = b.lines[:n]\n\t\tb.lines[n-1] = b.lines[n-1][:0]\n\t} else {\n\t\tb.lines = append(b.lines, nil)\n\t}\n\n\tif !flushed {\n\t\t// The previous line is probably a good indicator\n\t\t// of how many cells the current line will have.\n\t\t// If the current line's capacity is smaller than that,\n\t\t// abandon it and make a new one.\n\t\tif n := len(b.lines); n \u003e= 2 {\n\t\t\tif prev := len(b.lines[n-2]); prev \u003e cap(b.lines[n-1]) {\n\t\t\t\tb.lines[n-1] = make([]cell, 0, prev)\n\t\t\t}\n\t\t}\n\t}\n}",
    "filename": "/usr/local/go/src/text/tabwriter/tabwriter.go",
    "line": 111
  },
  {
    "id": 70,
    "text": "func (b *Writer) reset() {\n\tb.buf = b.buf[:0]\n\tb.pos = 0\n\tb.cell = cell{}\n\tb.endChar = 0\n\tb.lines = b.lines[0:0]\n\tb.widths = b.widths[0:0]\n\tb.addLine(true)\n}",
    "filename": "/usr/local/go/src/text/tabwriter/tabwriter.go",
    "line": 136
  },
  {
    "id": 71,
    "text": "func (b *Writer) Init(output io.Writer, minwidth, tabwidth, padding int, padchar byte, flags uint) *Writer {\n\tif minwidth \u003c 0 || tabwidth \u003c 0 || padding \u003c 0 {\n\t\tpanic(\"negative minwidth, tabwidth, or padding\")\n\t}\n\tb.output = output\n\tb.minwidth = minwidth\n\tb.tabwidth = tabwidth\n\tb.padding = padding\n\tfor i := range b.padbytes {\n\t\tb.padbytes[i] = padchar\n\t}\n\tif padchar == '\\t' {\n\t\t// tab padding enforces left-alignment\n\t\tflags \u0026^= AlignRight\n\t}\n\tb.flags = flags\n\n\tb.reset()\n\n\treturn b\n}",
    "filename": "/usr/local/go/src/text/tabwriter/tabwriter.go",
    "line": 209
  },
  {
    "id": 72,
    "text": "func (b *Writer) dump() {\n\tpos := 0\n\tfor i, line := range b.lines {\n\t\tprint(\"(\", i, \") \")\n\t\tfor _, c := range line {\n\t\t\tprint(\"[\", string(b.buf[pos:pos+c.size]), \"]\")\n\t\t\tpos += c.size\n\t\t}\n\t\tprint(\"\\n\")\n\t}\n\tprint(\"\\n\")\n}",
    "filename": "/usr/local/go/src/text/tabwriter/tabwriter.go",
    "line": 232
  },
  {
    "id": 73,
    "text": "func (b *Writer) write0(buf []byte) {\n\tn, err := b.output.Write(buf)\n\tif n != len(buf) \u0026\u0026 err == nil {\n\t\terr = io.ErrShortWrite\n\t}\n\tif err != nil {\n\t\tpanic(osError{err})\n\t}\n}",
    "filename": "/usr/local/go/src/text/tabwriter/tabwriter.go",
    "line": 251
  },
  {
    "id": 74,
    "text": "func (b *Writer) writeN(src []byte, n int) {\n\tfor n \u003e len(src) {\n\t\tb.write0(src)\n\t\tn -= len(src)\n\t}\n\tb.write0(src[0:n])\n}",
    "filename": "/usr/local/go/src/text/tabwriter/tabwriter.go",
    "line": 261
  },
  {
    "id": 75,
    "text": "func (b *Writer) writePadding(textw, cellw int, useTabs bool) {\n\tif b.padbytes[0] == '\\t' || useTabs {\n\t\t// padding is done with tabs\n\t\tif b.tabwidth == 0 {\n\t\t\treturn // tabs have no width - can't do any padding\n\t\t}\n\t\t// make cellw the smallest multiple of b.tabwidth\n\t\tcellw = (cellw + b.tabwidth - 1) / b.tabwidth * b.tabwidth\n\t\tn := cellw - textw // amount of padding\n\t\tif n \u003c 0 {\n\t\t\tpanic(\"internal error\")\n\t\t}\n\t\tb.writeN(tabs, (n+b.tabwidth-1)/b.tabwidth)\n\t\treturn\n\t}\n\n\t// padding is done with non-tab characters\n\tb.writeN(b.padbytes[0:], cellw-textw)\n}",
    "filename": "/usr/local/go/src/text/tabwriter/tabwriter.go",
    "line": 274
  },
  {
    "id": 76,
    "text": "func (b *Writer) writeLines(pos0 int, line0, line1 int) (pos int) {\n\tpos = pos0\n\tfor i := line0; i \u003c line1; i++ {\n\t\tline := b.lines[i]\n\n\t\t// if TabIndent is set, use tabs to pad leading empty cells\n\t\tuseTabs := b.flags\u0026TabIndent != 0\n\n\t\tfor j, c := range line {\n\t\t\tif j \u003e 0 \u0026\u0026 b.flags\u0026Debug != 0 {\n\t\t\t\t// indicate column break\n\t\t\t\tb.write0(vbar)\n\t\t\t}\n\n\t\t\tif c.size == 0 {\n\t\t\t\t// empty cell\n\t\t\t\tif j \u003c len(b.widths) {\n\t\t\t\t\tb.writePadding(c.width, b.widths[j], useTabs)\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// non-empty cell\n\t\t\t\tuseTabs = false\n\t\t\t\tif b.flags\u0026AlignRight == 0 { // align left\n\t\t\t\t\tb.write0(b.buf[pos : pos+c.size])\n\t\t\t\t\tpos += c.size\n\t\t\t\t\tif j \u003c len(b.widths) {\n\t\t\t\t\t\tb.writePadding(c.width, b.widths[j], false)\n\t\t\t\t\t}\n\t\t\t\t} else { // align right\n\t\t\t\t\tif j \u003c len(b.widths) {\n\t\t\t\t\t\tb.writePadding(c.width, b.widths[j], false)\n\t\t\t\t\t}\n\t\t\t\t\tb.write0(b.buf[pos : pos+c.size])\n\t\t\t\t\tpos += c.size\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif i+1 == len(b.lines) {\n\t\t\t// last buffered line - we don't have a newline, so just write\n\t\t\t// any outstanding buffered data\n\t\t\tb.write0(b.buf[pos : pos+b.cell.size])\n\t\t\tpos += b.cell.size\n\t\t} else {\n\t\t\t// not the last line - write newline\n\t\t\tb.write0(newline)\n\t\t}\n\t}\n\treturn\n}",
    "filename": "/usr/local/go/src/text/tabwriter/tabwriter.go",
    "line": 296
  },
  {
    "id": 77,
    "text": "func (b *Writer) format(pos0 int, line0, line1 int) (pos int) {\n\tpos = pos0\n\tcolumn := len(b.widths)\n\tfor this := line0; this \u003c line1; this++ {\n\t\tline := b.lines[this]\n\n\t\tif column \u003e= len(line)-1 {\n\t\t\tcontinue\n\t\t}\n\t\t// cell exists in this column =\u003e this line\n\t\t// has more cells than the previous line\n\t\t// (the last cell per line is ignored because cells are\n\t\t// tab-terminated; the last cell per line describes the\n\t\t// text before the newline/formfeed and does not belong\n\t\t// to a column)\n\n\t\t// print unprinted lines until beginning of block\n\t\tpos = b.writeLines(pos, line0, this)\n\t\tline0 = this\n\n\t\t// column block begin\n\t\twidth := b.minwidth // minimal column width\n\t\tdiscardable := true // true if all cells in this column are empty and \"soft\"\n\t\tfor ; this \u003c line1; this++ {\n\t\t\tline = b.lines[this]\n\t\t\tif column \u003e= len(line)-1 {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\t// cell exists in this column\n\t\t\tc := line[column]\n\t\t\t// update width\n\t\t\tif w := c.width + b.padding; w \u003e width {\n\t\t\t\twidth = w\n\t\t\t}\n\t\t\t// update discardable\n\t\t\tif c.width \u003e 0 || c.htab {\n\t\t\t\tdiscardable = false\n\t\t\t}\n\t\t}\n\t\t// column block end\n\n\t\t// discard empty columns if necessary\n\t\tif discardable \u0026\u0026 b.flags\u0026DiscardEmptyColumns != 0 {\n\t\t\twidth = 0\n\t\t}\n\n\t\t// format and print all columns to the right of this column\n\t\t// (we know the widths of this column and all columns to the left)\n\t\tb.widths = append(b.widths, width) // push width\n\t\tpos = b.format(pos, line0, this)\n\t\tb.widths = b.widths[0 : len(b.widths)-1] // pop width\n\t\tline0 = this\n\t}\n\n\t// print unprinted lines until end\n\treturn b.writeLines(pos, line0, line1)\n}",
    "filename": "/usr/local/go/src/text/tabwriter/tabwriter.go",
    "line": 351
  },
  {
    "id": 78,
    "text": "func (b *Writer) append(text []byte) {\n\tb.buf = append(b.buf, text...)\n\tb.cell.size += len(text)\n}",
    "filename": "/usr/local/go/src/text/tabwriter/tabwriter.go",
    "line": 410
  },
  {
    "id": 79,
    "text": "func (b *Writer) updateWidth() {\n\tb.cell.width += utf8.RuneCount(b.buf[b.pos:])\n\tb.pos = len(b.buf)\n}",
    "filename": "/usr/local/go/src/text/tabwriter/tabwriter.go",
    "line": 416
  },
  {
    "id": 80,
    "text": "func (b *Writer) startEscape(ch byte) {\n\tswitch ch {\n\tcase Escape:\n\t\tb.endChar = Escape\n\tcase '\u003c':\n\t\tb.endChar = '\u003e'\n\tcase '\u0026':\n\t\tb.endChar = ';'\n\t}\n}",
    "filename": "/usr/local/go/src/text/tabwriter/tabwriter.go",
    "line": 430
  },
  {
    "id": 81,
    "text": "func (b *Writer) endEscape() {\n\tswitch b.endChar {\n\tcase Escape:\n\t\tb.updateWidth()\n\t\tif b.flags\u0026StripEscape == 0 {\n\t\t\tb.cell.width -= 2 // don't count the Escape chars\n\t\t}\n\tcase '\u003e': // tag of zero width\n\tcase ';':\n\t\tb.cell.width++ // entity, count as one rune\n\t}\n\tb.pos = len(b.buf)\n\tb.endChar = 0\n}",
    "filename": "/usr/local/go/src/text/tabwriter/tabwriter.go",
    "line": 445
  },
  {
    "id": 82,
    "text": "func (b *Writer) terminateCell(htab bool) int {\n\tb.cell.htab = htab\n\tline := \u0026b.lines[len(b.lines)-1]\n\t*line = append(*line, b.cell)\n\tb.cell = cell{}\n\treturn len(*line)\n}",
    "filename": "/usr/local/go/src/text/tabwriter/tabwriter.go",
    "line": 462
  },
  {
    "id": 83,
    "text": "func (b *Writer) handlePanic(err *error, op string) {\n\tif e := recover(); e != nil {\n\t\tif op == \"Flush\" {\n\t\t\t// If Flush ran into a panic, we still need to reset.\n\t\t\tb.reset()\n\t\t}\n\t\tif nerr, ok := e.(osError); ok {\n\t\t\t*err = nerr.err\n\t\t\treturn\n\t\t}\n\t\tpanic(fmt.Sprintf(\"tabwriter: panic during %s (%v)\", op, e))\n\t}\n}",
    "filename": "/usr/local/go/src/text/tabwriter/tabwriter.go",
    "line": 470
  },
  {
    "id": 84,
    "text": "func (b *Writer) Flush() error {\n\treturn b.flush()\n}",
    "filename": "/usr/local/go/src/text/tabwriter/tabwriter.go",
    "line": 488
  },
  {
    "id": 85,
    "text": "func (b *Writer) flush() (err error) {\n\tdefer b.handlePanic(\u0026err, \"Flush\")\n\tb.flushNoDefers()\n\treturn nil\n}",
    "filename": "/usr/local/go/src/text/tabwriter/tabwriter.go",
    "line": 494
  },
  {
    "id": 86,
    "text": "func (b *Writer) flushNoDefers() {\n\t// add current cell if not empty\n\tif b.cell.size \u003e 0 {\n\t\tif b.endChar != 0 {\n\t\t\t// inside escape - terminate it even if incomplete\n\t\t\tb.endEscape()\n\t\t}\n\t\tb.terminateCell(false)\n\t}\n\n\t// format contents of buffer\n\tb.format(0, 0, len(b.lines))\n\tb.reset()\n}",
    "filename": "/usr/local/go/src/text/tabwriter/tabwriter.go",
    "line": 503
  },
  {
    "id": 87,
    "text": "func (b *Writer) Write(buf []byte) (n int, err error) {\n\tdefer b.handlePanic(\u0026err, \"Write\")\n\n\t// split text into cells\n\tn = 0\n\tfor i, ch := range buf {\n\t\tif b.endChar == 0 {\n\t\t\t// outside escape\n\t\t\tswitch ch {\n\t\t\tcase '\\t', '\\v', '\\n', '\\f':\n\t\t\t\t// end of cell\n\t\t\t\tb.append(buf[n:i])\n\t\t\t\tb.updateWidth()\n\t\t\t\tn = i + 1 // ch consumed\n\t\t\t\tncells := b.terminateCell(ch == '\\t')\n\t\t\t\tif ch == '\\n' || ch == '\\f' {\n\t\t\t\t\t// terminate line\n\t\t\t\t\tb.addLine(ch == '\\f')\n\t\t\t\t\tif ch == '\\f' || ncells == 1 {\n\t\t\t\t\t\t// A '\\f' always forces a flush. Otherwise, if the previous\n\t\t\t\t\t\t// line has only one cell which does not have an impact on\n\t\t\t\t\t\t// the formatting of the following lines (the last cell per\n\t\t\t\t\t\t// line is ignored by format()), thus we can flush the\n\t\t\t\t\t\t// Writer contents.\n\t\t\t\t\t\tb.flushNoDefers()\n\t\t\t\t\t\tif ch == '\\f' \u0026\u0026 b.flags\u0026Debug != 0 {\n\t\t\t\t\t\t\t// indicate section break\n\t\t\t\t\t\t\tb.write0(hbar)\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\tcase Escape:\n\t\t\t\t// start of escaped sequence\n\t\t\t\tb.append(buf[n:i])\n\t\t\t\tb.updateWidth()\n\t\t\t\tn = i\n\t\t\t\tif b.flags\u0026StripEscape != 0 {\n\t\t\t\t\tn++ // strip Escape\n\t\t\t\t}\n\t\t\t\tb.startEscape(Escape)\n\n\t\t\tcase '\u003c', '\u0026':\n\t\t\t\t// possibly an html tag/entity\n\t\t\t\tif b.flags\u0026FilterHTML != 0 {\n\t\t\t\t\t// begin of tag/entity\n\t\t\t\t\tb.append(buf[n:i])\n\t\t\t\t\tb.updateWidth()\n\t\t\t\t\tn = i\n\t\t\t\t\tb.startEscape(ch)\n\t\t\t\t}\n\t\t\t}\n\n\t\t} else {\n\t\t\t// inside escape\n\t\t\tif ch == b.endChar {\n\t\t\t\t// end of tag/entity\n\t\t\t\tj := i + 1\n\t\t\t\tif ch == Escape \u0026\u0026 b.flags\u0026StripEscape != 0 {\n\t\t\t\t\tj = i // strip Escape\n\t\t\t\t}\n\t\t\t\tb.append(buf[n:j])\n\t\t\t\tn = i + 1 // ch consumed\n\t\t\t\tb.endEscape()\n\t\t\t}\n\t\t}\n\t}\n\n\t// append leftover text\n\tb.append(buf[n:])\n\tn = len(buf)\n\treturn\n}",
    "filename": "/usr/local/go/src/text/tabwriter/tabwriter.go",
    "line": 523
  },
  {
    "id": 88,
    "text": "func NewWriter(output io.Writer, minwidth, tabwidth, padding int, padchar byte, flags uint) *Writer {\n\treturn new(Writer).Init(output, minwidth, tabwidth, padding, padchar, flags)\n}",
    "filename": "/usr/local/go/src/text/tabwriter/tabwriter.go",
    "line": 599
  },
  {
    "id": 89,
    "text": "func (b *buffer) init(n int) { b.a = make([]byte, 0, n) }",
    "filename": "/usr/local/go/src/text/tabwriter/tabwriter_test.go",
    "line": 19
  },
  {
    "id": 90,
    "text": "func (b *buffer) clear() { b.a = b.a[0:0] }",
    "filename": "/usr/local/go/src/text/tabwriter/tabwriter_test.go",
    "line": 21
  },
  {
    "id": 91,
    "text": "func (b *buffer) Write(buf []byte) (written int, err error) {\n\tn := len(b.a)\n\tm := len(buf)\n\tif n+m \u003c= cap(b.a) {\n\t\tb.a = b.a[0 : n+m]\n\t\tfor i := 0; i \u003c m; i++ {\n\t\t\tb.a[n+i] = buf[i]\n\t\t}\n\t} else {\n\t\tpanic(\"buffer.Write: buffer too small\")\n\t}\n\treturn len(buf), nil\n}",
    "filename": "/usr/local/go/src/text/tabwriter/tabwriter_test.go",
    "line": 23
  },
  {
    "id": 92,
    "text": "func (b *buffer) String() string { return string(b.a) }",
    "filename": "/usr/local/go/src/text/tabwriter/tabwriter_test.go",
    "line": 37
  },
  {
    "id": 93,
    "text": "func write(t *testing.T, testname string, w *Writer, src string) {\n\twritten, err := io.WriteString(w, src)\n\tif err != nil {\n\t\tt.Errorf(\"--- test: %s\\n--- src:\\n%q\\n--- write error: %v\\n\", testname, src, err)\n\t}\n\tif written != len(src) {\n\t\tt.Errorf(\"--- test: %s\\n--- src:\\n%q\\n--- written = %d, len(src) = %d\\n\", testname, src, written, len(src))\n\t}\n}",
    "filename": "/usr/local/go/src/text/tabwriter/tabwriter_test.go",
    "line": 39
  },
  {
    "id": 94,
    "text": "func verify(t *testing.T, testname string, w *Writer, b *buffer, src, expected string) {\n\terr := w.Flush()\n\tif err != nil {\n\t\tt.Errorf(\"--- test: %s\\n--- src:\\n%q\\n--- flush error: %v\\n\", testname, src, err)\n\t}\n\n\tres := b.String()\n\tif res != expected {\n\t\tt.Errorf(\"--- test: %s\\n--- src:\\n%q\\n--- found:\\n%q\\n--- expected:\\n%q\\n\", testname, src, res, expected)\n\t}\n}",
    "filename": "/usr/local/go/src/text/tabwriter/tabwriter_test.go",
    "line": 49
  },
  {
    "id": 95,
    "text": "func check(t *testing.T, testname string, minwidth, tabwidth, padding int, padchar byte, flags uint, src, expected string) {\n\tvar b buffer\n\tb.init(1000)\n\n\tvar w Writer\n\tw.Init(\u0026b, minwidth, tabwidth, padding, padchar, flags)\n\n\t// write all at once\n\ttitle := testname + \" (written all at once)\"\n\tb.clear()\n\twrite(t, title, \u0026w, src)\n\tverify(t, title, \u0026w, \u0026b, src, expected)\n\n\t// write byte-by-byte\n\ttitle = testname + \" (written byte-by-byte)\"\n\tb.clear()\n\tfor i := 0; i \u003c len(src); i++ {\n\t\twrite(t, title, \u0026w, src[i:i+1])\n\t}\n\tverify(t, title, \u0026w, \u0026b, src, expected)\n\n\t// write using Fibonacci slice sizes\n\ttitle = testname + \" (written in fibonacci slices)\"\n\tb.clear()\n\tfor i, d := 0, 0; i \u003c len(src); {\n\t\twrite(t, title, \u0026w, src[i:i+d])\n\t\ti, d = i+d, d+1\n\t\tif i+d \u003e len(src) {\n\t\t\td = len(src) - i\n\t\t}\n\t}\n\tverify(t, title, \u0026w, \u0026b, src, expected)\n}",
    "filename": "/usr/local/go/src/text/tabwriter/tabwriter_test.go",
    "line": 61
  },
  {
    "id": 96,
    "text": "func Test(t *testing.T) {\n\tfor _, e := range tests {\n\t\tcheck(t, e.testname, e.minwidth, e.tabwidth, e.padding, e.padchar, e.flags, e.src, e.expected)\n\t}\n}",
    "filename": "/usr/local/go/src/text/tabwriter/tabwriter_test.go",
    "line": 613
  },
  {
    "id": 97,
    "text": "func (panicWriter) Write([]byte) (int, error) {\n\tpanic(\"cannot write\")\n}",
    "filename": "/usr/local/go/src/text/tabwriter/tabwriter_test.go",
    "line": 621
  },
  {
    "id": 98,
    "text": "func wantPanicString(t *testing.T, want string) {\n\tif e := recover(); e != nil {\n\t\tgot, ok := e.(string)\n\t\tswitch {\n\t\tcase !ok:\n\t\t\tt.Errorf(\"got %v (%T), want panic string\", e, e)\n\t\tcase got != want:\n\t\t\tt.Errorf(\"wrong panic message: got %q, want %q\", got, want)\n\t\t}\n\t}\n}",
    "filename": "/usr/local/go/src/text/tabwriter/tabwriter_test.go",
    "line": 625
  },
  {
    "id": 99,
    "text": "func TestPanicDuringFlush(t *testing.T) {\n\tdefer wantPanicString(t, \"tabwriter: panic during Flush (cannot write)\")\n\tvar p panicWriter\n\tw := new(Writer)\n\tw.Init(p, 0, 0, 5, ' ', 0)\n\tio.WriteString(w, \"a\")\n\tw.Flush()\n\tt.Errorf(\"failed to panic during Flush\")\n}",
    "filename": "/usr/local/go/src/text/tabwriter/tabwriter_test.go",
    "line": 637
  },
  {
    "id": 100,
    "text": "func TestPanicDuringWrite(t *testing.T) {\n\tdefer wantPanicString(t, \"tabwriter: panic during Write (cannot write)\")\n\tvar p panicWriter\n\tw := new(Writer)\n\tw.Init(p, 0, 0, 5, ' ', 0)\n\tio.WriteString(w, \"a\\n\\n\") // the second \\n triggers a call to w.Write and thus a panic\n\tt.Errorf(\"failed to panic during Write\")\n}",
    "filename": "/usr/local/go/src/text/tabwriter/tabwriter_test.go",
    "line": 647
  },
  {
    "id": 101,
    "text": "func BenchmarkTable(b *testing.B) {\n\tfor _, w := range [...]int{1, 10, 100} {\n\t\t// Build a line with w cells.\n\t\tline := bytes.Repeat([]byte(\"a\\t\"), w)\n\t\tline = append(line, '\\n')\n\t\tfor _, h := range [...]int{10, 1000, 100000} {\n\t\t\tb.Run(fmt.Sprintf(\"%dx%d\", w, h), func(b *testing.B) {\n\t\t\t\tb.Run(\"new\", func(b *testing.B) {\n\t\t\t\t\tb.ReportAllocs()\n\t\t\t\t\tfor i := 0; i \u003c b.N; i++ {\n\t\t\t\t\t\tw := NewWriter(io.Discard, 4, 4, 1, ' ', 0) // no particular reason for these settings\n\t\t\t\t\t\t// Write the line h times.\n\t\t\t\t\t\tfor j := 0; j \u003c h; j++ {\n\t\t\t\t\t\t\tw.Write(line)\n\t\t\t\t\t\t}\n\t\t\t\t\t\tw.Flush()\n\t\t\t\t\t}\n\t\t\t\t})\n\n\t\t\t\tb.Run(\"reuse\", func(b *testing.B) {\n\t\t\t\t\tb.ReportAllocs()\n\t\t\t\t\tw := NewWriter(io.Discard, 4, 4, 1, ' ', 0) // no particular reason for these settings\n\t\t\t\t\tfor i := 0; i \u003c b.N; i++ {\n\t\t\t\t\t\t// Write the line h times.\n\t\t\t\t\t\tfor j := 0; j \u003c h; j++ {\n\t\t\t\t\t\t\tw.Write(line)\n\t\t\t\t\t\t}\n\t\t\t\t\t\tw.Flush()\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t})\n\t\t}\n\t}\n}",
    "filename": "/usr/local/go/src/text/tabwriter/tabwriter_test.go",
    "line": 656
  },
  {
    "id": 102,
    "text": "func BenchmarkPyramid(b *testing.B) {\n\tfor _, x := range [...]int{10, 100, 1000} {\n\t\t// Build a line with x cells.\n\t\tline := bytes.Repeat([]byte(\"a\\t\"), x)\n\t\tb.Run(fmt.Sprintf(\"%d\", x), func(b *testing.B) {\n\t\t\tb.ReportAllocs()\n\t\t\tfor i := 0; i \u003c b.N; i++ {\n\t\t\t\tw := NewWriter(io.Discard, 4, 4, 1, ' ', 0) // no particular reason for these settings\n\t\t\t\t// Write increasing prefixes of that line.\n\t\t\t\tfor j := 0; j \u003c x; j++ {\n\t\t\t\t\tw.Write(line[:j*2])\n\t\t\t\t\tw.Write([]byte{'\\n'})\n\t\t\t\t}\n\t\t\t\tw.Flush()\n\t\t\t}\n\t\t})\n\t}\n}",
    "filename": "/usr/local/go/src/text/tabwriter/tabwriter_test.go",
    "line": 691
  },
  {
    "id": 103,
    "text": "func BenchmarkRagged(b *testing.B) {\n\tvar lines [8][]byte\n\tfor i, w := range [8]int{6, 2, 9, 5, 5, 7, 3, 8} {\n\t\t// Build a line with w cells.\n\t\tlines[i] = bytes.Repeat([]byte(\"a\\t\"), w)\n\t}\n\tfor _, h := range [...]int{10, 100, 1000} {\n\t\tb.Run(fmt.Sprintf(\"%d\", h), func(b *testing.B) {\n\t\t\tb.ReportAllocs()\n\t\t\tfor i := 0; i \u003c b.N; i++ {\n\t\t\t\tw := NewWriter(io.Discard, 4, 4, 1, ' ', 0) // no particular reason for these settings\n\t\t\t\t// Write the lines in turn h times.\n\t\t\t\tfor j := 0; j \u003c h; j++ {\n\t\t\t\t\tw.Write(lines[j%len(lines)])\n\t\t\t\t\tw.Write([]byte{'\\n'})\n\t\t\t\t}\n\t\t\t\tw.Flush()\n\t\t\t}\n\t\t})\n\t}\n}",
    "filename": "/usr/local/go/src/text/tabwriter/tabwriter_test.go",
    "line": 710
  },
  {
    "id": 104,
    "text": "func BenchmarkCode(b *testing.B) {\n\tb.ReportAllocs()\n\tfor i := 0; i \u003c b.N; i++ {\n\t\tw := NewWriter(io.Discard, 4, 4, 1, ' ', 0) // no particular reason for these settings\n\t\t// The code is small, so it's reasonable for the tabwriter user\n\t\t// to write it all at once, or buffer the writes.\n\t\tw.Write([]byte(codeSnippet))\n\t\tw.Flush()\n\t}\n}",
    "filename": "/usr/local/go/src/text/tabwriter/tabwriter_test.go",
    "line": 745
  },
  {
    "id": 105,
    "text": "func ExampleTemplate() {\n\t// Define a template.\n\tconst letter = `\nDear {{.Name}},\n{{if .Attended}}\nIt was a pleasure to see you at the wedding.\n{{- else}}\nIt is a shame you couldn't make it to the wedding.\n{{- end}}\n{{with .Gift -}}\nThank you for the lovely {{.}}.\n{{end}}\nBest wishes,\nJosie\n`\n\n\t// Prepare some data to insert into the template.\n\ttype Recipient struct {\n\t\tName, Gift string\n\t\tAttended   bool\n\t}\n\tvar recipients = []Recipient{\n\t\t{\"Aunt Mildred\", \"bone china tea set\", true},\n\t\t{\"Uncle John\", \"moleskin pants\", false},\n\t\t{\"Cousin Rodney\", \"\", false},\n\t}\n\n\t// Create a new template and parse the letter into it.\n\tt := template.Must(template.New(\"letter\").Parse(letter))\n\n\t// Execute the template for each recipient.\n\tfor _, r := range recipients {\n\t\terr := t.Execute(os.Stdout, r)\n\t\tif err != nil {\n\t\t\tlog.Println(\"executing template:\", err)\n\t\t}\n\t}\n\n\t// Output:\n\t// Dear Aunt Mildred,\n\t//\n\t// It was a pleasure to see you at the wedding.\n\t// Thank you for the lovely bone china tea set.\n\t//\n\t// Best wishes,\n\t// Josie\n\t//\n\t// Dear Uncle John,\n\t//\n\t// It is a shame you couldn't make it to the wedding.\n\t// Thank you for the lovely moleskin pants.\n\t//\n\t// Best wishes,\n\t// Josie\n\t//\n\t// Dear Cousin Rodney,\n\t//\n\t// It is a shame you couldn't make it to the wedding.\n\t//\n\t// Best wishes,\n\t// Josie\n}",
    "filename": "/usr/local/go/src/text/template/example_test.go",
    "line": 14
  },
  {
    "id": 106,
    "text": "func ExampleTemplate_block() {\n\tconst (\n\t\tmaster  = `Names:{{block \"list\" .}}{{\"\\n\"}}{{range .}}{{println \"-\" .}}{{end}}{{end}}`\n\t\toverlay = `{{define \"list\"}} {{join . \", \"}}{{end}} `\n\t)\n\tvar (\n\t\tfuncs     = template.FuncMap{\"join\": strings.Join}\n\t\tguardians = []string{\"Gamora\", \"Groot\", \"Nebula\", \"Rocket\", \"Star-Lord\"}\n\t)\n\tmasterTmpl, err := template.New(\"master\").Funcs(funcs).Parse(master)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\toverlayTmpl, err := template.Must(masterTmpl.Clone()).Parse(overlay)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tif err := masterTmpl.Execute(os.Stdout, guardians); err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tif err := overlayTmpl.Execute(os.Stdout, guardians); err != nil {\n\t\tlog.Fatal(err)\n\t}\n\t// Output:\n\t// Names:\n\t// - Gamora\n\t// - Groot\n\t// - Nebula\n\t// - Rocket\n\t// - Star-Lord\n\t// Names: Gamora, Groot, Nebula, Rocket, Star-Lord\n}",
    "filename": "/usr/local/go/src/text/template/example_test.go",
    "line": 79
  },
  {
    "id": 107,
    "text": "func createTestDir(files []templateFile) string {\n\tdir, err := os.MkdirTemp(\"\", \"template\")\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tfor _, file := range files {\n\t\tf, err := os.Create(filepath.Join(dir, file.name))\n\t\tif err != nil {\n\t\t\tlog.Fatal(err)\n\t\t}\n\t\tdefer f.Close()\n\t\t_, err = io.WriteString(f, file.contents)\n\t\tif err != nil {\n\t\t\tlog.Fatal(err)\n\t\t}\n\t}\n\treturn dir\n}",
    "filename": "/usr/local/go/src/text/template/examplefiles_test.go",
    "line": 21
  },
  {
    "id": 108,
    "text": "func ExampleTemplate_glob() {\n\t// Here we create a temporary directory and populate it with our sample\n\t// template definition files; usually the template files would already\n\t// exist in some location known to the program.\n\tdir := createTestDir([]templateFile{\n\t\t// T0.tmpl is a plain template file that just invokes T1.\n\t\t{\"T0.tmpl\", `T0 invokes T1: ({{template \"T1\"}})`},\n\t\t// T1.tmpl defines a template, T1 that invokes T2.\n\t\t{\"T1.tmpl\", `{{define \"T1\"}}T1 invokes T2: ({{template \"T2\"}}){{end}}`},\n\t\t// T2.tmpl defines a template T2.\n\t\t{\"T2.tmpl\", `{{define \"T2\"}}This is T2{{end}}`},\n\t})\n\t// Clean up after the test; another quirk of running as an example.\n\tdefer os.RemoveAll(dir)\n\n\t// pattern is the glob pattern used to find all the template files.\n\tpattern := filepath.Join(dir, \"*.tmpl\")\n\n\t// Here starts the example proper.\n\t// T0.tmpl is the first name matched, so it becomes the starting template,\n\t// the value returned by ParseGlob.\n\ttmpl := template.Must(template.ParseGlob(pattern))\n\n\terr := tmpl.Execute(os.Stdout, nil)\n\tif err != nil {\n\t\tlog.Fatalf(\"template execution: %s\", err)\n\t}\n\t// Output:\n\t// T0 invokes T1: (T1 invokes T2: (This is T2))\n}",
    "filename": "/usr/local/go/src/text/template/examplefiles_test.go",
    "line": 41
  },
  {
    "id": 109,
    "text": "func ExampleTemplate_helpers() {\n\t// Here we create a temporary directory and populate it with our sample\n\t// template definition files; usually the template files would already\n\t// exist in some location known to the program.\n\tdir := createTestDir([]templateFile{\n\t\t// T1.tmpl defines a template, T1 that invokes T2.\n\t\t{\"T1.tmpl\", `{{define \"T1\"}}T1 invokes T2: ({{template \"T2\"}}){{end}}`},\n\t\t// T2.tmpl defines a template T2.\n\t\t{\"T2.tmpl\", `{{define \"T2\"}}This is T2{{end}}`},\n\t})\n\t// Clean up after the test; another quirk of running as an example.\n\tdefer os.RemoveAll(dir)\n\n\t// pattern is the glob pattern used to find all the template files.\n\tpattern := filepath.Join(dir, \"*.tmpl\")\n\n\t// Here starts the example proper.\n\t// Load the helpers.\n\ttemplates := template.Must(template.ParseGlob(pattern))\n\t// Add one driver template to the bunch; we do this with an explicit template definition.\n\t_, err := templates.Parse(\"{{define `driver1`}}Driver 1 calls T1: ({{template `T1`}})\\n{{end}}\")\n\tif err != nil {\n\t\tlog.Fatal(\"parsing driver1: \", err)\n\t}\n\t// Add another driver template.\n\t_, err = templates.Parse(\"{{define `driver2`}}Driver 2 calls T2: ({{template `T2`}})\\n{{end}}\")\n\tif err != nil {\n\t\tlog.Fatal(\"parsing driver2: \", err)\n\t}\n\t// We load all the templates before execution. This package does not require\n\t// that behavior but html/template's escaping does, so it's a good habit.\n\terr = templates.ExecuteTemplate(os.Stdout, \"driver1\", nil)\n\tif err != nil {\n\t\tlog.Fatalf(\"driver1 execution: %s\", err)\n\t}\n\terr = templates.ExecuteTemplate(os.Stdout, \"driver2\", nil)\n\tif err != nil {\n\t\tlog.Fatalf(\"driver2 execution: %s\", err)\n\t}\n\t// Output:\n\t// Driver 1 calls T1: (T1 invokes T2: (This is T2))\n\t// Driver 2 calls T2: (This is T2)\n}",
    "filename": "/usr/local/go/src/text/template/examplefiles_test.go",
    "line": 75
  },
  {
    "id": 110,
    "text": "func ExampleTemplate_share() {\n\t// Here we create a temporary directory and populate it with our sample\n\t// template definition files; usually the template files would already\n\t// exist in some location known to the program.\n\tdir := createTestDir([]templateFile{\n\t\t// T0.tmpl is a plain template file that just invokes T1.\n\t\t{\"T0.tmpl\", \"T0 ({{.}} version) invokes T1: ({{template `T1`}})\\n\"},\n\t\t// T1.tmpl defines a template, T1 that invokes T2. Note T2 is not defined\n\t\t{\"T1.tmpl\", `{{define \"T1\"}}T1 invokes T2: ({{template \"T2\"}}){{end}}`},\n\t})\n\t// Clean up after the test; another quirk of running as an example.\n\tdefer os.RemoveAll(dir)\n\n\t// pattern is the glob pattern used to find all the template files.\n\tpattern := filepath.Join(dir, \"*.tmpl\")\n\n\t// Here starts the example proper.\n\t// Load the drivers.\n\tdrivers := template.Must(template.ParseGlob(pattern))\n\n\t// We must define an implementation of the T2 template. First we clone\n\t// the drivers, then add a definition of T2 to the template name space.\n\n\t// 1. Clone the helper set to create a new name space from which to run them.\n\tfirst, err := drivers.Clone()\n\tif err != nil {\n\t\tlog.Fatal(\"cloning helpers: \", err)\n\t}\n\t// 2. Define T2, version A, and parse it.\n\t_, err = first.Parse(\"{{define `T2`}}T2, version A{{end}}\")\n\tif err != nil {\n\t\tlog.Fatal(\"parsing T2: \", err)\n\t}\n\n\t// Now repeat the whole thing, using a different version of T2.\n\t// 1. Clone the drivers.\n\tsecond, err := drivers.Clone()\n\tif err != nil {\n\t\tlog.Fatal(\"cloning drivers: \", err)\n\t}\n\t// 2. Define T2, version B, and parse it.\n\t_, err = second.Parse(\"{{define `T2`}}T2, version B{{end}}\")\n\tif err != nil {\n\t\tlog.Fatal(\"parsing T2: \", err)\n\t}\n\n\t// Execute the templates in the reverse order to verify the\n\t// first is unaffected by the second.\n\terr = second.ExecuteTemplate(os.Stdout, \"T0.tmpl\", \"second\")\n\tif err != nil {\n\t\tlog.Fatalf(\"second execution: %s\", err)\n\t}\n\terr = first.ExecuteTemplate(os.Stdout, \"T0.tmpl\", \"first\")\n\tif err != nil {\n\t\tlog.Fatalf(\"first: execution: %s\", err)\n\t}\n\n\t// Output:\n\t// T0 (second version) invokes T1: (T1 invokes T2: (T2, version B))\n\t// T0 (first version) invokes T1: (T1 invokes T2: (T2, version A))\n}",
    "filename": "/usr/local/go/src/text/template/examplefiles_test.go",
    "line": 121
  },
  {
    "id": 111,
    "text": "func ExampleTemplate_func() {\n\t// First we create a FuncMap with which to register the function.\n\tfuncMap := template.FuncMap{\n\t\t// The name \"title\" is what the function will be called in the template text.\n\t\t\"title\": strings.Title,\n\t}\n\n\t// A simple template definition to test our function.\n\t// We print the input text several ways:\n\t// - the original\n\t// - title-cased\n\t// - title-cased and then printed with %q\n\t// - printed with %q and then title-cased.\n\tconst templateText = `\nInput: {{printf \"%q\" .}}\nOutput 0: {{title .}}\nOutput 1: {{title . | printf \"%q\"}}\nOutput 2: {{printf \"%q\" . | title}}\n`\n\n\t// Create a template, add the function map, and parse the text.\n\ttmpl, err := template.New(\"titleTest\").Funcs(funcMap).Parse(templateText)\n\tif err != nil {\n\t\tlog.Fatalf(\"parsing: %s\", err)\n\t}\n\n\t// Run the template to verify the output.\n\terr = tmpl.Execute(os.Stdout, \"the go programming language\")\n\tif err != nil {\n\t\tlog.Fatalf(\"execution: %s\", err)\n\t}\n\n\t// Output:\n\t// Input: \"the go programming language\"\n\t// Output 0: The Go Programming Language\n\t// Output 1: \"The Go Programming Language\"\n\t// Output 2: \"The Go Programming Language\"\n}",
    "filename": "/usr/local/go/src/text/template/examplefunc_test.go",
    "line": 17
  },
  {
    "id": 112,
    "text": "func ExampleTemplate_funcs() {\n\n\t// Define a simple template to test the functions.\n\tconst tmpl = `{{ . | lower | repeat }}`\n\n\t// Define the template funcMap with two functions.\n\tvar funcMap = template.FuncMap{\n\t\t\"lower\":  strings.ToLower,\n\t\t\"repeat\": func(s string) string { return strings.Repeat(s, 2) },\n\t}\n\n\t// Define a New template, add the funcMap using Funcs and then Parse\n\t// the template.\n\tparsedTmpl, err := template.New(\"t\").Funcs(funcMap).Parse(tmpl)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tif err := parsedTmpl.Execute(os.Stdout, \"ABC\\n\"); err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\t// [Funcs] must be called before a template is parsed to add\n\t// functions to the template. [Funcs] can also be used after a\n\t// template is parsed to overwrite template functions.\n\t//\n\t// Here the function identified by \"repeat\" is overwritten.\n\tparsedTmpl.Funcs(template.FuncMap{\n\t\t\"repeat\": func(s string) string { return strings.Repeat(s, 3) },\n\t})\n\tif err := parsedTmpl.Execute(os.Stdout, \"DEF\\n\"); err != nil {\n\t\tlog.Fatal(err)\n\t}\n\t// Output:\n\t// abc\n\t// abc\n\t// def\n\t// def\n\t// def\n}",
    "filename": "/usr/local/go/src/text/template/examplefunc_test.go",
    "line": 60
  },
  {
    "id": 113,
    "text": "func ExampleTemplate_if() {\n\ttype book struct {\n\t\tStars float32\n\t\tName  string\n\t}\n\n\ttpl, err := template.New(\"book\").Parse(`{{ if (gt .Stars 4.0) }}\"{{.Name }}\" is a great book.{{ else }}\"{{.Name}}\" is not a great book.{{ end }}`)\n\tif err != nil {\n\t\tlog.Fatalf(\"failed to parse template: %s\", err)\n\t}\n\n\tb := \u0026book{\n\t\tStars: 4.9,\n\t\tName:  \"Good Night, Gopher\",\n\t}\n\terr = tpl.Execute(os.Stdout, b)\n\tif err != nil {\n\t\tlog.Fatalf(\"failed to execute template: %s\", err)\n\t}\n\n\t// Output:\n\t// \"Good Night, Gopher\" is a great book.\n}",
    "filename": "/usr/local/go/src/text/template/examplefunc_test.go",
    "line": 101
  },
  {
    "id": 114,
    "text": "func initMaxExecDepth() int {\n\tif runtime.GOARCH == \"wasm\" {\n\t\treturn 1000\n\t}\n\treturn 100000\n}",
    "filename": "/usr/local/go/src/text/template/exec.go",
    "line": 24
  },
  {
    "id": 115,
    "text": "func (s *state) push(name string, value reflect.Value) {\n\ts.vars = append(s.vars, variable{name, value})\n}",
    "filename": "/usr/local/go/src/text/template/exec.go",
    "line": 49
  },
  {
    "id": 116,
    "text": "func (s *state) mark() int {\n\treturn len(s.vars)\n}",
    "filename": "/usr/local/go/src/text/template/exec.go",
    "line": 54
  },
  {
    "id": 117,
    "text": "func (s *state) pop(mark int) {\n\ts.vars = s.vars[0:mark]\n}",
    "filename": "/usr/local/go/src/text/template/exec.go",
    "line": 59
  },
  {
    "id": 118,
    "text": "func (s *state) setVar(name string, value reflect.Value) {\n\tfor i := s.mark() - 1; i \u003e= 0; i-- {\n\t\tif s.vars[i].name == name {\n\t\t\ts.vars[i].value = value\n\t\t\treturn\n\t\t}\n\t}\n\ts.errorf(\"undefined variable: %s\", name)\n}",
    "filename": "/usr/local/go/src/text/template/exec.go",
    "line": 65
  },
  {
    "id": 119,
    "text": "func (s *state) setTopVar(n int, value reflect.Value) {\n\ts.vars[len(s.vars)-n].value = value\n}",
    "filename": "/usr/local/go/src/text/template/exec.go",
    "line": 76
  },
  {
    "id": 120,
    "text": "func (s *state) varValue(name string) reflect.Value {\n\tfor i := s.mark() - 1; i \u003e= 0; i-- {\n\t\tif s.vars[i].name == name {\n\t\t\treturn s.vars[i].value\n\t\t}\n\t}\n\ts.errorf(\"undefined variable: %s\", name)\n\treturn zero\n}",
    "filename": "/usr/local/go/src/text/template/exec.go",
    "line": 81
  },
  {
    "id": 121,
    "text": "func isMissing(v reflect.Value) bool {\n\treturn v.IsValid() \u0026\u0026 v.Type() == missingValReflectType\n}",
    "filename": "/usr/local/go/src/text/template/exec.go",
    "line": 99
  },
  {
    "id": 122,
    "text": "func (s *state) at(node parse.Node) {\n\ts.node = node\n}",
    "filename": "/usr/local/go/src/text/template/exec.go",
    "line": 104
  },
  {
    "id": 123,
    "text": "func doublePercent(str string) string {\n\treturn strings.ReplaceAll(str, \"%\", \"%%\")\n}",
    "filename": "/usr/local/go/src/text/template/exec.go",
    "line": 110
  },
  {
    "id": 124,
    "text": "func (e ExecError) Error() string {\n\treturn e.Err.Error()\n}",
    "filename": "/usr/local/go/src/text/template/exec.go",
    "line": 126
  },
  {
    "id": 125,
    "text": "func (e ExecError) Unwrap() error {\n\treturn e.Err\n}",
    "filename": "/usr/local/go/src/text/template/exec.go",
    "line": 130
  },
  {
    "id": 126,
    "text": "func (s *state) errorf(format string, args ...any) {\n\tname := doublePercent(s.tmpl.Name())\n\tif s.node == nil {\n\t\tformat = fmt.Sprintf(\"template: %s: %s\", name, format)\n\t} else {\n\t\tlocation, context := s.tmpl.ErrorContext(s.node)\n\t\tformat = fmt.Sprintf(\"template: %s: executing %q at \u003c%s\u003e: %s\", location, name, doublePercent(context), format)\n\t}\n\tpanic(ExecError{\n\t\tName: s.tmpl.Name(),\n\t\tErr:  fmt.Errorf(format, args...),\n\t})\n}",
    "filename": "/usr/local/go/src/text/template/exec.go",
    "line": 135
  },
  {
    "id": 127,
    "text": "func (s *state) writeError(err error) {\n\tpanic(writeError{\n\t\tErr: err,\n\t})\n}",
    "filename": "/usr/local/go/src/text/template/exec.go",
    "line": 157
  },
  {
    "id": 128,
    "text": "func errRecover(errp *error) {\n\te := recover()\n\tif e != nil {\n\t\tswitch err := e.(type) {\n\t\tcase runtime.Error:\n\t\t\tpanic(e)\n\t\tcase writeError:\n\t\t\t*errp = err.Err // Strip the wrapper.\n\t\tcase ExecError:\n\t\t\t*errp = err // Keep the wrapper.\n\t\tdefault:\n\t\t\tpanic(e)\n\t\t}\n\t}\n}",
    "filename": "/usr/local/go/src/text/template/exec.go",
    "line": 165
  },
  {
    "id": 129,
    "text": "func (t *Template) ExecuteTemplate(wr io.Writer, name string, data any) error {\n\ttmpl := t.Lookup(name)\n\tif tmpl == nil {\n\t\treturn fmt.Errorf(\"template: no template %q associated with template %q\", name, t.name)\n\t}\n\treturn tmpl.Execute(wr, data)\n}",
    "filename": "/usr/local/go/src/text/template/exec.go",
    "line": 188
  },
  {
    "id": 130,
    "text": "func (t *Template) Execute(wr io.Writer, data any) error {\n\treturn t.execute(wr, data)\n}",
    "filename": "/usr/local/go/src/text/template/exec.go",
    "line": 206
  },
  {
    "id": 131,
    "text": "func (t *Template) execute(wr io.Writer, data any) (err error) {\n\tdefer errRecover(\u0026err)\n\tvalue, ok := data.(reflect.Value)\n\tif !ok {\n\t\tvalue = reflect.ValueOf(data)\n\t}\n\tstate := \u0026state{\n\t\ttmpl: t,\n\t\twr:   wr,\n\t\tvars: []variable{{\"$\", value}},\n\t}\n\tif t.Tree == nil || t.Root == nil {\n\t\tstate.errorf(\"%q is an incomplete or empty template\", t.Name())\n\t}\n\tstate.walk(value, t.Root)\n\treturn\n}",
    "filename": "/usr/local/go/src/text/template/exec.go",
    "line": 210
  },
  {
    "id": 132,
    "text": "func (t *Template) DefinedTemplates() string {\n\tif t.common == nil {\n\t\treturn \"\"\n\t}\n\tvar b strings.Builder\n\tt.muTmpl.RLock()\n\tdefer t.muTmpl.RUnlock()\n\tfor name, tmpl := range t.tmpl {\n\t\tif tmpl.Tree == nil || tmpl.Root == nil {\n\t\t\tcontinue\n\t\t}\n\t\tif b.Len() == 0 {\n\t\t\tb.WriteString(\"; defined templates are: \")\n\t\t} else {\n\t\t\tb.WriteString(\", \")\n\t\t}\n\t\tfmt.Fprintf(\u0026b, \"%q\", name)\n\t}\n\treturn b.String()\n}",
    "filename": "/usr/local/go/src/text/template/exec.go",
    "line": 232
  },
  {
    "id": 133,
    "text": "func (s *state) walk(dot reflect.Value, node parse.Node) {\n\ts.at(node)\n\tswitch node := node.(type) {\n\tcase *parse.ActionNode:\n\t\t// Do not pop variables so they persist until next end.\n\t\t// Also, if the action declares variables, don't print the result.\n\t\tval := s.evalPipeline(dot, node.Pipe)\n\t\tif len(node.Pipe.Decl) == 0 {\n\t\t\ts.printValue(node, val)\n\t\t}\n\tcase *parse.BreakNode:\n\t\tpanic(walkBreak)\n\tcase *parse.CommentNode:\n\tcase *parse.ContinueNode:\n\t\tpanic(walkContinue)\n\tcase *parse.IfNode:\n\t\ts.walkIfOrWith(parse.NodeIf, dot, node.Pipe, node.List, node.ElseList)\n\tcase *parse.ListNode:\n\t\tfor _, node := range node.Nodes {\n\t\t\ts.walk(dot, node)\n\t\t}\n\tcase *parse.RangeNode:\n\t\ts.walkRange(dot, node)\n\tcase *parse.TemplateNode:\n\t\ts.walkTemplate(dot, node)\n\tcase *parse.TextNode:\n\t\tif _, err := s.wr.Write(node.Text); err != nil {\n\t\t\ts.writeError(err)\n\t\t}\n\tcase *parse.WithNode:\n\t\ts.walkIfOrWith(parse.NodeWith, dot, node.Pipe, node.List, node.ElseList)\n\tdefault:\n\t\ts.errorf(\"unknown node: %s\", node)\n\t}\n}",
    "filename": "/usr/local/go/src/text/template/exec.go",
    "line": 261
  },
  {
    "id": 134,
    "text": "func (s *state) walkIfOrWith(typ parse.NodeType, dot reflect.Value, pipe *parse.PipeNode, list, elseList *parse.ListNode) {\n\tdefer s.pop(s.mark())\n\tval := s.evalPipeline(dot, pipe)\n\ttruth, ok := isTrue(indirectInterface(val))\n\tif !ok {\n\t\ts.errorf(\"if/with can't use %v\", val)\n\t}\n\tif truth {\n\t\tif typ == parse.NodeWith {\n\t\t\ts.walk(val, list)\n\t\t} else {\n\t\t\ts.walk(dot, list)\n\t\t}\n\t} else if elseList != nil {\n\t\ts.walk(dot, elseList)\n\t}\n}",
    "filename": "/usr/local/go/src/text/template/exec.go",
    "line": 299
  },
  {
    "id": 135,
    "text": "func IsTrue(val any) (truth, ok bool) {\n\treturn isTrue(reflect.ValueOf(val))\n}",
    "filename": "/usr/local/go/src/text/template/exec.go",
    "line": 320
  },
  {
    "id": 136,
    "text": "func isTrue(val reflect.Value) (truth, ok bool) {\n\tif !val.IsValid() {\n\t\t// Something like var x interface{}, never set. It's a form of nil.\n\t\treturn false, true\n\t}\n\tswitch val.Kind() {\n\tcase reflect.Array, reflect.Map, reflect.Slice, reflect.String:\n\t\ttruth = val.Len() \u003e 0\n\tcase reflect.Bool:\n\t\ttruth = val.Bool()\n\tcase reflect.Complex64, reflect.Complex128:\n\t\ttruth = val.Complex() != 0\n\tcase reflect.Chan, reflect.Func, reflect.Pointer, reflect.UnsafePointer, reflect.Interface:\n\t\ttruth = !val.IsNil()\n\tcase reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:\n\t\ttruth = val.Int() != 0\n\tcase reflect.Float32, reflect.Float64:\n\t\ttruth = val.Float() != 0\n\tcase reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64, reflect.Uintptr:\n\t\ttruth = val.Uint() != 0\n\tcase reflect.Struct:\n\t\ttruth = true // Struct values are always true.\n\tdefault:\n\t\treturn\n\t}\n\treturn truth, true\n}",
    "filename": "/usr/local/go/src/text/template/exec.go",
    "line": 324
  },
  {
    "id": 137,
    "text": "func (s *state) walkRange(dot reflect.Value, r *parse.RangeNode) {\n\ts.at(r)\n\tdefer func() {\n\t\tif r := recover(); r != nil \u0026\u0026 r != walkBreak {\n\t\t\tpanic(r)\n\t\t}\n\t}()\n\tdefer s.pop(s.mark())\n\tval, _ := indirect(s.evalPipeline(dot, r.Pipe))\n\t// mark top of stack before any variables in the body are pushed.\n\tmark := s.mark()\n\toneIteration := func(index, elem reflect.Value) {\n\t\tif len(r.Pipe.Decl) \u003e 0 {\n\t\t\tif r.Pipe.IsAssign {\n\t\t\t\t// With two variables, index comes first.\n\t\t\t\t// With one, we use the element.\n\t\t\t\tif len(r.Pipe.Decl) \u003e 1 {\n\t\t\t\t\ts.setVar(r.Pipe.Decl[0].Ident[0], index)\n\t\t\t\t} else {\n\t\t\t\t\ts.setVar(r.Pipe.Decl[0].Ident[0], elem)\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Set top var (lexically the second if there\n\t\t\t\t// are two) to the element.\n\t\t\t\ts.setTopVar(1, elem)\n\t\t\t}\n\t\t}\n\t\tif len(r.Pipe.Decl) \u003e 1 {\n\t\t\tif r.Pipe.IsAssign {\n\t\t\t\ts.setVar(r.Pipe.Decl[1].Ident[0], elem)\n\t\t\t} else {\n\t\t\t\t// Set next var (lexically the first if there\n\t\t\t\t// are two) to the index.\n\t\t\t\ts.setTopVar(2, index)\n\t\t\t}\n\t\t}\n\t\tdefer s.pop(mark)\n\t\tdefer func() {\n\t\t\t// Consume panic(walkContinue)\n\t\t\tif r := recover(); r != nil \u0026\u0026 r != walkContinue {\n\t\t\t\tpanic(r)\n\t\t\t}\n\t\t}()\n\t\ts.walk(elem, r.List)\n\t}\n\tswitch val.Kind() {\n\tcase reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64,\n\t\treflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64, reflect.Uintptr:\n\t\tif len(r.Pipe.Decl) \u003e 1 {\n\t\t\ts.errorf(\"can't use %v to iterate over more than one variable\", val)\n\t\t\tbreak\n\t\t}\n\t\trun := false\n\t\tfor v := range val.Seq() {\n\t\t\trun = true\n\t\t\t// Pass element as second value, as we do for channels.\n\t\t\toneIteration(reflect.Value{}, v)\n\t\t}\n\t\tif !run {\n\t\t\tbreak\n\t\t}\n\t\treturn\n\tcase reflect.Array, reflect.Slice:\n\t\tif val.Len() == 0 {\n\t\t\tbreak\n\t\t}\n\t\tfor i := 0; i \u003c val.Len(); i++ {\n\t\t\toneIteration(reflect.ValueOf(i), val.Index(i))\n\t\t}\n\t\treturn\n\tcase reflect.Map:\n\t\tif val.Len() == 0 {\n\t\t\tbreak\n\t\t}\n\t\tom := fmtsort.Sort(val)\n\t\tfor _, m := range om {\n\t\t\toneIteration(m.Key, m.Value)\n\t\t}\n\t\treturn\n\tcase reflect.Chan:\n\t\tif val.IsNil() {\n\t\t\tbreak\n\t\t}\n\t\tif val.Type().ChanDir() == reflect.SendDir {\n\t\t\ts.errorf(\"range over send-only channel %v\", val)\n\t\t\tbreak\n\t\t}\n\t\ti := 0\n\t\tfor ; ; i++ {\n\t\t\telem, ok := val.Recv()\n\t\t\tif !ok {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\toneIteration(reflect.ValueOf(i), elem)\n\t\t}\n\t\tif i == 0 {\n\t\t\tbreak\n\t\t}\n\t\treturn\n\tcase reflect.Invalid:\n\t\tbreak // An invalid value is likely a nil map, etc. and acts like an empty map.\n\tcase reflect.Func:\n\t\tif val.Type().CanSeq() {\n\t\t\tif len(r.Pipe.Decl) \u003e 1 {\n\t\t\t\ts.errorf(\"can't use %v iterate over more than one variable\", val)\n\t\t\t\tbreak\n\t\t\t}\n\t\t\trun := false\n\t\t\tfor v := range val.Seq() {\n\t\t\t\trun = true\n\t\t\t\t// Pass element as second value,\n\t\t\t\t// as we do for channels.\n\t\t\t\toneIteration(reflect.Value{}, v)\n\t\t\t}\n\t\t\tif !run {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\treturn\n\t\t}\n\t\tif val.Type().CanSeq2() {\n\t\t\trun := false\n\t\t\tfor i, v := range val.Seq2() {\n\t\t\t\trun = true\n\t\t\t\tif len(r.Pipe.Decl) \u003e 1 {\n\t\t\t\t\toneIteration(i, v)\n\t\t\t\t} else {\n\t\t\t\t\t// If there is only one range variable,\n\t\t\t\t\t// oneIteration will use the\n\t\t\t\t\t// second value.\n\t\t\t\t\toneIteration(reflect.Value{}, i)\n\t\t\t\t}\n\t\t\t}\n\t\t\tif !run {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\treturn\n\t\t}\n\t\tfallthrough\n\tdefault:\n\t\ts.errorf(\"range can't iterate over %v\", val)\n\t}\n\tif r.ElseList != nil {\n\t\ts.walk(dot, r.ElseList)\n\t}\n}",
    "filename": "/usr/local/go/src/text/template/exec.go",
    "line": 352
  },
  {
    "id": 138,
    "text": "func (s *state) walkTemplate(dot reflect.Value, t *parse.TemplateNode) {\n\ts.at(t)\n\ttmpl := s.tmpl.Lookup(t.Name)\n\tif tmpl == nil {\n\t\ts.errorf(\"template %q not defined\", t.Name)\n\t}\n\tif s.depth == maxExecDepth {\n\t\ts.errorf(\"exceeded maximum template depth (%v)\", maxExecDepth)\n\t}\n\t// Variables declared by the pipeline persist.\n\tdot = s.evalPipeline(dot, t.Pipe)\n\tnewState := *s\n\tnewState.depth++\n\tnewState.tmpl = tmpl\n\t// No dynamic scoping: template invocations inherit no variables.\n\tnewState.vars = []variable{{\"$\", dot}}\n\tnewState.walk(dot, tmpl.Root)\n}",
    "filename": "/usr/local/go/src/text/template/exec.go",
    "line": 498
  },
  {
    "id": 139,
    "text": "func (s *state) evalPipeline(dot reflect.Value, pipe *parse.PipeNode) (value reflect.Value) {\n\tif pipe == nil {\n\t\treturn\n\t}\n\ts.at(pipe)\n\tvalue = missingVal\n\tfor _, cmd := range pipe.Cmds {\n\t\tvalue = s.evalCommand(dot, cmd, value) // previous value is this one's final arg.\n\t\t// If the object has type interface{}, dig down one level to the thing inside.\n\t\tif value.Kind() == reflect.Interface \u0026\u0026 value.Type().NumMethod() == 0 {\n\t\t\tvalue = value.Elem()\n\t\t}\n\t}\n\tfor _, variable := range pipe.Decl {\n\t\tif pipe.IsAssign {\n\t\t\ts.setVar(variable.Ident[0], value)\n\t\t} else {\n\t\t\ts.push(variable.Ident[0], value)\n\t\t}\n\t}\n\treturn value\n}",
    "filename": "/usr/local/go/src/text/template/exec.go",
    "line": 525
  },
  {
    "id": 140,
    "text": "func (s *state) notAFunction(args []parse.Node, final reflect.Value) {\n\tif len(args) \u003e 1 || !isMissing(final) {\n\t\ts.errorf(\"can't give argument to non-function %s\", args[0])\n\t}\n}",
    "filename": "/usr/local/go/src/text/template/exec.go",
    "line": 548
  },
  {
    "id": 141,
    "text": "func (s *state) evalCommand(dot reflect.Value, cmd *parse.CommandNode, final reflect.Value) reflect.Value {\n\tfirstWord := cmd.Args[0]\n\tswitch n := firstWord.(type) {\n\tcase *parse.FieldNode:\n\t\treturn s.evalFieldNode(dot, n, cmd.Args, final)\n\tcase *parse.ChainNode:\n\t\treturn s.evalChainNode(dot, n, cmd.Args, final)\n\tcase *parse.IdentifierNode:\n\t\t// Must be a function.\n\t\treturn s.evalFunction(dot, n, cmd, cmd.Args, final)\n\tcase *parse.PipeNode:\n\t\t// Parenthesized pipeline. The arguments are all inside the pipeline; final must be absent.\n\t\ts.notAFunction(cmd.Args, final)\n\t\treturn s.evalPipeline(dot, n)\n\tcase *parse.VariableNode:\n\t\treturn s.evalVariableNode(dot, n, cmd.Args, final)\n\t}\n\ts.at(firstWord)\n\ts.notAFunction(cmd.Args, final)\n\tswitch word := firstWord.(type) {\n\tcase *parse.BoolNode:\n\t\treturn reflect.ValueOf(word.True)\n\tcase *parse.DotNode:\n\t\treturn dot\n\tcase *parse.NilNode:\n\t\ts.errorf(\"nil is not a command\")\n\tcase *parse.NumberNode:\n\t\treturn s.idealConstant(word)\n\tcase *parse.StringNode:\n\t\treturn reflect.ValueOf(word.Text)\n\t}\n\ts.errorf(\"can't evaluate command %q\", firstWord)\n\tpanic(\"not reached\")\n}",
    "filename": "/usr/local/go/src/text/template/exec.go",
    "line": 554
  },
  {
    "id": 142,
    "text": "func (s *state) idealConstant(constant *parse.NumberNode) reflect.Value {\n\t// These are ideal constants but we don't know the type\n\t// and we have no context.  (If it was a method argument,\n\t// we'd know what we need.) The syntax guides us to some extent.\n\ts.at(constant)\n\tswitch {\n\tcase constant.IsComplex:\n\t\treturn reflect.ValueOf(constant.Complex128) // incontrovertible.\n\n\tcase constant.IsFloat \u0026\u0026\n\t\t!isHexInt(constant.Text) \u0026\u0026 !isRuneInt(constant.Text) \u0026\u0026\n\t\tstrings.ContainsAny(constant.Text, \".eEpP\"):\n\t\treturn reflect.ValueOf(constant.Float64)\n\n\tcase constant.IsInt:\n\t\tn := int(constant.Int64)\n\t\tif int64(n) != constant.Int64 {\n\t\t\ts.errorf(\"%s overflows int\", constant.Text)\n\t\t}\n\t\treturn reflect.ValueOf(n)\n\n\tcase constant.IsUint:\n\t\ts.errorf(\"%s overflows int\", constant.Text)\n\t}\n\treturn zero\n}",
    "filename": "/usr/local/go/src/text/template/exec.go",
    "line": 593
  },
  {
    "id": 143,
    "text": "func isRuneInt(s string) bool {\n\treturn len(s) \u003e 0 \u0026\u0026 s[0] == '\\''\n}",
    "filename": "/usr/local/go/src/text/template/exec.go",
    "line": 620
  },
  {
    "id": 144,
    "text": "func isHexInt(s string) bool {\n\treturn len(s) \u003e 2 \u0026\u0026 s[0] == '0' \u0026\u0026 (s[1] == 'x' || s[1] == 'X') \u0026\u0026 !strings.ContainsAny(s, \"pP\")\n}",
    "filename": "/usr/local/go/src/text/template/exec.go",
    "line": 624
  },
  {
    "id": 145,
    "text": "func (s *state) evalFieldNode(dot reflect.Value, field *parse.FieldNode, args []parse.Node, final reflect.Value) reflect.Value {\n\ts.at(field)\n\treturn s.evalFieldChain(dot, dot, field, field.Ident, args, final)\n}",
    "filename": "/usr/local/go/src/text/template/exec.go",
    "line": 628
  },
  {
    "id": 146,
    "text": "func (s *state) evalChainNode(dot reflect.Value, chain *parse.ChainNode, args []parse.Node, final reflect.Value) reflect.Value {\n\ts.at(chain)\n\tif len(chain.Field) == 0 {\n\t\ts.errorf(\"internal error: no fields in evalChainNode\")\n\t}\n\tif chain.Node.Type() == parse.NodeNil {\n\t\ts.errorf(\"indirection through explicit nil in %s\", chain)\n\t}\n\t// (pipe).Field1.Field2 has pipe as .Node, fields as .Field. Eval the pipeline, then the fields.\n\tpipe := s.evalArg(dot, nil, chain.Node)\n\treturn s.evalFieldChain(dot, pipe, chain, chain.Field, args, final)\n}",
    "filename": "/usr/local/go/src/text/template/exec.go",
    "line": 633
  },
  {
    "id": 147,
    "text": "func (s *state) evalVariableNode(dot reflect.Value, variable *parse.VariableNode, args []parse.Node, final reflect.Value) reflect.Value {\n\t// $x.Field has $x as the first ident, Field as the second. Eval the var, then the fields.\n\ts.at(variable)\n\tvalue := s.varValue(variable.Ident[0])\n\tif len(variable.Ident) == 1 {\n\t\ts.notAFunction(args, final)\n\t\treturn value\n\t}\n\treturn s.evalFieldChain(dot, value, variable, variable.Ident[1:], args, final)\n}",
    "filename": "/usr/local/go/src/text/template/exec.go",
    "line": 646
  },
  {
    "id": 148,
    "text": "func (s *state) evalFieldChain(dot, receiver reflect.Value, node parse.Node, ident []string, args []parse.Node, final reflect.Value) reflect.Value {\n\tn := len(ident)\n\tfor i := 0; i \u003c n-1; i++ {\n\t\treceiver = s.evalField(dot, ident[i], node, nil, missingVal, receiver)\n\t}\n\t// Now if it's a method, it gets the arguments.\n\treturn s.evalField(dot, ident[n-1], node, args, final, receiver)\n}",
    "filename": "/usr/local/go/src/text/template/exec.go",
    "line": 660
  },
  {
    "id": 149,
    "text": "func (s *state) evalFunction(dot reflect.Value, node *parse.IdentifierNode, cmd parse.Node, args []parse.Node, final reflect.Value) reflect.Value {\n\ts.at(node)\n\tname := node.Ident\n\tfunction, isBuiltin, ok := findFunction(name, s.tmpl)\n\tif !ok {\n\t\ts.errorf(\"%q is not a defined function\", name)\n\t}\n\treturn s.evalCall(dot, function, isBuiltin, cmd, name, args, final)\n}",
    "filename": "/usr/local/go/src/text/template/exec.go",
    "line": 669
  },
  {
    "id": 150,
    "text": "func (s *state) evalField(dot reflect.Value, fieldName string, node parse.Node, args []parse.Node, final, receiver reflect.Value) reflect.Value {\n\tif !receiver.IsValid() {\n\t\tif s.tmpl.option.missingKey == mapError { // Treat invalid value as missing map key.\n\t\t\ts.errorf(\"nil data; no entry for key %q\", fieldName)\n\t\t}\n\t\treturn zero\n\t}\n\ttyp := receiver.Type()\n\treceiver, isNil := indirect(receiver)\n\tif receiver.Kind() == reflect.Interface \u0026\u0026 isNil {\n\t\t// Calling a method on a nil interface can't work. The\n\t\t// MethodByName method call below would panic.\n\t\ts.errorf(\"nil pointer evaluating %s.%s\", typ, fieldName)\n\t\treturn zero\n\t}\n\n\t// Unless it's an interface, need to get to a value of type *T to guarantee\n\t// we see all methods of T and *T.\n\tptr := receiver\n\tif ptr.Kind() != reflect.Interface \u0026\u0026 ptr.Kind() != reflect.Pointer \u0026\u0026 ptr.CanAddr() {\n\t\tptr = ptr.Addr()\n\t}\n\tif method := ptr.MethodByName(fieldName); method.IsValid() {\n\t\treturn s.evalCall(dot, method, false, node, fieldName, args, final)\n\t}\n\thasArgs := len(args) \u003e 1 || !isMissing(final)\n\t// It's not a method; must be a field of a struct or an element of a map.\n\tswitch receiver.Kind() {\n\tcase reflect.Struct:\n\t\ttField, ok := receiver.Type().FieldByName(fieldName)\n\t\tif ok {\n\t\t\tfield, err := receiver.FieldByIndexErr(tField.Index)\n\t\t\tif !tField.IsExported() {\n\t\t\t\ts.errorf(\"%s is an unexported field of struct type %s\", fieldName, typ)\n\t\t\t}\n\t\t\tif err != nil {\n\t\t\t\ts.errorf(\"%v\", err)\n\t\t\t}\n\t\t\t// If it's a function, we must call it.\n\t\t\tif hasArgs {\n\t\t\t\ts.errorf(\"%s has arguments but cannot be invoked as function\", fieldName)\n\t\t\t}\n\t\t\treturn field\n\t\t}\n\tcase reflect.Map:\n\t\t// If it's a map, attempt to use the field name as a key.\n\t\tnameVal := reflect.ValueOf(fieldName)\n\t\tif nameVal.Type().AssignableTo(receiver.Type().Key()) {\n\t\t\tif hasArgs {\n\t\t\t\ts.errorf(\"%s is not a method but has arguments\", fieldName)\n\t\t\t}\n\t\t\tresult := receiver.MapIndex(nameVal)\n\t\t\tif !result.IsValid() {\n\t\t\t\tswitch s.tmpl.option.missingKey {\n\t\t\t\tcase mapInvalid:\n\t\t\t\t\t// Just use the invalid value.\n\t\t\t\tcase mapZeroValue:\n\t\t\t\t\tresult = reflect.Zero(receiver.Type().Elem())\n\t\t\t\tcase mapError:\n\t\t\t\t\ts.errorf(\"map has no entry for key %q\", fieldName)\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn result\n\t\t}\n\tcase reflect.Pointer:\n\t\tetyp := receiver.Type().Elem()\n\t\tif etyp.Kind() == reflect.Struct {\n\t\t\tif _, ok := etyp.FieldByName(fieldName); !ok {\n\t\t\t\t// If there's no such field, say \"can't evaluate\"\n\t\t\t\t// instead of \"nil pointer evaluating\".\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif isNil {\n\t\t\ts.errorf(\"nil pointer evaluating %s.%s\", typ, fieldName)\n\t\t}\n\t}\n\ts.errorf(\"can't evaluate field %s in type %s\", fieldName, typ)\n\tpanic(\"not reached\")\n}",
    "filename": "/usr/local/go/src/text/template/exec.go",
    "line": 682
  },
  {
    "id": 151,
    "text": "func (s *state) evalCall(dot, fun reflect.Value, isBuiltin bool, node parse.Node, name string, args []parse.Node, final reflect.Value) reflect.Value {\n\tif args != nil {\n\t\targs = args[1:] // Zeroth arg is function name/node; not passed to function.\n\t}\n\ttyp := fun.Type()\n\tnumIn := len(args)\n\tif !isMissing(final) {\n\t\tnumIn++\n\t}\n\tnumFixed := len(args)\n\tif typ.IsVariadic() {\n\t\tnumFixed = typ.NumIn() - 1 // last arg is the variadic one.\n\t\tif numIn \u003c numFixed {\n\t\t\ts.errorf(\"wrong number of args for %s: want at least %d got %d\", name, typ.NumIn()-1, len(args))\n\t\t}\n\t} else if numIn != typ.NumIn() {\n\t\ts.errorf(\"wrong number of args for %s: want %d got %d\", name, typ.NumIn(), numIn)\n\t}\n\tif err := goodFunc(name, typ); err != nil {\n\t\ts.errorf(\"%v\", err)\n\t}\n\n\tunwrap := func(v reflect.Value) reflect.Value {\n\t\tif v.Type() == reflectValueType {\n\t\t\tv = v.Interface().(reflect.Value)\n\t\t}\n\t\treturn v\n\t}\n\n\t// Special case for builtin and/or, which short-circuit.\n\tif isBuiltin \u0026\u0026 (name == \"and\" || name == \"or\") {\n\t\targType := typ.In(0)\n\t\tvar v reflect.Value\n\t\tfor _, arg := range args {\n\t\t\tv = s.evalArg(dot, argType, arg).Interface().(reflect.Value)\n\t\t\tif truth(v) == (name == \"or\") {\n\t\t\t\t// This value was already unwrapped\n\t\t\t\t// by the .Interface().(reflect.Value).\n\t\t\t\treturn v\n\t\t\t}\n\t\t}\n\t\tif !final.Equal(missingVal) {\n\t\t\t// The last argument to and/or is coming from\n\t\t\t// the pipeline. We didn't short circuit on an earlier\n\t\t\t// argument, so we are going to return this one.\n\t\t\t// We don't have to evaluate final, but we do\n\t\t\t// have to check its type. Then, since we are\n\t\t\t// going to return it, we have to unwrap it.\n\t\t\tv = unwrap(s.validateType(final, argType))\n\t\t}\n\t\treturn v\n\t}\n\n\t// Build the arg list.\n\targv := make([]reflect.Value, numIn)\n\t// Args must be evaluated. Fixed args first.\n\ti := 0\n\tfor ; i \u003c numFixed \u0026\u0026 i \u003c len(args); i++ {\n\t\targv[i] = s.evalArg(dot, typ.In(i), args[i])\n\t}\n\t// Now the ... args.\n\tif typ.IsVariadic() {\n\t\targType := typ.In(typ.NumIn() - 1).Elem() // Argument is a slice.\n\t\tfor ; i \u003c len(args); i++ {\n\t\t\targv[i] = s.evalArg(dot, argType, args[i])\n\t\t}\n\t}\n\t// Add final value if necessary.\n\tif !isMissing(final) {\n\t\tt := typ.In(typ.NumIn() - 1)\n\t\tif typ.IsVariadic() {\n\t\t\tif numIn-1 \u003c numFixed {\n\t\t\t\t// The added final argument corresponds to a fixed parameter of the function.\n\t\t\t\t// Validate against the type of the actual parameter.\n\t\t\t\tt = typ.In(numIn - 1)\n\t\t\t} else {\n\t\t\t\t// The added final argument corresponds to the variadic part.\n\t\t\t\t// Validate against the type of the elements of the variadic slice.\n\t\t\t\tt = t.Elem()\n\t\t\t}\n\t\t}\n\t\targv[i] = s.validateType(final, t)\n\t}\n\n\t// Special case for the \"call\" builtin.\n\t// Insert the name of the callee function as the first argument.\n\tif isBuiltin \u0026\u0026 name == \"call\" {\n\t\tvar calleeName string\n\t\tif len(args) == 0 {\n\t\t\t// final must be present or we would have errored out above.\n\t\t\tcalleeName = final.String()\n\t\t} else {\n\t\t\tcalleeName = args[0].String()\n\t\t}\n\t\targv = append([]reflect.Value{reflect.ValueOf(calleeName)}, argv...)\n\t\tfun = reflect.ValueOf(call)\n\t}\n\n\tv, err := safeCall(fun, argv)\n\t// If we have an error that is not nil, stop execution and return that\n\t// error to the caller.\n\tif err != nil {\n\t\ts.at(node)\n\t\ts.errorf(\"error calling %s: %w\", name, err)\n\t}\n\treturn unwrap(v)\n}",
    "filename": "/usr/local/go/src/text/template/exec.go",
    "line": 772
  },
  {
    "id": 152,
    "text": "func canBeNil(typ reflect.Type) bool {\n\tswitch typ.Kind() {\n\tcase reflect.Chan, reflect.Func, reflect.Interface, reflect.Map, reflect.Pointer, reflect.Slice:\n\t\treturn true\n\tcase reflect.Struct:\n\t\treturn typ == reflectValueType\n\t}\n\treturn false\n}",
    "filename": "/usr/local/go/src/text/template/exec.go",
    "line": 881
  },
  {
    "id": 153,
    "text": "func (s *state) validateType(value reflect.Value, typ reflect.Type) reflect.Value {\n\tif !value.IsValid() {\n\t\tif typ == nil {\n\t\t\t// An untyped nil interface{}. Accept as a proper nil value.\n\t\t\treturn reflect.ValueOf(nil)\n\t\t}\n\t\tif canBeNil(typ) {\n\t\t\t// Like above, but use the zero value of the non-nil type.\n\t\t\treturn reflect.Zero(typ)\n\t\t}\n\t\ts.errorf(\"invalid value; expected %s\", typ)\n\t}\n\tif typ == reflectValueType \u0026\u0026 value.Type() != typ {\n\t\treturn reflect.ValueOf(value)\n\t}\n\tif typ != nil \u0026\u0026 !value.Type().AssignableTo(typ) {\n\t\tif value.Kind() == reflect.Interface \u0026\u0026 !value.IsNil() {\n\t\t\tvalue = value.Elem()\n\t\t\tif value.Type().AssignableTo(typ) {\n\t\t\t\treturn value\n\t\t\t}\n\t\t\t// fallthrough\n\t\t}\n\t\t// Does one dereference or indirection work? We could do more, as we\n\t\t// do with method receivers, but that gets messy and method receivers\n\t\t// are much more constrained, so it makes more sense there than here.\n\t\t// Besides, one is almost always all you need.\n\t\tswitch {\n\t\tcase value.Kind() == reflect.Pointer \u0026\u0026 value.Type().Elem().AssignableTo(typ):\n\t\t\tvalue = value.Elem()\n\t\t\tif !value.IsValid() {\n\t\t\t\ts.errorf(\"dereference of nil pointer of type %s\", typ)\n\t\t\t}\n\t\tcase reflect.PointerTo(value.Type()).AssignableTo(typ) \u0026\u0026 value.CanAddr():\n\t\t\tvalue = value.Addr()\n\t\tdefault:\n\t\t\ts.errorf(\"wrong type for value; expected %s; got %s\", typ, value.Type())\n\t\t}\n\t}\n\treturn value\n}",
    "filename": "/usr/local/go/src/text/template/exec.go",
    "line": 892
  },
  {
    "id": 154,
    "text": "func (s *state) evalArg(dot reflect.Value, typ reflect.Type, n parse.Node) reflect.Value {\n\ts.at(n)\n\tswitch arg := n.(type) {\n\tcase *parse.DotNode:\n\t\treturn s.validateType(dot, typ)\n\tcase *parse.NilNode:\n\t\tif canBeNil(typ) {\n\t\t\treturn reflect.Zero(typ)\n\t\t}\n\t\ts.errorf(\"cannot assign nil to %s\", typ)\n\tcase *parse.FieldNode:\n\t\treturn s.validateType(s.evalFieldNode(dot, arg, []parse.Node{n}, missingVal), typ)\n\tcase *parse.VariableNode:\n\t\treturn s.validateType(s.evalVariableNode(dot, arg, nil, missingVal), typ)\n\tcase *parse.PipeNode:\n\t\treturn s.validateType(s.evalPipeline(dot, arg), typ)\n\tcase *parse.IdentifierNode:\n\t\treturn s.validateType(s.evalFunction(dot, arg, arg, nil, missingVal), typ)\n\tcase *parse.ChainNode:\n\t\treturn s.validateType(s.evalChainNode(dot, arg, nil, missingVal), typ)\n\t}\n\tswitch typ.Kind() {\n\tcase reflect.Bool:\n\t\treturn s.evalBool(typ, n)\n\tcase reflect.Complex64, reflect.Complex128:\n\t\treturn s.evalComplex(typ, n)\n\tcase reflect.Float32, reflect.Float64:\n\t\treturn s.evalFloat(typ, n)\n\tcase reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:\n\t\treturn s.evalInteger(typ, n)\n\tcase reflect.Interface:\n\t\tif typ.NumMethod() == 0 {\n\t\t\treturn s.evalEmptyInterface(dot, n)\n\t\t}\n\tcase reflect.Struct:\n\t\tif typ == reflectValueType {\n\t\t\treturn reflect.ValueOf(s.evalEmptyInterface(dot, n))\n\t\t}\n\tcase reflect.String:\n\t\treturn s.evalString(typ, n)\n\tcase reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64, reflect.Uintptr:\n\t\treturn s.evalUnsignedInteger(typ, n)\n\t}\n\ts.errorf(\"can't handle %s for arg of type %s\", n, typ)\n\tpanic(\"not reached\")\n}",
    "filename": "/usr/local/go/src/text/template/exec.go",
    "line": 934
  },
  {
    "id": 155,
    "text": "func (s *state) evalBool(typ reflect.Type, n parse.Node) reflect.Value {\n\ts.at(n)\n\tif n, ok := n.(*parse.BoolNode); ok {\n\t\tvalue := reflect.New(typ).Elem()\n\t\tvalue.SetBool(n.True)\n\t\treturn value\n\t}\n\ts.errorf(\"expected bool; found %s\", n)\n\tpanic(\"not reached\")\n}",
    "filename": "/usr/local/go/src/text/template/exec.go",
    "line": 981
  },
  {
    "id": 156,
    "text": "func (s *state) evalString(typ reflect.Type, n parse.Node) reflect.Value {\n\ts.at(n)\n\tif n, ok := n.(*parse.StringNode); ok {\n\t\tvalue := reflect.New(typ).Elem()\n\t\tvalue.SetString(n.Text)\n\t\treturn value\n\t}\n\ts.errorf(\"expected string; found %s\", n)\n\tpanic(\"not reached\")\n}",
    "filename": "/usr/local/go/src/text/template/exec.go",
    "line": 992
  },
  {
    "id": 157,
    "text": "func (s *state) evalInteger(typ reflect.Type, n parse.Node) reflect.Value {\n\ts.at(n)\n\tif n, ok := n.(*parse.NumberNode); ok \u0026\u0026 n.IsInt {\n\t\tvalue := reflect.New(typ).Elem()\n\t\tvalue.SetInt(n.Int64)\n\t\treturn value\n\t}\n\ts.errorf(\"expected integer; found %s\", n)\n\tpanic(\"not reached\")\n}",
    "filename": "/usr/local/go/src/text/template/exec.go",
    "line": 1003
  },
  {
    "id": 158,
    "text": "func (s *state) evalUnsignedInteger(typ reflect.Type, n parse.Node) reflect.Value {\n\ts.at(n)\n\tif n, ok := n.(*parse.NumberNode); ok \u0026\u0026 n.IsUint {\n\t\tvalue := reflect.New(typ).Elem()\n\t\tvalue.SetUint(n.Uint64)\n\t\treturn value\n\t}\n\ts.errorf(\"expected unsigned integer; found %s\", n)\n\tpanic(\"not reached\")\n}",
    "filename": "/usr/local/go/src/text/template/exec.go",
    "line": 1014
  },
  {
    "id": 159,
    "text": "func (s *state) evalFloat(typ reflect.Type, n parse.Node) reflect.Value {\n\ts.at(n)\n\tif n, ok := n.(*parse.NumberNode); ok \u0026\u0026 n.IsFloat {\n\t\tvalue := reflect.New(typ).Elem()\n\t\tvalue.SetFloat(n.Float64)\n\t\treturn value\n\t}\n\ts.errorf(\"expected float; found %s\", n)\n\tpanic(\"not reached\")\n}",
    "filename": "/usr/local/go/src/text/template/exec.go",
    "line": 1025
  },
  {
    "id": 160,
    "text": "func (s *state) evalComplex(typ reflect.Type, n parse.Node) reflect.Value {\n\tif n, ok := n.(*parse.NumberNode); ok \u0026\u0026 n.IsComplex {\n\t\tvalue := reflect.New(typ).Elem()\n\t\tvalue.SetComplex(n.Complex128)\n\t\treturn value\n\t}\n\ts.errorf(\"expected complex; found %s\", n)\n\tpanic(\"not reached\")\n}",
    "filename": "/usr/local/go/src/text/template/exec.go",
    "line": 1036
  },
  {
    "id": 161,
    "text": "func (s *state) evalEmptyInterface(dot reflect.Value, n parse.Node) reflect.Value {\n\ts.at(n)\n\tswitch n := n.(type) {\n\tcase *parse.BoolNode:\n\t\treturn reflect.ValueOf(n.True)\n\tcase *parse.DotNode:\n\t\treturn dot\n\tcase *parse.FieldNode:\n\t\treturn s.evalFieldNode(dot, n, nil, missingVal)\n\tcase *parse.IdentifierNode:\n\t\treturn s.evalFunction(dot, n, n, nil, missingVal)\n\tcase *parse.NilNode:\n\t\t// NilNode is handled in evalArg, the only place that calls here.\n\t\ts.errorf(\"evalEmptyInterface: nil (can't happen)\")\n\tcase *parse.NumberNode:\n\t\treturn s.idealConstant(n)\n\tcase *parse.StringNode:\n\t\treturn reflect.ValueOf(n.Text)\n\tcase *parse.VariableNode:\n\t\treturn s.evalVariableNode(dot, n, nil, missingVal)\n\tcase *parse.PipeNode:\n\t\treturn s.evalPipeline(dot, n)\n\t}\n\ts.errorf(\"can't handle assignment of %s to empty interface argument\", n)\n\tpanic(\"not reached\")\n}",
    "filename": "/usr/local/go/src/text/template/exec.go",
    "line": 1046
  },
  {
    "id": 162,
    "text": "func indirect(v reflect.Value) (rv reflect.Value, isNil bool) {\n\tfor ; v.Kind() == reflect.Pointer || v.Kind() == reflect.Interface; v = v.Elem() {\n\t\tif v.IsNil() {\n\t\t\treturn v, true\n\t\t}\n\t}\n\treturn v, false\n}",
    "filename": "/usr/local/go/src/text/template/exec.go",
    "line": 1076
  },
  {
    "id": 163,
    "text": "func indirectInterface(v reflect.Value) reflect.Value {\n\tif v.Kind() != reflect.Interface {\n\t\treturn v\n\t}\n\tif v.IsNil() {\n\t\treturn reflect.Value{}\n\t}\n\treturn v.Elem()\n}",
    "filename": "/usr/local/go/src/text/template/exec.go",
    "line": 1089
  },
  {
    "id": 164,
    "text": "func (s *state) printValue(n parse.Node, v reflect.Value) {\n\ts.at(n)\n\tiface, ok := printableValue(v)\n\tif !ok {\n\t\ts.errorf(\"can't print %s of type %s\", n, v.Type())\n\t}\n\t_, err := fmt.Fprint(s.wr, iface)\n\tif err != nil {\n\t\ts.writeError(err)\n\t}\n}",
    "filename": "/usr/local/go/src/text/template/exec.go",
    "line": 1101
  },
  {
    "id": 165,
    "text": "func printableValue(v reflect.Value) (any, bool) {\n\tif v.Kind() == reflect.Pointer {\n\t\tv, _ = indirect(v) // fmt.Fprint handles nil.\n\t}\n\tif !v.IsValid() {\n\t\treturn \"\u003cno value\u003e\", true\n\t}\n\n\tif !v.Type().Implements(errorType) \u0026\u0026 !v.Type().Implements(fmtStringerType) {\n\t\tif v.CanAddr() \u0026\u0026 (reflect.PointerTo(v.Type()).Implements(errorType) || reflect.PointerTo(v.Type()).Implements(fmtStringerType)) {\n\t\t\tv = v.Addr()\n\t\t} else {\n\t\t\tswitch v.Kind() {\n\t\t\tcase reflect.Chan, reflect.Func:\n\t\t\t\treturn nil, false\n\t\t\t}\n\t\t}\n\t}\n\treturn v.Interface(), true\n}",
    "filename": "/usr/local/go/src/text/template/exec.go",
    "line": 1115
  },
  {
    "id": 166,
    "text": "func (S) Method0() string {\n\treturn \"M0\"\n}",
    "filename": "/usr/local/go/src/text/template/exec_test.go",
    "line": 99
  },
  {
    "id": 167,
    "text": "func (v *V) String() string {\n\tif v == nil {\n\t\treturn \"nilV\"\n\t}\n\treturn fmt.Sprintf(\"\u003c%d\u003e\", v.j)\n}",
    "filename": "/usr/local/go/src/text/template/exec_test.go",
    "line": 111
  },
  {
    "id": 168,
    "text": "func (w *W) Error() string {\n\tif w == nil {\n\t\treturn \"nilW\"\n\t}\n\treturn fmt.Sprintf(\"[%d]\", w.k)\n}",
    "filename": "/usr/local/go/src/text/template/exec_test.go",
    "line": 122
  },
  {
    "id": 169,
    "text": "func newInt(n int) *int {\n\treturn \u0026n\n}",
    "filename": "/usr/local/go/src/text/template/exec_test.go",
    "line": 195
  },
  {
    "id": 170,
    "text": "func newUnsafePointer(n int) unsafe.Pointer {\n\treturn unsafe.Pointer(\u0026n)\n}",
    "filename": "/usr/local/go/src/text/template/exec_test.go",
    "line": 199
  },
  {
    "id": 171,
    "text": "func newString(s string) *string {\n\treturn \u0026s\n}",
    "filename": "/usr/local/go/src/text/template/exec_test.go",
    "line": 203
  },
  {
    "id": 172,
    "text": "func newIntSlice(n ...int) *[]int {\n\tp := new([]int)\n\t*p = make([]int, len(n))\n\tcopy(*p, n)\n\treturn p\n}",
    "filename": "/usr/local/go/src/text/template/exec_test.go",
    "line": 207
  },
  {
    "id": 173,
    "text": "func (t *T) Method0() string {\n\treturn \"M0\"\n}",
    "filename": "/usr/local/go/src/text/template/exec_test.go",
    "line": 215
  },
  {
    "id": 174,
    "text": "func (t *T) Method1(a int) int {\n\treturn a\n}",
    "filename": "/usr/local/go/src/text/template/exec_test.go",
    "line": 219
  },
  {
    "id": 175,
    "text": "func (t *T) Method2(a uint16, b string) string {\n\treturn fmt.Sprintf(\"Method2: %d %s\", a, b)\n}",
    "filename": "/usr/local/go/src/text/template/exec_test.go",
    "line": 223
  },
  {
    "id": 176,
    "text": "func (t *T) Method3(v any) string {\n\treturn fmt.Sprintf(\"Method3: %v\", v)\n}",
    "filename": "/usr/local/go/src/text/template/exec_test.go",
    "line": 227
  },
  {
    "id": 177,
    "text": "func (t *T) Copy() *T {\n\tn := new(T)\n\t*n = *t\n\treturn n\n}",
    "filename": "/usr/local/go/src/text/template/exec_test.go",
    "line": 231
  },
  {
    "id": 178,
    "text": "func (t *T) MAdd(a int, b []int) []int {\n\tv := make([]int, len(b))\n\tfor i, x := range b {\n\t\tv[i] = x + a\n\t}\n\treturn v\n}",
    "filename": "/usr/local/go/src/text/template/exec_test.go",
    "line": 237
  },
  {
    "id": 179,
    "text": "func (t *T) MyError(error bool) (bool, error) {\n\tif error {\n\t\treturn true, myError\n\t}\n\treturn false, nil\n}",
    "filename": "/usr/local/go/src/text/template/exec_test.go",
    "line": 248
  },
  {
    "id": 180,
    "text": "func (t *T) GetU() *U {\n\treturn t.U\n}",
    "filename": "/usr/local/go/src/text/template/exec_test.go",
    "line": 256
  },
  {
    "id": 181,
    "text": "func (u *U) TrueFalse(b bool) string {\n\tif b {\n\t\treturn \"true\"\n\t}\n\treturn \"\"\n}",
    "filename": "/usr/local/go/src/text/template/exec_test.go",
    "line": 260
  },
  {
    "id": 182,
    "text": "func typeOf(arg any) string {\n\treturn fmt.Sprintf(\"%T\", arg)\n}",
    "filename": "/usr/local/go/src/text/template/exec_test.go",
    "line": 267
  },
  {
    "id": 183,
    "text": "func fVal1(i int) iter.Seq[int] {\n\treturn func(yield func(int) bool) {\n\t\tfor v := range i {\n\t\t\tif !yield(v) {\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t}\n}",
    "filename": "/usr/local/go/src/text/template/exec_test.go",
    "line": 748
  },
  {
    "id": 184,
    "text": "func fVal2(i int) iter.Seq2[int, int] {\n\treturn func(yield func(int, int) bool) {\n\t\tfor v := range i {\n\t\t\tif !yield(v, v+1) {\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t}\n}",
    "filename": "/usr/local/go/src/text/template/exec_test.go",
    "line": 758
  },
  {
    "id": 185,
    "text": "func rangeTestData[T int | int8 | int16 | int32 | int64 | uint | uint8 | uint16 | uint32 | uint64 | uintptr]() string {\n\tI := T(5)\n\tvar buf strings.Builder\n\tfor i := T(0); i \u003c I; i++ {\n\t\tfmt.Fprintf(\u0026buf, \"%T%d\", i, i)\n\t}\n\treturn buf.String()\n}",
    "filename": "/usr/local/go/src/text/template/exec_test.go",
    "line": 770
  },
  {
    "id": 186,
    "text": "func zeroArgs() string {\n\treturn \"zeroArgs\"\n}",
    "filename": "/usr/local/go/src/text/template/exec_test.go",
    "line": 779
  },
  {
    "id": 187,
    "text": "func oneArg(a string) string {\n\treturn \"oneArg=\" + a\n}",
    "filename": "/usr/local/go/src/text/template/exec_test.go",
    "line": 783
  },
  {
    "id": 188,
    "text": "func twoArgs(a, b string) string {\n\treturn \"twoArgs=\" + a + b\n}",
    "filename": "/usr/local/go/src/text/template/exec_test.go",
    "line": 787
  },
  {
    "id": 189,
    "text": "func dddArg(a int, b ...string) string {\n\treturn fmt.Sprintln(a, b)\n}",
    "filename": "/usr/local/go/src/text/template/exec_test.go",
    "line": 791
  },
  {
    "id": 190,
    "text": "func count(n int) chan string {\n\tif n == 0 {\n\t\treturn nil\n\t}\n\tc := make(chan string)\n\tgo func() {\n\t\tfor i := 0; i \u003c n; i++ {\n\t\t\tc \u003c- \"abcdefghijklmnop\"[i : i+1]\n\t\t}\n\t\tclose(c)\n\t}()\n\treturn c\n}",
    "filename": "/usr/local/go/src/text/template/exec_test.go",
    "line": 796
  },
  {
    "id": 191,
    "text": "func vfunc(V, *V) string {\n\treturn \"vfunc\"\n}",
    "filename": "/usr/local/go/src/text/template/exec_test.go",
    "line": 811
  },
  {
    "id": 192,
    "text": "func valueString(v string) string {\n\treturn \"value is ignored\"\n}",
    "filename": "/usr/local/go/src/text/template/exec_test.go",
    "line": 816
  },
  {
    "id": 193,
    "text": "func returnInt() int {\n\treturn 7\n}",
    "filename": "/usr/local/go/src/text/template/exec_test.go",
    "line": 821
  },
  {
    "id": 194,
    "text": "func add(args ...int) int {\n\tsum := 0\n\tfor _, x := range args {\n\t\tsum += x\n\t}\n\treturn sum\n}",
    "filename": "/usr/local/go/src/text/template/exec_test.go",
    "line": 825
  },
  {
    "id": 195,
    "text": "func echo(arg any) any {\n\treturn arg\n}",
    "filename": "/usr/local/go/src/text/template/exec_test.go",
    "line": 833
  },
  {
    "id": 196,
    "text": "func makemap(arg ...string) map[string]string {\n\tif len(arg)%2 != 0 {\n\t\tpanic(\"bad makemap\")\n\t}\n\tm := make(map[string]string)\n\tfor i := 0; i \u003c len(arg); i += 2 {\n\t\tm[arg[i]] = arg[i+1]\n\t}\n\treturn m\n}",
    "filename": "/usr/local/go/src/text/template/exec_test.go",
    "line": 837
  },
  {
    "id": 197,
    "text": "func stringer(s fmt.Stringer) string {\n\treturn s.String()\n}",
    "filename": "/usr/local/go/src/text/template/exec_test.go",
    "line": 848
  },
  {
    "id": 198,
    "text": "func mapOfThree() any {\n\treturn map[string]int{\"three\": 3}\n}",
    "filename": "/usr/local/go/src/text/template/exec_test.go",
    "line": 852
  },
  {
    "id": 199,
    "text": "func testExecute(execTests []execTest, template *Template, t *testing.T) {\n\tb := new(strings.Builder)\n\tfuncs := FuncMap{\n\t\t\"add\":         add,\n\t\t\"count\":       count,\n\t\t\"dddArg\":      dddArg,\n\t\t\"die\":         func() bool { panic(\"die\") },\n\t\t\"echo\":        echo,\n\t\t\"makemap\":     makemap,\n\t\t\"mapOfThree\":  mapOfThree,\n\t\t\"oneArg\":      oneArg,\n\t\t\"returnInt\":   returnInt,\n\t\t\"stringer\":    stringer,\n\t\t\"twoArgs\":     twoArgs,\n\t\t\"typeOf\":      typeOf,\n\t\t\"valueString\": valueString,\n\t\t\"vfunc\":       vfunc,\n\t\t\"zeroArgs\":    zeroArgs,\n\t}\n\tfor _, test := range execTests {\n\t\tvar tmpl *Template\n\t\tvar err error\n\t\tif template == nil {\n\t\t\ttmpl, err = New(test.name).Funcs(funcs).Parse(test.input)\n\t\t} else {\n\t\t\ttmpl, err = template.New(test.name).Funcs(funcs).Parse(test.input)\n\t\t}\n\t\tif err != nil {\n\t\t\tt.Errorf(\"%s: parse error: %s\", test.name, err)\n\t\t\tcontinue\n\t\t}\n\t\tb.Reset()\n\t\terr = tmpl.Execute(b, test.data)\n\t\tswitch {\n\t\tcase !test.ok \u0026\u0026 err == nil:\n\t\t\tt.Errorf(\"%s: expected error; got none\", test.name)\n\t\t\tcontinue\n\t\tcase test.ok \u0026\u0026 err != nil:\n\t\t\tt.Errorf(\"%s: unexpected execute error: %s\", test.name, err)\n\t\t\tcontinue\n\t\tcase !test.ok \u0026\u0026 err != nil:\n\t\t\t// expected error, got one\n\t\t\tif *debug {\n\t\t\t\tfmt.Printf(\"%s: %s\\n\\t%s\\n\", test.name, test.input, err)\n\t\t\t}\n\t\t}\n\t\tresult := b.String()\n\t\tif result != test.output {\n\t\t\tt.Errorf(\"%s: expected\\n\\t%q\\ngot\\n\\t%q\", test.name, test.output, result)\n\t\t}\n\t}\n}",
    "filename": "/usr/local/go/src/text/template/exec_test.go",
    "line": 856
  },
  {
    "id": 200,
    "text": "func TestExecute(t *testing.T) {\n\ttestExecute(execTests, nil, t)\n}",
    "filename": "/usr/local/go/src/text/template/exec_test.go",
    "line": 909
  },
  {
    "id": 201,
    "text": "func TestDelims(t *testing.T) {\n\tconst hello = \"Hello, world\"\n\tvar value = struct{ Str string }{hello}\n\tfor i := 0; i \u003c len(delimPairs); i += 2 {\n\t\ttext := \".Str\"\n\t\tleft := delimPairs[i+0]\n\t\ttrueLeft := left\n\t\tright := delimPairs[i+1]\n\t\ttrueRight := right\n\t\tif left == \"\" { // default case\n\t\t\ttrueLeft = \"{{\"\n\t\t}\n\t\tif right == \"\" { // default case\n\t\t\ttrueRight = \"}}\"\n\t\t}\n\t\ttext = trueLeft + text + trueRight\n\t\t// Now add a comment\n\t\ttext += trueLeft + \"/*comment*/\" + trueRight\n\t\t// Now add  an action containing a string.\n\t\ttext += trueLeft + `\"` + trueLeft + `\"` + trueRight\n\t\t// At this point text looks like `{{.Str}}{{/*comment*/}}{{\"{{\"}}`.\n\t\ttmpl, err := New(\"delims\").Delims(left, right).Parse(text)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"delim %q text %q parse err %s\", left, text, err)\n\t\t}\n\t\tvar b = new(strings.Builder)\n\t\terr = tmpl.Execute(b, value)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"delim %q exec err %s\", left, err)\n\t\t}\n\t\tif b.String() != hello+trueLeft {\n\t\t\tt.Errorf(\"expected %q got %q\", hello+trueLeft, b.String())\n\t\t}\n\t}\n}",
    "filename": "/usr/local/go/src/text/template/exec_test.go",
    "line": 921
  },
  {
    "id": 202,
    "text": "func TestExecuteError(t *testing.T) {\n\tb := new(bytes.Buffer)\n\ttmpl := New(\"error\")\n\t_, err := tmpl.Parse(\"{{.MyError true}}\")\n\tif err != nil {\n\t\tt.Fatalf(\"parse error: %s\", err)\n\t}\n\terr = tmpl.Execute(b, tVal)\n\tif err == nil {\n\t\tt.Errorf(\"expected error; got none\")\n\t} else if !strings.Contains(err.Error(), myError.Error()) {\n\t\tif *debug {\n\t\t\tfmt.Printf(\"test execute error: %s\\n\", err)\n\t\t}\n\t\tt.Errorf(\"expected myError; got %s\", err)\n\t}\n}",
    "filename": "/usr/local/go/src/text/template/exec_test.go",
    "line": 958
  },
  {
    "id": 203,
    "text": "func TestExecError(t *testing.T) {\n\ttmpl, err := New(\"top\").Parse(execErrorText)\n\tif err != nil {\n\t\tt.Fatal(\"parse error:\", err)\n\t}\n\tvar b bytes.Buffer\n\terr = tmpl.Execute(\u0026b, 5) // 5 is out of range indexing \"hi\"\n\tif err == nil {\n\t\tt.Fatal(\"expected error\")\n\t}\n\tconst want = `template: top:7:20: executing \"three\" at \u003cindex \"hi\" $\u003e: error calling index: index out of range: 5`\n\tgot := err.Error()\n\tif got != want {\n\t\tt.Errorf(\"expected\\n%q\\ngot\\n%q\", want, got)\n\t}\n}",
    "filename": "/usr/local/go/src/text/template/exec_test.go",
    "line": 985
  },
  {
    "id": 204,
    "text": "func (*CustomError) Error() string { return \"heyo !\" }",
    "filename": "/usr/local/go/src/text/template/exec_test.go",
    "line": 1004
  },
  {
    "id": 205,
    "text": "func TestExecError_CustomError(t *testing.T) {\n\tfailingFunc := func() (string, error) {\n\t\treturn \"\", \u0026CustomError{}\n\t}\n\ttmpl := Must(New(\"top\").Funcs(FuncMap{\n\t\t\"err\": failingFunc,\n\t}).Parse(\"{{ err }}\"))\n\n\tvar b bytes.Buffer\n\terr := tmpl.Execute(\u0026b, nil)\n\n\tvar e *CustomError\n\tif !errors.As(err, \u0026e) {\n\t\tt.Fatalf(\"expected custom error; got %s\", err)\n\t}\n}",
    "filename": "/usr/local/go/src/text/template/exec_test.go",
    "line": 1007
  },
  {
    "id": 206,
    "text": "func TestJSEscaping(t *testing.T) {\n\ttestCases := []struct {\n\t\tin, exp string\n\t}{\n\t\t{`a`, `a`},\n\t\t{`'foo`, `\\'foo`},\n\t\t{`Go \"jump\" \\`, `Go \\\"jump\\\" \\\\`},\n\t\t{`Yukihiro says \"今日は世界\"`, `Yukihiro says \\\"今日は世界\\\"`},\n\t\t{\"unprintable \\uFFFE\", `unprintable \\uFFFE`},\n\t\t{`\u003chtml\u003e`, `\\u003Chtml\\u003E`},\n\t\t{`no = in attributes`, `no \\u003D in attributes`},\n\t\t{`\u0026#x27; does not become HTML entity`, `\\u0026#x27; does not become HTML entity`},\n\t}\n\tfor _, tc := range testCases {\n\t\ts := JSEscapeString(tc.in)\n\t\tif s != tc.exp {\n\t\t\tt.Errorf(\"JS escaping [%s] got [%s] want [%s]\", tc.in, s, tc.exp)\n\t\t}\n\t}\n}",
    "filename": "/usr/local/go/src/text/template/exec_test.go",
    "line": 1024
  },
  {
    "id": 207,
    "text": "func TestTree(t *testing.T) {\n\tvar tree = \u0026Tree{\n\t\t1,\n\t\t\u0026Tree{\n\t\t\t2, \u0026Tree{\n\t\t\t\t3,\n\t\t\t\t\u0026Tree{\n\t\t\t\t\t4, nil, nil,\n\t\t\t\t},\n\t\t\t\tnil,\n\t\t\t},\n\t\t\t\u0026Tree{\n\t\t\t\t5,\n\t\t\t\t\u0026Tree{\n\t\t\t\t\t6, nil, nil,\n\t\t\t\t},\n\t\t\t\tnil,\n\t\t\t},\n\t\t},\n\t\t\u0026Tree{\n\t\t\t7,\n\t\t\t\u0026Tree{\n\t\t\t\t8,\n\t\t\t\t\u0026Tree{\n\t\t\t\t\t9, nil, nil,\n\t\t\t\t},\n\t\t\t\tnil,\n\t\t\t},\n\t\t\t\u0026Tree{\n\t\t\t\t10,\n\t\t\t\t\u0026Tree{\n\t\t\t\t\t11, nil, nil,\n\t\t\t\t},\n\t\t\t\tnil,\n\t\t\t},\n\t\t},\n\t}\n\ttmpl, err := New(\"root\").Delims(\"(\", \")\").Parse(treeTemplate)\n\tif err != nil {\n\t\tt.Fatal(\"parse error:\", err)\n\t}\n\tvar b strings.Builder\n\tconst expect = \"[1[2[3[4]][5[6]]][7[8[9]][10[11]]]]\"\n\t// First by looking up the template.\n\terr = tmpl.Lookup(\"tree\").Execute(\u0026b, tree)\n\tif err != nil {\n\t\tt.Fatal(\"exec error:\", err)\n\t}\n\tresult := b.String()\n\tif result != expect {\n\t\tt.Errorf(\"expected %q got %q\", expect, result)\n\t}\n\t// Then direct to execution.\n\tb.Reset()\n\terr = tmpl.ExecuteTemplate(\u0026b, \"tree\", tree)\n\tif err != nil {\n\t\tt.Fatal(\"exec error:\", err)\n\t}\n\tresult = b.String()\n\tif result != expect {\n\t\tt.Errorf(\"expected %q got %q\", expect, result)\n\t}\n}",
    "filename": "/usr/local/go/src/text/template/exec_test.go",
    "line": 1068
  },
  {
    "id": 208,
    "text": "func TestExecuteOnNewTemplate(t *testing.T) {\n\t// This is issue 3872.\n\tNew(\"Name\").Templates()\n\t// This is issue 11379.\n\tnew(Template).Templates()\n\tnew(Template).Parse(\"\")\n\tnew(Template).New(\"abc\").Parse(\"\")\n\tnew(Template).Execute(nil, nil)                // returns an error (but does not crash)\n\tnew(Template).ExecuteTemplate(nil, \"XXX\", nil) // returns an error (but does not crash)\n}",
    "filename": "/usr/local/go/src/text/template/exec_test.go",
    "line": 1132
  },
  {
    "id": 209,
    "text": "func TestMessageForExecuteEmpty(t *testing.T) {\n\t// Test a truly empty template.\n\ttmpl := New(\"empty\")\n\tvar b bytes.Buffer\n\terr := tmpl.Execute(\u0026b, 0)\n\tif err == nil {\n\t\tt.Fatal(\"expected initial error\")\n\t}\n\tgot := err.Error()\n\twant := `template: empty: \"empty\" is an incomplete or empty template`\n\tif got != want {\n\t\tt.Errorf(\"expected error %s got %s\", want, got)\n\t}\n\t// Add a non-empty template to check that the error is helpful.\n\ttests, err := New(\"\").Parse(testTemplates)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\ttmpl.AddParseTree(\"secondary\", tests.Tree)\n\terr = tmpl.Execute(\u0026b, 0)\n\tif err == nil {\n\t\tt.Fatal(\"expected second error\")\n\t}\n\tgot = err.Error()\n\twant = `template: empty: \"empty\" is an incomplete or empty template`\n\tif got != want {\n\t\tt.Errorf(\"expected error %s got %s\", want, got)\n\t}\n\t// Make sure we can execute the secondary.\n\terr = tmpl.ExecuteTemplate(\u0026b, \"secondary\", 0)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n}",
    "filename": "/usr/local/go/src/text/template/exec_test.go",
    "line": 1145
  },
  {
    "id": 210,
    "text": "func TestFinalForPrintf(t *testing.T) {\n\ttmpl, err := New(\"\").Parse(`{{\"x\" | printf}}`)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tvar b bytes.Buffer\n\terr = tmpl.Execute(\u0026b, 0)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n}",
    "filename": "/usr/local/go/src/text/template/exec_test.go",
    "line": 1180
  },
  {
    "id": 211,
    "text": "func TestComparison(t *testing.T) {\n\tb := new(strings.Builder)\n\tvar cmpStruct = struct {\n\t\tUthree, Ufour    uint\n\t\tNegOne, Three    int\n\t\tPtr, NilPtr      *int\n\t\tNonNilMap        map[int]int\n\t\tMap              map[int]int\n\t\tV1, V2           V\n\t\tIface1, NilIface fmt.Stringer\n\t}{\n\t\tUthree:    3,\n\t\tUfour:     4,\n\t\tNegOne:    -1,\n\t\tThree:     3,\n\t\tPtr:       new(int),\n\t\tNonNilMap: make(map[int]int),\n\t\tIface1:    b,\n\t}\n\tfor _, test := range cmpTests {\n\t\ttext := fmt.Sprintf(\"{{if %s}}true{{else}}false{{end}}\", test.expr)\n\t\ttmpl, err := New(\"empty\").Parse(text)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"%q: %s\", test.expr, err)\n\t\t}\n\t\tb.Reset()\n\t\terr = tmpl.Execute(b, \u0026cmpStruct)\n\t\tif test.ok \u0026\u0026 err != nil {\n\t\t\tt.Errorf(\"%s errored incorrectly: %s\", test.expr, err)\n\t\t\tcontinue\n\t\t}\n\t\tif !test.ok \u0026\u0026 err == nil {\n\t\t\tt.Errorf(\"%s did not error\", test.expr)\n\t\t\tcontinue\n\t\t}\n\t\tif b.String() != test.truth {\n\t\t\tt.Errorf(\"%s: want %s; got %s\", test.expr, test.truth, b.String())\n\t\t}\n\t}\n}",
    "filename": "/usr/local/go/src/text/template/exec_test.go",
    "line": 1320
  },
  {
    "id": 212,
    "text": "func TestMissingMapKey(t *testing.T) {\n\tdata := map[string]int{\n\t\t\"x\": 99,\n\t}\n\ttmpl, err := New(\"t1\").Parse(\"{{.x}} {{.y}}\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tvar b strings.Builder\n\t// By default, just get \"\u003cno value\u003e\"\n\terr = tmpl.Execute(\u0026b, data)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\twant := \"99 \u003cno value\u003e\"\n\tgot := b.String()\n\tif got != want {\n\t\tt.Errorf(\"got %q; expected %q\", got, want)\n\t}\n\t// Same if we set the option explicitly to the default.\n\ttmpl.Option(\"missingkey=default\")\n\tb.Reset()\n\terr = tmpl.Execute(\u0026b, data)\n\tif err != nil {\n\t\tt.Fatal(\"default:\", err)\n\t}\n\twant = \"99 \u003cno value\u003e\"\n\tgot = b.String()\n\tif got != want {\n\t\tt.Errorf(\"got %q; expected %q\", got, want)\n\t}\n\t// Next we ask for a zero value\n\ttmpl.Option(\"missingkey=zero\")\n\tb.Reset()\n\terr = tmpl.Execute(\u0026b, data)\n\tif err != nil {\n\t\tt.Fatal(\"zero:\", err)\n\t}\n\twant = \"99 0\"\n\tgot = b.String()\n\tif got != want {\n\t\tt.Errorf(\"got %q; expected %q\", got, want)\n\t}\n\t// Now we ask for an error.\n\ttmpl.Option(\"missingkey=error\")\n\terr = tmpl.Execute(\u0026b, data)\n\tif err == nil {\n\t\tt.Errorf(\"expected error; got none\")\n\t}\n\t// same Option, but now a nil interface: ask for an error\n\terr = tmpl.Execute(\u0026b, nil)\n\tt.Log(err)\n\tif err == nil {\n\t\tt.Errorf(\"expected error for nil-interface; got none\")\n\t}\n}",
    "filename": "/usr/local/go/src/text/template/exec_test.go",
    "line": 1361
  },
  {
    "id": 213,
    "text": "func TestUnterminatedStringError(t *testing.T) {\n\t_, err := New(\"X\").Parse(\"hello\\n\\n{{`unterminated\\n\\n\\n\\n}}\\n some more\\n\\n\")\n\tif err == nil {\n\t\tt.Fatal(\"expected error\")\n\t}\n\tstr := err.Error()\n\tif !strings.Contains(str, \"X:3: unterminated raw quoted string\") {\n\t\tt.Fatalf(\"unexpected error: %s\", str)\n\t}\n}",
    "filename": "/usr/local/go/src/text/template/exec_test.go",
    "line": 1420
  },
  {
    "id": 214,
    "text": "func (e ErrorWriter) Write(p []byte) (int, error) {\n\treturn 0, alwaysError\n}",
    "filename": "/usr/local/go/src/text/template/exec_test.go",
    "line": 1437
  },
  {
    "id": 215,
    "text": "func TestExecuteGivesExecError(t *testing.T) {\n\t// First, a non-execution error shouldn't be an ExecError.\n\ttmpl, err := New(\"X\").Parse(\"hello\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\terr = tmpl.Execute(ErrorWriter(0), 0)\n\tif err == nil {\n\t\tt.Fatal(\"expected error; got none\")\n\t}\n\tif err.Error() != alwaysErrorText {\n\t\tt.Errorf(\"expected %q error; got %q\", alwaysErrorText, err)\n\t}\n\t// This one should be an ExecError.\n\ttmpl, err = New(\"X\").Parse(\"hello, {{.X.Y}}\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\terr = tmpl.Execute(io.Discard, 0)\n\tif err == nil {\n\t\tt.Fatal(\"expected error; got none\")\n\t}\n\teerr, ok := err.(ExecError)\n\tif !ok {\n\t\tt.Fatalf(\"did not expect ExecError %s\", eerr)\n\t}\n\texpect := \"field X in type int\"\n\tif !strings.Contains(err.Error(), expect) {\n\t\tt.Errorf(\"expected %q; got %q\", expect, err)\n\t}\n}",
    "filename": "/usr/local/go/src/text/template/exec_test.go",
    "line": 1441
  },
  {
    "id": 216,
    "text": "func funcNameTestFunc() int {\n\treturn 0\n}",
    "filename": "/usr/local/go/src/text/template/exec_test.go",
    "line": 1473
  },
  {
    "id": 217,
    "text": "func TestGoodFuncNames(t *testing.T) {\n\tnames := []string{\n\t\t\"_\",\n\t\t\"a\",\n\t\t\"a1\",\n\t\t\"a1\",\n\t\t\"Ӵ\",\n\t}\n\tfor _, name := range names {\n\t\ttmpl := New(\"X\").Funcs(\n\t\t\tFuncMap{\n\t\t\t\tname: funcNameTestFunc,\n\t\t\t},\n\t\t)\n\t\tif tmpl == nil {\n\t\t\tt.Fatalf(\"nil result for %q\", name)\n\t\t}\n\t}\n}",
    "filename": "/usr/local/go/src/text/template/exec_test.go",
    "line": 1477
  },
  {
    "id": 218,
    "text": "func TestBadFuncNames(t *testing.T) {\n\tnames := []string{\n\t\t\"\",\n\t\t\"2\",\n\t\t\"a-b\",\n\t}\n\tfor _, name := range names {\n\t\ttestBadFuncName(name, t)\n\t}\n}",
    "filename": "/usr/local/go/src/text/template/exec_test.go",
    "line": 1497
  },
  {
    "id": 219,
    "text": "func TestIsTrue(t *testing.T) {\n\tvar nil_ptr *int\n\tvar nil_chan chan int\n\ttests := []struct {\n\t\tv    any\n\t\twant bool\n\t}{\n\t\t{1, true},\n\t\t{0, false},\n\t\t{uint8(1), true},\n\t\t{uint8(0), false},\n\t\t{float64(1.0), true},\n\t\t{float64(0.0), false},\n\t\t{complex64(1.0), true},\n\t\t{complex64(0.0), false},\n\t\t{true, true},\n\t\t{false, false},\n\t\t{[2]int{1, 2}, true},\n\t\t{[0]int{}, false},\n\t\t{[]byte(\"abc\"), true},\n\t\t{[]byte(\"\"), false},\n\t\t{map[string]int{\"a\": 1, \"b\": 2}, true},\n\t\t{map[string]int{}, false},\n\t\t{make(chan int), true},\n\t\t{nil_chan, false},\n\t\t{new(int), true},\n\t\t{nil_ptr, false},\n\t\t{unsafe.Pointer(new(int)), true},\n\t\t{unsafe.Pointer(nil_ptr), false},\n\t}\n\tfor _, test_case := range tests {\n\t\tgot, _ := IsTrue(test_case.v)\n\t\tif got != test_case.want {\n\t\t\tt.Fatalf(\"expect result %v, got %v\", test_case.want, got)\n\t\t}\n\t}\n}",
    "filename": "/usr/local/go/src/text/template/exec_test.go",
    "line": 1508
  },
  {
    "id": 220,
    "text": "func testBadFuncName(name string, t *testing.T) {\n\tt.Helper()\n\tdefer func() {\n\t\trecover()\n\t}()\n\tNew(\"X\").Funcs(\n\t\tFuncMap{\n\t\t\tname: funcNameTestFunc,\n\t\t},\n\t)\n\t// If we get here, the name did not cause a panic, which is how Funcs\n\t// reports an error.\n\tt.Errorf(\"%q succeeded incorrectly as function name\", name)\n}",
    "filename": "/usr/local/go/src/text/template/exec_test.go",
    "line": 1546
  },
  {
    "id": 221,
    "text": "func TestBlock(t *testing.T) {\n\tconst (\n\t\tinput   = `a({{block \"inner\" .}}bar({{.}})baz{{end}})b`\n\t\twant    = `a(bar(hello)baz)b`\n\t\toverlay = `{{define \"inner\"}}foo({{.}})bar{{end}}`\n\t\twant2   = `a(foo(goodbye)bar)b`\n\t)\n\ttmpl, err := New(\"outer\").Parse(input)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\ttmpl2, err := Must(tmpl.Clone()).Parse(overlay)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tvar buf strings.Builder\n\tif err := tmpl.Execute(\u0026buf, \"hello\"); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif got := buf.String(); got != want {\n\t\tt.Errorf(\"got %q, want %q\", got, want)\n\t}\n\n\tbuf.Reset()\n\tif err := tmpl2.Execute(\u0026buf, \"goodbye\"); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif got := buf.String(); got != want2 {\n\t\tt.Errorf(\"got %q, want %q\", got, want2)\n\t}\n}",
    "filename": "/usr/local/go/src/text/template/exec_test.go",
    "line": 1561
  },
  {
    "id": 222,
    "text": "func TestEvalFieldErrors(t *testing.T) {\n\ttests := []struct {\n\t\tname, src string\n\t\tvalue     any\n\t\twant      string\n\t}{\n\t\t{\n\t\t\t// Check that calling an invalid field on nil pointer\n\t\t\t// prints a field error instead of a distracting nil\n\t\t\t// pointer error. https://golang.org/issue/15125\n\t\t\t\"MissingFieldOnNil\",\n\t\t\t\"{{.MissingField}}\",\n\t\t\t(*T)(nil),\n\t\t\t\"can't evaluate field MissingField in type *template.T\",\n\t\t},\n\t\t{\n\t\t\t\"MissingFieldOnNonNil\",\n\t\t\t\"{{.MissingField}}\",\n\t\t\t\u0026T{},\n\t\t\t\"can't evaluate field MissingField in type *template.T\",\n\t\t},\n\t\t{\n\t\t\t\"ExistingFieldOnNil\",\n\t\t\t\"{{.X}}\",\n\t\t\t(*T)(nil),\n\t\t\t\"nil pointer evaluating *template.T.X\",\n\t\t},\n\t\t{\n\t\t\t\"MissingKeyOnNilMap\",\n\t\t\t\"{{.MissingKey}}\",\n\t\t\t(*map[string]string)(nil),\n\t\t\t\"nil pointer evaluating *map[string]string.MissingKey\",\n\t\t},\n\t\t{\n\t\t\t\"MissingKeyOnNilMapPtr\",\n\t\t\t\"{{.MissingKey}}\",\n\t\t\t(*map[string]string)(nil),\n\t\t\t\"nil pointer evaluating *map[string]string.MissingKey\",\n\t\t},\n\t\t{\n\t\t\t\"MissingKeyOnMapPtrToNil\",\n\t\t\t\"{{.MissingKey}}\",\n\t\t\t\u0026map[string]string{},\n\t\t\t\"\u003cnil\u003e\",\n\t\t},\n\t}\n\tfor _, tc := range tests {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\ttmpl := Must(New(\"tmpl\").Parse(tc.src))\n\t\t\terr := tmpl.Execute(io.Discard, tc.value)\n\t\t\tgot := \"\u003cnil\u003e\"\n\t\t\tif err != nil {\n\t\t\t\tgot = err.Error()\n\t\t\t}\n\t\t\tif !strings.HasSuffix(got, tc.want) {\n\t\t\t\tt.Fatalf(\"got error %q, want %q\", got, tc.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "filename": "/usr/local/go/src/text/template/exec_test.go",
    "line": 1594
  },
  {
    "id": 223,
    "text": "func TestMaxExecDepth(t *testing.T) {\n\tif testing.Short() {\n\t\tt.Skip(\"skipping in -short mode\")\n\t}\n\ttmpl := Must(New(\"tmpl\").Parse(`{{template \"tmpl\" .}}`))\n\terr := tmpl.Execute(io.Discard, nil)\n\tgot := \"\u003cnil\u003e\"\n\tif err != nil {\n\t\tgot = err.Error()\n\t}\n\tconst want = \"exceeded maximum template depth\"\n\tif !strings.Contains(got, want) {\n\t\tt.Errorf(\"got error %q; want %q\", got, want)\n\t}\n}",
    "filename": "/usr/local/go/src/text/template/exec_test.go",
    "line": 1655
  },
  {
    "id": 224,
    "text": "func TestAddrOfIndex(t *testing.T) {\n\t// golang.org/issue/14916.\n\t// Before index worked on reflect.Values, the .String could not be\n\t// found on the (incorrectly unaddressable) V value,\n\t// in contrast to range, which worked fine.\n\t// Also testing that passing a reflect.Value to tmpl.Execute works.\n\ttexts := []string{\n\t\t`{{range .}}{{.String}}{{end}}`,\n\t\t`{{with index . 0}}{{.String}}{{end}}`,\n\t}\n\tfor _, text := range texts {\n\t\ttmpl := Must(New(\"tmpl\").Parse(text))\n\t\tvar buf strings.Builder\n\t\terr := tmpl.Execute(\u0026buf, reflect.ValueOf([]V{{1}}))\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"%s: Execute: %v\", text, err)\n\t\t}\n\t\tif buf.String() != \"\u003c1\u003e\" {\n\t\t\tt.Fatalf(\"%s: template output = %q, want %q\", text, \u0026buf, \"\u003c1\u003e\")\n\t\t}\n\t}\n}",
    "filename": "/usr/local/go/src/text/template/exec_test.go",
    "line": 1671
  },
  {
    "id": 225,
    "text": "func TestInterfaceValues(t *testing.T) {\n\t// golang.org/issue/17714.\n\t// Before index worked on reflect.Values, interface values\n\t// were always implicitly promoted to the underlying value,\n\t// except that nil interfaces were promoted to the zero reflect.Value.\n\t// Eliminating a round trip to interface{} and back to reflect.Value\n\t// eliminated this promotion, breaking these cases.\n\ttests := []struct {\n\t\ttext string\n\t\tout  string\n\t}{\n\t\t{`{{index .Nil 1}}`, \"ERROR: index of untyped nil\"},\n\t\t{`{{index .Slice 2}}`, \"2\"},\n\t\t{`{{index .Slice .Two}}`, \"2\"},\n\t\t{`{{call .Nil 1}}`, \"ERROR: call of nil\"},\n\t\t{`{{call .PlusOne 1}}`, \"2\"},\n\t\t{`{{call .PlusOne .One}}`, \"2\"},\n\t\t{`{{and (index .Slice 0) true}}`, \"0\"},\n\t\t{`{{and .Zero true}}`, \"0\"},\n\t\t{`{{and (index .Slice 1) false}}`, \"false\"},\n\t\t{`{{and .One false}}`, \"false\"},\n\t\t{`{{or (index .Slice 0) false}}`, \"false\"},\n\t\t{`{{or .Zero false}}`, \"false\"},\n\t\t{`{{or (index .Slice 1) true}}`, \"1\"},\n\t\t{`{{or .One true}}`, \"1\"},\n\t\t{`{{not (index .Slice 0)}}`, \"true\"},\n\t\t{`{{not .Zero}}`, \"true\"},\n\t\t{`{{not (index .Slice 1)}}`, \"false\"},\n\t\t{`{{not .One}}`, \"false\"},\n\t\t{`{{eq (index .Slice 0) .Zero}}`, \"true\"},\n\t\t{`{{eq (index .Slice 1) .One}}`, \"true\"},\n\t\t{`{{ne (index .Slice 0) .Zero}}`, \"false\"},\n\t\t{`{{ne (index .Slice 1) .One}}`, \"false\"},\n\t\t{`{{ge (index .Slice 0) .One}}`, \"false\"},\n\t\t{`{{ge (index .Slice 1) .Zero}}`, \"true\"},\n\t\t{`{{gt (index .Slice 0) .One}}`, \"false\"},\n\t\t{`{{gt (index .Slice 1) .Zero}}`, \"true\"},\n\t\t{`{{le (index .Slice 0) .One}}`, \"true\"},\n\t\t{`{{le (index .Slice 1) .Zero}}`, \"false\"},\n\t\t{`{{lt (index .Slice 0) .One}}`, \"true\"},\n\t\t{`{{lt (index .Slice 1) .Zero}}`, \"false\"},\n\t}\n\n\tfor _, tt := range tests {\n\t\ttmpl := Must(New(\"tmpl\").Parse(tt.text))\n\t\tvar buf strings.Builder\n\t\terr := tmpl.Execute(\u0026buf, map[string]any{\n\t\t\t\"PlusOne\": func(n int) int {\n\t\t\t\treturn n + 1\n\t\t\t},\n\t\t\t\"Slice\": []int{0, 1, 2, 3},\n\t\t\t\"One\":   1,\n\t\t\t\"Two\":   2,\n\t\t\t\"Nil\":   nil,\n\t\t\t\"Zero\":  0,\n\t\t})\n\t\tif strings.HasPrefix(tt.out, \"ERROR:\") {\n\t\t\te := strings.TrimSpace(strings.TrimPrefix(tt.out, \"ERROR:\"))\n\t\t\tif err == nil || !strings.Contains(err.Error(), e) {\n\t\t\t\tt.Errorf(\"%s: Execute: %v, want error %q\", tt.text, err, e)\n\t\t\t}\n\t\t\tcontinue\n\t\t}\n\t\tif err != nil {\n\t\t\tt.Errorf(\"%s: Execute: %v\", tt.text, err)\n\t\t\tcontinue\n\t\t}\n\t\tif buf.String() != tt.out {\n\t\t\tt.Errorf(\"%s: template output = %q, want %q\", tt.text, \u0026buf, tt.out)\n\t\t}\n\t}\n}",
    "filename": "/usr/local/go/src/text/template/exec_test.go",
    "line": 1694
  },
  {
    "id": 226,
    "text": "func TestExecutePanicDuringCall(t *testing.T) {\n\tfuncs := map[string]any{\n\t\t\"doPanic\": func() string {\n\t\t\tpanic(\"custom panic string\")\n\t\t},\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\tinput   string\n\t\tdata    any\n\t\twantErr string\n\t}{\n\t\t{\n\t\t\t\"direct func call panics\",\n\t\t\t\"{{doPanic}}\", (*T)(nil),\n\t\t\t`template: t:1:2: executing \"t\" at \u003cdoPanic\u003e: error calling doPanic: custom panic string`,\n\t\t},\n\t\t{\n\t\t\t\"indirect func call panics\",\n\t\t\t\"{{call doPanic}}\", (*T)(nil),\n\t\t\t`template: t:1:7: executing \"t\" at \u003cdoPanic\u003e: error calling doPanic: custom panic string`,\n\t\t},\n\t\t{\n\t\t\t\"direct method call panics\",\n\t\t\t\"{{.GetU}}\", (*T)(nil),\n\t\t\t`template: t:1:2: executing \"t\" at \u003c.GetU\u003e: error calling GetU: runtime error: invalid memory address or nil pointer dereference`,\n\t\t},\n\t\t{\n\t\t\t\"indirect method call panics\",\n\t\t\t\"{{call .GetU}}\", (*T)(nil),\n\t\t\t`template: t:1:7: executing \"t\" at \u003c.GetU\u003e: error calling GetU: runtime error: invalid memory address or nil pointer dereference`,\n\t\t},\n\t\t{\n\t\t\t\"func field call panics\",\n\t\t\t\"{{call .PanicFunc}}\", tVal,\n\t\t\t`template: t:1:2: executing \"t\" at \u003ccall .PanicFunc\u003e: error calling call: test panic`,\n\t\t},\n\t\t{\n\t\t\t\"method call on nil interface\",\n\t\t\t\"{{.NonEmptyInterfaceNil.Method0}}\", tVal,\n\t\t\t`template: t:1:23: executing \"t\" at \u003c.NonEmptyInterfaceNil.Method0\u003e: nil pointer evaluating template.I.Method0`,\n\t\t},\n\t}\n\tfor _, tc := range tests {\n\t\tb := new(bytes.Buffer)\n\t\ttmpl, err := New(\"t\").Funcs(funcs).Parse(tc.input)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"parse error: %s\", err)\n\t\t}\n\t\terr = tmpl.Execute(b, tc.data)\n\t\tif err == nil {\n\t\t\tt.Errorf(\"%s: expected error; got none\", tc.name)\n\t\t} else if !strings.Contains(err.Error(), tc.wantErr) {\n\t\t\tif *debug {\n\t\t\t\tfmt.Printf(\"%s: test execute error: %s\\n\", tc.name, err)\n\t\t\t}\n\t\t\tt.Errorf(\"%s: expected error:\\n%s\\ngot:\\n%s\", tc.name, tc.wantErr, err)\n\t\t}\n\t}\n}",
    "filename": "/usr/local/go/src/text/template/exec_test.go",
    "line": 1768
  },
  {
    "id": 227,
    "text": "func TestFunctionCheckDuringCall(t *testing.T) {\n\ttests := []struct {\n\t\tname    string\n\t\tinput   string\n\t\tdata    any\n\t\twantErr string\n\t}{{\n\t\tname:    \"call nothing\",\n\t\tinput:   `{{call}}`,\n\t\tdata:    tVal,\n\t\twantErr: \"wrong number of args for call: want at least 1 got 0\",\n\t},\n\t\t{\n\t\t\tname:    \"call non-function\",\n\t\t\tinput:   \"{{call .True}}\",\n\t\t\tdata:    tVal,\n\t\t\twantErr: \"error calling call: non-function .True of type bool\",\n\t\t},\n\t\t{\n\t\t\tname:    \"call func with wrong argument\",\n\t\t\tinput:   \"{{call .BinaryFunc 1}}\",\n\t\t\tdata:    tVal,\n\t\t\twantErr: \"error calling call: wrong number of args for .BinaryFunc: got 1 want 2\",\n\t\t},\n\t\t{\n\t\t\tname:    \"call variadic func with wrong argument\",\n\t\t\tinput:   `{{call .VariadicFuncInt}}`,\n\t\t\tdata:    tVal,\n\t\t\twantErr: \"error calling call: wrong number of args for .VariadicFuncInt: got 0 want at least 1\",\n\t\t},\n\t\t{\n\t\t\tname:    \"call too few return number func\",\n\t\t\tinput:   `{{call .TooFewReturnCountFunc}}`,\n\t\t\tdata:    tVal,\n\t\t\twantErr: \"error calling call: function .TooFewReturnCountFunc has 0 return values; should be 1 or 2\",\n\t\t},\n\t\t{\n\t\t\tname:    \"call too many return number func\",\n\t\t\tinput:   `{{call .TooManyReturnCountFunc}}`,\n\t\t\tdata:    tVal,\n\t\t\twantErr: \"error calling call: function .TooManyReturnCountFunc has 3 return values; should be 1 or 2\",\n\t\t},\n\t\t{\n\t\t\tname:    \"call invalid return type func\",\n\t\t\tinput:   `{{call .InvalidReturnTypeFunc}}`,\n\t\t\tdata:    tVal,\n\t\t\twantErr: \"error calling call: invalid function signature for .InvalidReturnTypeFunc: second return value should be error; is bool\",\n\t\t},\n\t\t{\n\t\t\tname:    \"call pipeline\",\n\t\t\tinput:   `{{call (len \"test\")}}`,\n\t\t\tdata:    nil,\n\t\t\twantErr: \"error calling call: non-function len \\\"test\\\" of type int\",\n\t\t},\n\t}\n\n\tfor _, tc := range tests {\n\t\tb := new(bytes.Buffer)\n\t\ttmpl, err := New(\"t\").Parse(tc.input)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"parse error: %s\", err)\n\t\t}\n\t\terr = tmpl.Execute(b, tc.data)\n\t\tif err == nil {\n\t\t\tt.Errorf(\"%s: expected error; got none\", tc.name)\n\t\t} else if tc.wantErr == \"\" || !strings.Contains(err.Error(), tc.wantErr) {\n\t\t\tif *debug {\n\t\t\t\tfmt.Printf(\"%s: test execute error: %s\\n\", tc.name, err)\n\t\t\t}\n\t\t\tt.Errorf(\"%s: expected error:\\n%s\\ngot:\\n%s\", tc.name, tc.wantErr, err)\n\t\t}\n\t}\n}",
    "filename": "/usr/local/go/src/text/template/exec_test.go",
    "line": 1829
  },
  {
    "id": 228,
    "text": "func TestIssue31810(t *testing.T) {\n\t// A simple value with no arguments is fine.\n\tvar b strings.Builder\n\tconst text = \"{{ (.)  }}\"\n\ttmpl, err := New(\"\").Parse(text)\n\tif err != nil {\n\t\tt.Error(err)\n\t}\n\terr = tmpl.Execute(\u0026b, \"result\")\n\tif err != nil {\n\t\tt.Error(err)\n\t}\n\tif b.String() != \"result\" {\n\t\tt.Errorf(\"%s got %q, expected %q\", text, b.String(), \"result\")\n\t}\n\n\t// Even a plain function fails - need to use call.\n\tf := func() string { return \"result\" }\n\tb.Reset()\n\terr = tmpl.Execute(\u0026b, f)\n\tif err == nil {\n\t\tt.Error(\"expected error with no call, got none\")\n\t}\n\n\t// Works if the function is explicitly called.\n\tconst textCall = \"{{ (call .)  }}\"\n\ttmpl, err = New(\"\").Parse(textCall)\n\tb.Reset()\n\terr = tmpl.Execute(\u0026b, f)\n\tif err != nil {\n\t\tt.Error(err)\n\t}\n\tif b.String() != \"result\" {\n\t\tt.Errorf(\"%s got %q, expected %q\", textCall, b.String(), \"result\")\n\t}\n}",
    "filename": "/usr/local/go/src/text/template/exec_test.go",
    "line": 1904
  },
  {
    "id": 229,
    "text": "func TestIssue43065(t *testing.T) {\n\tvar b bytes.Buffer\n\ttmp := Must(New(\"\").Parse(`{{range .}}{{end}}`))\n\tch := make(chan\u003c- int)\n\terr := tmp.Execute(\u0026b, ch)\n\tif err == nil {\n\t\tt.Error(\"expected err got nil\")\n\t} else if !strings.Contains(err.Error(), \"range over send-only channel\") {\n\t\tt.Errorf(\"%s\", err)\n\t}\n}",
    "filename": "/usr/local/go/src/text/template/exec_test.go",
    "line": 1942
  },
  {
    "id": 230,
    "text": "func TestIssue39807(t *testing.T) {\n\tvar wg sync.WaitGroup\n\n\ttplFoo, err := New(\"foo\").Parse(`{{ template \"bar\" . }}`)\n\tif err != nil {\n\t\tt.Error(err)\n\t}\n\n\ttplBar, err := New(\"bar\").Parse(\"bar\")\n\tif err != nil {\n\t\tt.Error(err)\n\t}\n\n\tgofuncs := 10\n\tnumTemplates := 10\n\n\tfor i := 1; i \u003c= gofuncs; i++ {\n\t\twg.Add(1)\n\t\tgo func() {\n\t\t\tdefer wg.Done()\n\t\t\tfor j := 0; j \u003c numTemplates; j++ {\n\t\t\t\t_, err := tplFoo.AddParseTree(tplBar.Name(), tplBar.Tree)\n\t\t\t\tif err != nil {\n\t\t\t\t\tt.Error(err)\n\t\t\t\t}\n\t\t\t\terr = tplFoo.Execute(io.Discard, nil)\n\t\t\t\tif err != nil {\n\t\t\t\t\tt.Error(err)\n\t\t\t\t}\n\t\t\t}\n\t\t}()\n\t}\n\n\twg.Wait()\n}",
    "filename": "/usr/local/go/src/text/template/exec_test.go",
    "line": 1955
  },
  {
    "id": 231,
    "text": "func TestIssue48215(t *testing.T) {\n\ttype A struct {\n\t\tS string\n\t}\n\ttype B struct {\n\t\t*A\n\t}\n\ttmpl, err := New(\"\").Parse(`{{ .S }}`)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\terr = tmpl.Execute(io.Discard, B{})\n\t// We expect an error, not a panic.\n\tif err == nil {\n\t\tt.Fatal(\"did not get error for nil embedded struct\")\n\t}\n\tif !strings.Contains(err.Error(), \"reflect: indirection through nil pointer to embedded struct field A\") {\n\t\tt.Fatal(err)\n\t}\n}",
    "filename": "/usr/local/go/src/text/template/exec_test.go",
    "line": 1993
  },
  {
    "id": 232,
    "text": "func builtins() FuncMap {\n\treturn FuncMap{\n\t\t\"and\":      and,\n\t\t\"call\":     emptyCall,\n\t\t\"html\":     HTMLEscaper,\n\t\t\"index\":    index,\n\t\t\"slice\":    slice,\n\t\t\"js\":       JSEscaper,\n\t\t\"len\":      length,\n\t\t\"not\":      not,\n\t\t\"or\":       or,\n\t\t\"print\":    fmt.Sprint,\n\t\t\"printf\":   fmt.Sprintf,\n\t\t\"println\":  fmt.Sprintln,\n\t\t\"urlquery\": URLQueryEscaper,\n\n\t\t// Comparisons\n\t\t\"eq\": eq, // ==\n\t\t\"ge\": ge, // \u003e=\n\t\t\"gt\": gt, // \u003e\n\t\t\"le\": le, // \u003c=\n\t\t\"lt\": lt, // \u003c\n\t\t\"ne\": ne, // !=\n\t}\n}",
    "filename": "/usr/local/go/src/text/template/funcs.go",
    "line": 39
  },
  {
    "id": 233,
    "text": "func builtinFuncs() map[string]reflect.Value {\n\tbuiltinFuncsOnce.Do(func() {\n\t\tbuiltinFuncsOnce.v = createValueFuncs(builtins())\n\t})\n\treturn builtinFuncsOnce.v\n}",
    "filename": "/usr/local/go/src/text/template/funcs.go",
    "line": 72
  },
  {
    "id": 234,
    "text": "func createValueFuncs(funcMap FuncMap) map[string]reflect.Value {\n\tm := make(map[string]reflect.Value)\n\taddValueFuncs(m, funcMap)\n\treturn m\n}",
    "filename": "/usr/local/go/src/text/template/funcs.go",
    "line": 80
  },
  {
    "id": 235,
    "text": "func addValueFuncs(out map[string]reflect.Value, in FuncMap) {\n\tfor name, fn := range in {\n\t\tif !goodName(name) {\n\t\t\tpanic(fmt.Errorf(\"function name %q is not a valid identifier\", name))\n\t\t}\n\t\tv := reflect.ValueOf(fn)\n\t\tif v.Kind() != reflect.Func {\n\t\t\tpanic(\"value for \" + name + \" not a function\")\n\t\t}\n\t\tif err := goodFunc(name, v.Type()); err != nil {\n\t\t\tpanic(err)\n\t\t}\n\t\tout[name] = v\n\t}\n}",
    "filename": "/usr/local/go/src/text/template/funcs.go",
    "line": 87
  },
  {
    "id": 236,
    "text": "func addFuncs(out, in FuncMap) {\n\tfor name, fn := range in {\n\t\tout[name] = fn\n\t}\n}",
    "filename": "/usr/local/go/src/text/template/funcs.go",
    "line": 105
  },
  {
    "id": 237,
    "text": "func goodFunc(name string, typ reflect.Type) error {\n\t// We allow functions with 1 result or 2 results where the second is an error.\n\tswitch numOut := typ.NumOut(); {\n\tcase numOut == 1:\n\t\treturn nil\n\tcase numOut == 2 \u0026\u0026 typ.Out(1) == errorType:\n\t\treturn nil\n\tcase numOut == 2:\n\t\treturn fmt.Errorf(\"invalid function signature for %s: second return value should be error; is %s\", name, typ.Out(1))\n\tdefault:\n\t\treturn fmt.Errorf(\"function %s has %d return values; should be 1 or 2\", name, typ.NumOut())\n\t}\n}",
    "filename": "/usr/local/go/src/text/template/funcs.go",
    "line": 112
  },
  {
    "id": 238,
    "text": "func goodName(name string) bool {\n\tif name == \"\" {\n\t\treturn false\n\t}\n\tfor i, r := range name {\n\t\tswitch {\n\t\tcase r == '_':\n\t\tcase i == 0 \u0026\u0026 !unicode.IsLetter(r):\n\t\t\treturn false\n\t\tcase !unicode.IsLetter(r) \u0026\u0026 !unicode.IsDigit(r):\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}",
    "filename": "/usr/local/go/src/text/template/funcs.go",
    "line": 127
  },
  {
    "id": 239,
    "text": "func findFunction(name string, tmpl *Template) (v reflect.Value, isBuiltin, ok bool) {\n\tif tmpl != nil \u0026\u0026 tmpl.common != nil {\n\t\ttmpl.muFuncs.RLock()\n\t\tdefer tmpl.muFuncs.RUnlock()\n\t\tif fn := tmpl.execFuncs[name]; fn.IsValid() {\n\t\t\treturn fn, false, true\n\t\t}\n\t}\n\tif fn := builtinFuncs()[name]; fn.IsValid() {\n\t\treturn fn, true, true\n\t}\n\treturn reflect.Value{}, false, false\n}",
    "filename": "/usr/local/go/src/text/template/funcs.go",
    "line": 144
  },
  {
    "id": 240,
    "text": "func prepareArg(value reflect.Value, argType reflect.Type) (reflect.Value, error) {\n\tif !value.IsValid() {\n\t\tif !canBeNil(argType) {\n\t\t\treturn reflect.Value{}, fmt.Errorf(\"value is nil; should be of type %s\", argType)\n\t\t}\n\t\tvalue = reflect.Zero(argType)\n\t}\n\tif value.Type().AssignableTo(argType) {\n\t\treturn value, nil\n\t}\n\tif intLike(value.Kind()) \u0026\u0026 intLike(argType.Kind()) \u0026\u0026 value.Type().ConvertibleTo(argType) {\n\t\tvalue = value.Convert(argType)\n\t\treturn value, nil\n\t}\n\treturn reflect.Value{}, fmt.Errorf(\"value has type %s; should be %s\", value.Type(), argType)\n}",
    "filename": "/usr/local/go/src/text/template/funcs.go",
    "line": 160
  },
  {
    "id": 241,
    "text": "func intLike(typ reflect.Kind) bool {\n\tswitch typ {\n\tcase reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:\n\t\treturn true\n\tcase reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64, reflect.Uintptr:\n\t\treturn true\n\t}\n\treturn false\n}",
    "filename": "/usr/local/go/src/text/template/funcs.go",
    "line": 177
  },
  {
    "id": 242,
    "text": "func indexArg(index reflect.Value, cap int) (int, error) {\n\tvar x int64\n\tswitch index.Kind() {\n\tcase reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:\n\t\tx = index.Int()\n\tcase reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64, reflect.Uintptr:\n\t\tx = int64(index.Uint())\n\tcase reflect.Invalid:\n\t\treturn 0, fmt.Errorf(\"cannot index slice/array with nil\")\n\tdefault:\n\t\treturn 0, fmt.Errorf(\"cannot index slice/array with type %s\", index.Type())\n\t}\n\tif x \u003c 0 || int(x) \u003c 0 || int(x) \u003e cap {\n\t\treturn 0, fmt.Errorf(\"index out of range: %d\", x)\n\t}\n\treturn int(x), nil\n}",
    "filename": "/usr/local/go/src/text/template/funcs.go",
    "line": 188
  },
  {
    "id": 243,
    "text": "func index(item reflect.Value, indexes ...reflect.Value) (reflect.Value, error) {\n\titem = indirectInterface(item)\n\tif !item.IsValid() {\n\t\treturn reflect.Value{}, fmt.Errorf(\"index of untyped nil\")\n\t}\n\tfor _, index := range indexes {\n\t\tindex = indirectInterface(index)\n\t\tvar isNil bool\n\t\tif item, isNil = indirect(item); isNil {\n\t\t\treturn reflect.Value{}, fmt.Errorf(\"index of nil pointer\")\n\t\t}\n\t\tswitch item.Kind() {\n\t\tcase reflect.Array, reflect.Slice, reflect.String:\n\t\t\tx, err := indexArg(index, item.Len())\n\t\t\tif err != nil {\n\t\t\t\treturn reflect.Value{}, err\n\t\t\t}\n\t\t\titem = item.Index(x)\n\t\tcase reflect.Map:\n\t\t\tindex, err := prepareArg(index, item.Type().Key())\n\t\t\tif err != nil {\n\t\t\t\treturn reflect.Value{}, err\n\t\t\t}\n\t\t\tif x := item.MapIndex(index); x.IsValid() {\n\t\t\t\titem = x\n\t\t\t} else {\n\t\t\t\titem = reflect.Zero(item.Type().Elem())\n\t\t\t}\n\t\tcase reflect.Invalid:\n\t\t\t// the loop holds invariant: item.IsValid()\n\t\t\tpanic(\"unreachable\")\n\t\tdefault:\n\t\t\treturn reflect.Value{}, fmt.Errorf(\"can't index item of type %s\", item.Type())\n\t\t}\n\t}\n\treturn item, nil\n}",
    "filename": "/usr/local/go/src/text/template/funcs.go",
    "line": 211
  },
  {
    "id": 244,
    "text": "func slice(item reflect.Value, indexes ...reflect.Value) (reflect.Value, error) {\n\titem = indirectInterface(item)\n\tif !item.IsValid() {\n\t\treturn reflect.Value{}, fmt.Errorf(\"slice of untyped nil\")\n\t}\n\tif len(indexes) \u003e 3 {\n\t\treturn reflect.Value{}, fmt.Errorf(\"too many slice indexes: %d\", len(indexes))\n\t}\n\tvar cap int\n\tswitch item.Kind() {\n\tcase reflect.String:\n\t\tif len(indexes) == 3 {\n\t\t\treturn reflect.Value{}, fmt.Errorf(\"cannot 3-index slice a string\")\n\t\t}\n\t\tcap = item.Len()\n\tcase reflect.Array, reflect.Slice:\n\t\tcap = item.Cap()\n\tdefault:\n\t\treturn reflect.Value{}, fmt.Errorf(\"can't slice item of type %s\", item.Type())\n\t}\n\t// set default values for cases item[:], item[i:].\n\tidx := [3]int{0, item.Len()}\n\tfor i, index := range indexes {\n\t\tx, err := indexArg(index, cap)\n\t\tif err != nil {\n\t\t\treturn reflect.Value{}, err\n\t\t}\n\t\tidx[i] = x\n\t}\n\t// given item[i:j], make sure i \u003c= j.\n\tif idx[0] \u003e idx[1] {\n\t\treturn reflect.Value{}, fmt.Errorf(\"invalid slice index: %d \u003e %d\", idx[0], idx[1])\n\t}\n\tif len(indexes) \u003c 3 {\n\t\treturn item.Slice(idx[0], idx[1]), nil\n\t}\n\t// given item[i:j:k], make sure i \u003c= j \u003c= k.\n\tif idx[1] \u003e idx[2] {\n\t\treturn reflect.Value{}, fmt.Errorf(\"invalid slice index: %d \u003e %d\", idx[1], idx[2])\n\t}\n\treturn item.Slice3(idx[0], idx[1], idx[2]), nil\n}",
    "filename": "/usr/local/go/src/text/template/funcs.go",
    "line": 255
  },
  {
    "id": 245,
    "text": "func length(item reflect.Value) (int, error) {\n\titem, isNil := indirect(item)\n\tif isNil {\n\t\treturn 0, fmt.Errorf(\"len of nil pointer\")\n\t}\n\tswitch item.Kind() {\n\tcase reflect.Array, reflect.Chan, reflect.Map, reflect.Slice, reflect.String:\n\t\treturn item.Len(), nil\n\t}\n\treturn 0, fmt.Errorf(\"len of type %s\", item.Type())\n}",
    "filename": "/usr/local/go/src/text/template/funcs.go",
    "line": 301
  },
  {
    "id": 246,
    "text": "func emptyCall(fn reflect.Value, args ...reflect.Value) reflect.Value {\n\tpanic(\"unreachable\") // implemented as a special case in evalCall\n}",
    "filename": "/usr/local/go/src/text/template/funcs.go",
    "line": 315
  },
  {
    "id": 247,
    "text": "func call(name string, fn reflect.Value, args ...reflect.Value) (reflect.Value, error) {\n\tfn = indirectInterface(fn)\n\tif !fn.IsValid() {\n\t\treturn reflect.Value{}, fmt.Errorf(\"call of nil\")\n\t}\n\ttyp := fn.Type()\n\tif typ.Kind() != reflect.Func {\n\t\treturn reflect.Value{}, fmt.Errorf(\"non-function %s of type %s\", name, typ)\n\t}\n\n\tif err := goodFunc(name, typ); err != nil {\n\t\treturn reflect.Value{}, err\n\t}\n\tnumIn := typ.NumIn()\n\tvar dddType reflect.Type\n\tif typ.IsVariadic() {\n\t\tif len(args) \u003c numIn-1 {\n\t\t\treturn reflect.Value{}, fmt.Errorf(\"wrong number of args for %s: got %d want at least %d\", name, len(args), numIn-1)\n\t\t}\n\t\tdddType = typ.In(numIn - 1).Elem()\n\t} else {\n\t\tif len(args) != numIn {\n\t\t\treturn reflect.Value{}, fmt.Errorf(\"wrong number of args for %s: got %d want %d\", name, len(args), numIn)\n\t\t}\n\t}\n\targv := make([]reflect.Value, len(args))\n\tfor i, arg := range args {\n\t\targ = indirectInterface(arg)\n\t\t// Compute the expected type. Clumsy because of variadics.\n\t\targType := dddType\n\t\tif !typ.IsVariadic() || i \u003c numIn-1 {\n\t\t\targType = typ.In(i)\n\t\t}\n\n\t\tvar err error\n\t\tif argv[i], err = prepareArg(arg, argType); err != nil {\n\t\t\treturn reflect.Value{}, fmt.Errorf(\"arg %d: %w\", i, err)\n\t\t}\n\t}\n\treturn safeCall(fn, argv)\n}",
    "filename": "/usr/local/go/src/text/template/funcs.go",
    "line": 321
  },
  {
    "id": 248,
    "text": "func safeCall(fun reflect.Value, args []reflect.Value) (val reflect.Value, err error) {\n\tdefer func() {\n\t\tif r := recover(); r != nil {\n\t\t\tif e, ok := r.(error); ok {\n\t\t\t\terr = e\n\t\t\t} else {\n\t\t\t\terr = fmt.Errorf(\"%v\", r)\n\t\t\t}\n\t\t}\n\t}()\n\tret := fun.Call(args)\n\tif len(ret) == 2 \u0026\u0026 !ret[1].IsNil() {\n\t\treturn ret[0], ret[1].Interface().(error)\n\t}\n\treturn ret[0], nil\n}",
    "filename": "/usr/local/go/src/text/template/funcs.go",
    "line": 365
  },
  {
    "id": 249,
    "text": "func truth(arg reflect.Value) bool {\n\tt, _ := isTrue(indirectInterface(arg))\n\treturn t\n}",
    "filename": "/usr/local/go/src/text/template/funcs.go",
    "line": 384
  },
  {
    "id": 250,
    "text": "func and(arg0 reflect.Value, args ...reflect.Value) reflect.Value {\n\tpanic(\"unreachable\") // implemented as a special case in evalCall\n}",
    "filename": "/usr/local/go/src/text/template/funcs.go",
    "line": 391
  },
  {
    "id": 251,
    "text": "func or(arg0 reflect.Value, args ...reflect.Value) reflect.Value {\n\tpanic(\"unreachable\") // implemented as a special case in evalCall\n}",
    "filename": "/usr/local/go/src/text/template/funcs.go",
    "line": 397
  },
  {
    "id": 252,
    "text": "func not(arg reflect.Value) bool {\n\treturn !truth(arg)\n}",
    "filename": "/usr/local/go/src/text/template/funcs.go",
    "line": 402
  },
  {
    "id": 253,
    "text": "func basicKind(v reflect.Value) (kind, error) {\n\tswitch v.Kind() {\n\tcase reflect.Bool:\n\t\treturn boolKind, nil\n\tcase reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:\n\t\treturn intKind, nil\n\tcase reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64, reflect.Uintptr:\n\t\treturn uintKind, nil\n\tcase reflect.Float32, reflect.Float64:\n\t\treturn floatKind, nil\n\tcase reflect.Complex64, reflect.Complex128:\n\t\treturn complexKind, nil\n\tcase reflect.String:\n\t\treturn stringKind, nil\n\t}\n\treturn invalidKind, errBadComparisonType\n}",
    "filename": "/usr/local/go/src/text/template/funcs.go",
    "line": 427
  },
  {
    "id": 254,
    "text": "func isNil(v reflect.Value) bool {\n\tif !v.IsValid() {\n\t\treturn true\n\t}\n\tswitch v.Kind() {\n\tcase reflect.Chan, reflect.Func, reflect.Interface, reflect.Map, reflect.Pointer, reflect.Slice:\n\t\treturn v.IsNil()\n\t}\n\treturn false\n}",
    "filename": "/usr/local/go/src/text/template/funcs.go",
    "line": 446
  },
  {
    "id": 255,
    "text": "func canCompare(v1, v2 reflect.Value) bool {\n\tk1 := v1.Kind()\n\tk2 := v2.Kind()\n\tif k1 == k2 {\n\t\treturn true\n\t}\n\t// We know the type can be compared to nil.\n\treturn k1 == reflect.Invalid || k2 == reflect.Invalid\n}",
    "filename": "/usr/local/go/src/text/template/funcs.go",
    "line": 459
  },
  {
    "id": 256,
    "text": "func eq(arg1 reflect.Value, arg2 ...reflect.Value) (bool, error) {\n\targ1 = indirectInterface(arg1)\n\tif len(arg2) == 0 {\n\t\treturn false, errNoComparison\n\t}\n\tk1, _ := basicKind(arg1)\n\tfor _, arg := range arg2 {\n\t\targ = indirectInterface(arg)\n\t\tk2, _ := basicKind(arg)\n\t\ttruth := false\n\t\tif k1 != k2 {\n\t\t\t// Special case: Can compare integer values regardless of type's sign.\n\t\t\tswitch {\n\t\t\tcase k1 == intKind \u0026\u0026 k2 == uintKind:\n\t\t\t\ttruth = arg1.Int() \u003e= 0 \u0026\u0026 uint64(arg1.Int()) == arg.Uint()\n\t\t\tcase k1 == uintKind \u0026\u0026 k2 == intKind:\n\t\t\t\ttruth = arg.Int() \u003e= 0 \u0026\u0026 arg1.Uint() == uint64(arg.Int())\n\t\t\tdefault:\n\t\t\t\tif arg1.IsValid() \u0026\u0026 arg.IsValid() {\n\t\t\t\t\treturn false, fmt.Errorf(\"incompatible types for comparison: %v and %v\", arg1.Type(), arg.Type())\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tswitch k1 {\n\t\t\tcase boolKind:\n\t\t\t\ttruth = arg1.Bool() == arg.Bool()\n\t\t\tcase complexKind:\n\t\t\t\ttruth = arg1.Complex() == arg.Complex()\n\t\t\tcase floatKind:\n\t\t\t\ttruth = arg1.Float() == arg.Float()\n\t\t\tcase intKind:\n\t\t\t\ttruth = arg1.Int() == arg.Int()\n\t\t\tcase stringKind:\n\t\t\t\ttruth = arg1.String() == arg.String()\n\t\t\tcase uintKind:\n\t\t\t\ttruth = arg1.Uint() == arg.Uint()\n\t\t\tdefault:\n\t\t\t\tif !canCompare(arg1, arg) {\n\t\t\t\t\treturn false, fmt.Errorf(\"non-comparable types %s: %v, %s: %v\", arg1, arg1.Type(), arg.Type(), arg)\n\t\t\t\t}\n\t\t\t\tif isNil(arg1) || isNil(arg) {\n\t\t\t\t\ttruth = isNil(arg) == isNil(arg1)\n\t\t\t\t} else {\n\t\t\t\t\tif !arg.Type().Comparable() {\n\t\t\t\t\t\treturn false, fmt.Errorf(\"non-comparable type %s: %v\", arg, arg.Type())\n\t\t\t\t\t}\n\t\t\t\t\ttruth = arg1.Interface() == arg.Interface()\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif truth {\n\t\t\treturn true, nil\n\t\t}\n\t}\n\treturn false, nil\n}",
    "filename": "/usr/local/go/src/text/template/funcs.go",
    "line": 470
  },
  {
    "id": 257,
    "text": "func ne(arg1, arg2 reflect.Value) (bool, error) {\n\t// != is the inverse of ==.\n\tequal, err := eq(arg1, arg2)\n\treturn !equal, err\n}",
    "filename": "/usr/local/go/src/text/template/funcs.go",
    "line": 528
  },
  {
    "id": 258,
    "text": "func lt(arg1, arg2 reflect.Value) (bool, error) {\n\targ1 = indirectInterface(arg1)\n\tk1, err := basicKind(arg1)\n\tif err != nil {\n\t\treturn false, err\n\t}\n\targ2 = indirectInterface(arg2)\n\tk2, err := basicKind(arg2)\n\tif err != nil {\n\t\treturn false, err\n\t}\n\ttruth := false\n\tif k1 != k2 {\n\t\t// Special case: Can compare integer values regardless of type's sign.\n\t\tswitch {\n\t\tcase k1 == intKind \u0026\u0026 k2 == uintKind:\n\t\t\ttruth = arg1.Int() \u003c 0 || uint64(arg1.Int()) \u003c arg2.Uint()\n\t\tcase k1 == uintKind \u0026\u0026 k2 == intKind:\n\t\t\ttruth = arg2.Int() \u003e= 0 \u0026\u0026 arg1.Uint() \u003c uint64(arg2.Int())\n\t\tdefault:\n\t\t\treturn false, fmt.Errorf(\"incompatible types for comparison: %v and %v\", arg1.Type(), arg2.Type())\n\t\t}\n\t} else {\n\t\tswitch k1 {\n\t\tcase boolKind, complexKind:\n\t\t\treturn false, errBadComparisonType\n\t\tcase floatKind:\n\t\t\ttruth = arg1.Float() \u003c arg2.Float()\n\t\tcase intKind:\n\t\t\ttruth = arg1.Int() \u003c arg2.Int()\n\t\tcase stringKind:\n\t\t\ttruth = arg1.String() \u003c arg2.String()\n\t\tcase uintKind:\n\t\t\ttruth = arg1.Uint() \u003c arg2.Uint()\n\t\tdefault:\n\t\t\tpanic(\"invalid kind\")\n\t\t}\n\t}\n\treturn truth, nil\n}",
    "filename": "/usr/local/go/src/text/template/funcs.go",
    "line": 535
  },
  {
    "id": 259,
    "text": "func le(arg1, arg2 reflect.Value) (bool, error) {\n\t// \u003c= is \u003c or ==.\n\tlessThan, err := lt(arg1, arg2)\n\tif lessThan || err != nil {\n\t\treturn lessThan, err\n\t}\n\treturn eq(arg1, arg2)\n}",
    "filename": "/usr/local/go/src/text/template/funcs.go",
    "line": 577
  },
  {
    "id": 260,
    "text": "func gt(arg1, arg2 reflect.Value) (bool, error) {\n\t// \u003e is the inverse of \u003c=.\n\tlessOrEqual, err := le(arg1, arg2)\n\tif err != nil {\n\t\treturn false, err\n\t}\n\treturn !lessOrEqual, nil\n}",
    "filename": "/usr/local/go/src/text/template/funcs.go",
    "line": 587
  },
  {
    "id": 261,
    "text": "func ge(arg1, arg2 reflect.Value) (bool, error) {\n\t// \u003e= is the inverse of \u003c.\n\tlessThan, err := lt(arg1, arg2)\n\tif err != nil {\n\t\treturn false, err\n\t}\n\treturn !lessThan, nil\n}",
    "filename": "/usr/local/go/src/text/template/funcs.go",
    "line": 597
  },
  {
    "id": 262,
    "text": "func HTMLEscape(w io.Writer, b []byte) {\n\tlast := 0\n\tfor i, c := range b {\n\t\tvar html []byte\n\t\tswitch c {\n\t\tcase '\\000':\n\t\t\thtml = htmlNull\n\t\tcase '\"':\n\t\t\thtml = htmlQuot\n\t\tcase '\\'':\n\t\t\thtml = htmlApos\n\t\tcase '\u0026':\n\t\t\thtml = htmlAmp\n\t\tcase '\u003c':\n\t\t\thtml = htmlLt\n\t\tcase '\u003e':\n\t\t\thtml = htmlGt\n\t\tdefault:\n\t\t\tcontinue\n\t\t}\n\t\tw.Write(b[last:i])\n\t\tw.Write(html)\n\t\tlast = i + 1\n\t}\n\tw.Write(b[last:])\n}",
    "filename": "/usr/local/go/src/text/template/funcs.go",
    "line": 618
  },
  {
    "id": 263,
    "text": "func HTMLEscapeString(s string) string {\n\t// Avoid allocation if we can.\n\tif !strings.ContainsAny(s, \"'\\\"\u0026\u003c\u003e\\000\") {\n\t\treturn s\n\t}\n\tvar b strings.Builder\n\tHTMLEscape(\u0026b, []byte(s))\n\treturn b.String()\n}",
    "filename": "/usr/local/go/src/text/template/funcs.go",
    "line": 646
  },
  {
    "id": 264,
    "text": "func HTMLEscaper(args ...any) string {\n\treturn HTMLEscapeString(evalArgs(args))\n}",
    "filename": "/usr/local/go/src/text/template/funcs.go",
    "line": 658
  },
  {
    "id": 265,
    "text": "func JSEscape(w io.Writer, b []byte) {\n\tlast := 0\n\tfor i := 0; i \u003c len(b); i++ {\n\t\tc := b[i]\n\n\t\tif !jsIsSpecial(rune(c)) {\n\t\t\t// fast path: nothing to do\n\t\t\tcontinue\n\t\t}\n\t\tw.Write(b[last:i])\n\n\t\tif c \u003c utf8.RuneSelf {\n\t\t\t// Quotes, slashes and angle brackets get quoted.\n\t\t\t// Control characters get written as \\u00XX.\n\t\t\tswitch c {\n\t\t\tcase '\\\\':\n\t\t\t\tw.Write(jsBackslash)\n\t\t\tcase '\\'':\n\t\t\t\tw.Write(jsApos)\n\t\t\tcase '\"':\n\t\t\t\tw.Write(jsQuot)\n\t\t\tcase '\u003c':\n\t\t\t\tw.Write(jsLt)\n\t\t\tcase '\u003e':\n\t\t\t\tw.Write(jsGt)\n\t\t\tcase '\u0026':\n\t\t\t\tw.Write(jsAmp)\n\t\t\tcase '=':\n\t\t\t\tw.Write(jsEq)\n\t\t\tdefault:\n\t\t\t\tw.Write(jsLowUni)\n\t\t\t\tt, b := c\u003e\u003e4, c\u00260x0f\n\t\t\t\tw.Write(hex[t : t+1])\n\t\t\t\tw.Write(hex[b : b+1])\n\t\t\t}\n\t\t} else {\n\t\t\t// Unicode rune.\n\t\t\tr, size := utf8.DecodeRune(b[i:])\n\t\t\tif unicode.IsPrint(r) {\n\t\t\t\tw.Write(b[i : i+size])\n\t\t\t} else {\n\t\t\t\tfmt.Fprintf(w, \"\\\\u%04X\", r)\n\t\t\t}\n\t\t\ti += size - 1\n\t\t}\n\t\tlast = i + 1\n\t}\n\tw.Write(b[last:])\n}",
    "filename": "/usr/local/go/src/text/template/funcs.go",
    "line": 678
  },
  {
    "id": 266,
    "text": "func JSEscapeString(s string) string {\n\t// Avoid allocation if we can.\n\tif strings.IndexFunc(s, jsIsSpecial) \u003c 0 {\n\t\treturn s\n\t}\n\tvar b strings.Builder\n\tJSEscape(\u0026b, []byte(s))\n\treturn b.String()\n}",
    "filename": "/usr/local/go/src/text/template/funcs.go",
    "line": 729
  },
  {
    "id": 267,
    "text": "func jsIsSpecial(r rune) bool {\n\tswitch r {\n\tcase '\\\\', '\\'', '\"', '\u003c', '\u003e', '\u0026', '=':\n\t\treturn true\n\t}\n\treturn r \u003c ' ' || utf8.RuneSelf \u003c= r\n}",
    "filename": "/usr/local/go/src/text/template/funcs.go",
    "line": 739
  },
  {
    "id": 268,
    "text": "func JSEscaper(args ...any) string {\n\treturn JSEscapeString(evalArgs(args))\n}",
    "filename": "/usr/local/go/src/text/template/funcs.go",
    "line": 749
  },
  {
    "id": 269,
    "text": "func URLQueryEscaper(args ...any) string {\n\treturn url.QueryEscape(evalArgs(args))\n}",
    "filename": "/usr/local/go/src/text/template/funcs.go",
    "line": 755
  },
  {
    "id": 270,
    "text": "func evalArgs(args []any) string {\n\tok := false\n\tvar s string\n\t// Fast path for simple common case.\n\tif len(args) == 1 {\n\t\ts, ok = args[0].(string)\n\t}\n\tif !ok {\n\t\tfor i, arg := range args {\n\t\t\ta, ok := printableValue(reflect.ValueOf(arg))\n\t\t\tif ok {\n\t\t\t\targs[i] = a\n\t\t\t} // else let fmt do its thing\n\t\t}\n\t\ts = fmt.Sprint(args...)\n\t}\n\treturn s\n}",
    "filename": "/usr/local/go/src/text/template/funcs.go",
    "line": 766
  },
  {
    "id": 271,
    "text": "func Must(t *Template, err error) *Template {\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\treturn t\n}",
    "filename": "/usr/local/go/src/text/template/helper.go",
    "line": 24
  },
  {
    "id": 272,
    "text": "func ParseFiles(filenames ...string) (*Template, error) {\n\treturn parseFiles(nil, readFileOS, filenames...)\n}",
    "filename": "/usr/local/go/src/text/template/helper.go",
    "line": 40
  },
  {
    "id": 273,
    "text": "func (t *Template) ParseFiles(filenames ...string) (*Template, error) {\n\tt.init()\n\treturn parseFiles(t, readFileOS, filenames...)\n}",
    "filename": "/usr/local/go/src/text/template/helper.go",
    "line": 55
  },
  {
    "id": 274,
    "text": "func parseFiles(t *Template, readFile func(string) (string, []byte, error), filenames ...string) (*Template, error) {\n\tif len(filenames) == 0 {\n\t\t// Not really a problem, but be consistent.\n\t\treturn nil, fmt.Errorf(\"template: no files named in call to ParseFiles\")\n\t}\n\tfor _, filename := range filenames {\n\t\tname, b, err := readFile(filename)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\ts := string(b)\n\t\t// First template becomes return value if not already defined,\n\t\t// and we use that one for subsequent New calls to associate\n\t\t// all the templates together. Also, if this file has the same name\n\t\t// as t, this file becomes the contents of t, so\n\t\t//  t, err := New(name).Funcs(xxx).ParseFiles(name)\n\t\t// works. Otherwise we create a new template associated with t.\n\t\tvar tmpl *Template\n\t\tif t == nil {\n\t\t\tt = New(name)\n\t\t}\n\t\tif name == t.Name() {\n\t\t\ttmpl = t\n\t\t} else {\n\t\t\ttmpl = t.New(name)\n\t\t}\n\t\t_, err = tmpl.Parse(s)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\treturn t, nil\n}",
    "filename": "/usr/local/go/src/text/template/helper.go",
    "line": 62
  },
  {
    "id": 275,
    "text": "func ParseGlob(pattern string) (*Template, error) {\n\treturn parseGlob(nil, pattern)\n}",
    "filename": "/usr/local/go/src/text/template/helper.go",
    "line": 105
  },
  {
    "id": 276,
    "text": "func (t *Template) ParseGlob(pattern string) (*Template, error) {\n\tt.init()\n\treturn parseGlob(t, pattern)\n}",
    "filename": "/usr/local/go/src/text/template/helper.go",
    "line": 117
  },
  {
    "id": 277,
    "text": "func parseGlob(t *Template, pattern string) (*Template, error) {\n\tfilenames, err := filepath.Glob(pattern)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif len(filenames) == 0 {\n\t\treturn nil, fmt.Errorf(\"template: pattern matches no files: %#q\", pattern)\n\t}\n\treturn parseFiles(t, readFileOS, filenames...)\n}",
    "filename": "/usr/local/go/src/text/template/helper.go",
    "line": 123
  },
  {
    "id": 278,
    "text": "func ParseFS(fsys fs.FS, patterns ...string) (*Template, error) {\n\treturn parseFS(nil, fsys, patterns)\n}",
    "filename": "/usr/local/go/src/text/template/helper.go",
    "line": 138
  },
  {
    "id": 279,
    "text": "func (t *Template) ParseFS(fsys fs.FS, patterns ...string) (*Template, error) {\n\tt.init()\n\treturn parseFS(t, fsys, patterns)\n}",
    "filename": "/usr/local/go/src/text/template/helper.go",
    "line": 146
  },
  {
    "id": 280,
    "text": "func parseFS(t *Template, fsys fs.FS, patterns []string) (*Template, error) {\n\tvar filenames []string\n\tfor _, pattern := range patterns {\n\t\tlist, err := fs.Glob(fsys, pattern)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tif len(list) == 0 {\n\t\t\treturn nil, fmt.Errorf(\"template: pattern matches no files: %#q\", pattern)\n\t\t}\n\t\tfilenames = append(filenames, list...)\n\t}\n\treturn parseFiles(t, readFileFS(fsys), filenames...)\n}",
    "filename": "/usr/local/go/src/text/template/helper.go",
    "line": 151
  },
  {
    "id": 281,
    "text": "func readFileOS(file string) (name string, b []byte, err error) {\n\tname = filepath.Base(file)\n\tb, err = os.ReadFile(file)\n\treturn\n}",
    "filename": "/usr/local/go/src/text/template/helper.go",
    "line": 166
  },
  {
    "id": 282,
    "text": "func readFileFS(fsys fs.FS) func(string) (string, []byte, error) {\n\treturn func(file string) (name string, b []byte, err error) {\n\t\tname = path.Base(file)\n\t\tb, err = fs.ReadFile(fsys, file)\n\t\treturn\n\t}\n}",
    "filename": "/usr/local/go/src/text/template/helper.go",
    "line": 172
  },
  {
    "id": 283,
    "text": "func TestLinkerGC(t *testing.T) {\n\tif testing.Short() {\n\t\tt.Skip(\"skipping in short mode\")\n\t}\n\ttestenv.MustHaveGoBuild(t)\n\tconst prog = `package main\n\nimport (\n\t_ \"text/template\"\n)\n\ntype T struct{}\n\nfunc (t *T) Unused() { println(\"THIS SHOULD BE ELIMINATED\") }\nfunc (t *T) Used() {}\n\nvar sink *T\n\nfunc main() {\n\tvar t T\n\tsink = \u0026t\n\tt.Used()\n}\n`\n\ttd := t.TempDir()\n\n\tif err := os.WriteFile(filepath.Join(td, \"x.go\"), []byte(prog), 0644); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tcmd := exec.Command(testenv.GoToolPath(t), \"build\", \"-o\", \"x.exe\", \"x.go\")\n\tcmd.Dir = td\n\tif out, err := cmd.CombinedOutput(); err != nil {\n\t\tt.Fatalf(\"go build: %v, %s\", err, out)\n\t}\n\tslurp, err := os.ReadFile(filepath.Join(td, \"x.exe\"))\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif bytes.Contains(slurp, []byte(\"THIS SHOULD BE ELIMINATED\")) {\n\t\tt.Error(\"binary contains code that should be deadcode eliminated\")\n\t}\n}",
    "filename": "/usr/local/go/src/text/template/link_test.go",
    "line": 18
  },
  {
    "id": 284,
    "text": "func TestMultiParse(t *testing.T) {\n\tfor _, test := range multiParseTests {\n\t\ttemplate, err := New(\"root\").Parse(test.input)\n\t\tswitch {\n\t\tcase err == nil \u0026\u0026 !test.ok:\n\t\t\tt.Errorf(\"%q: expected error; got none\", test.name)\n\t\t\tcontinue\n\t\tcase err != nil \u0026\u0026 test.ok:\n\t\t\tt.Errorf(\"%q: unexpected error: %v\", test.name, err)\n\t\t\tcontinue\n\t\tcase err != nil \u0026\u0026 !test.ok:\n\t\t\t// expected error, got one\n\t\t\tif *debug {\n\t\t\t\tfmt.Printf(\"%s: %s\\n\\t%s\\n\", test.name, test.input, err)\n\t\t\t}\n\t\t\tcontinue\n\t\t}\n\t\tif template == nil {\n\t\t\tcontinue\n\t\t}\n\t\tif len(template.tmpl) != len(test.names)+1 { // +1 for root\n\t\t\tt.Errorf(\"%s: wrong number of templates; wanted %d got %d\", test.name, len(test.names), len(template.tmpl))\n\t\t\tcontinue\n\t\t}\n\t\tfor i, name := range test.names {\n\t\t\ttmpl, ok := template.tmpl[name]\n\t\t\tif !ok {\n\t\t\t\tt.Errorf(\"%s: can't find template %q\", test.name, name)\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tresult := tmpl.Root.String()\n\t\t\tif result != test.results[i] {\n\t\t\t\tt.Errorf(\"%s=(%q): got\\n\\t%v\\nexpected\\n\\t%v\", test.name, test.input, result, test.results[i])\n\t\t\t}\n\t\t}\n\t}\n}",
    "filename": "/usr/local/go/src/text/template/multi_test.go",
    "line": 49
  },
  {
    "id": 285,
    "text": "func TestMultiExecute(t *testing.T) {\n\t// Declare a couple of templates first.\n\ttemplate, err := New(\"root\").Parse(multiText1)\n\tif err != nil {\n\t\tt.Fatalf(\"parse error for 1: %s\", err)\n\t}\n\t_, err = template.Parse(multiText2)\n\tif err != nil {\n\t\tt.Fatalf(\"parse error for 2: %s\", err)\n\t}\n\ttestExecute(multiExecTests, template, t)\n}",
    "filename": "/usr/local/go/src/text/template/multi_test.go",
    "line": 114
  },
  {
    "id": 286,
    "text": "func TestParseFiles(t *testing.T) {\n\t_, err := ParseFiles(\"DOES NOT EXIST\")\n\tif err == nil {\n\t\tt.Error(\"expected error for non-existent file; got none\")\n\t}\n\ttemplate := New(\"root\")\n\t_, err = template.ParseFiles(\"testdata/file1.tmpl\", \"testdata/file2.tmpl\")\n\tif err != nil {\n\t\tt.Fatalf(\"error parsing files: %v\", err)\n\t}\n\ttestExecute(multiExecTests, template, t)\n}",
    "filename": "/usr/local/go/src/text/template/multi_test.go",
    "line": 127
  },
  {
    "id": 287,
    "text": "func TestParseGlob(t *testing.T) {\n\t_, err := ParseGlob(\"DOES NOT EXIST\")\n\tif err == nil {\n\t\tt.Error(\"expected error for non-existent file; got none\")\n\t}\n\t_, err = New(\"error\").ParseGlob(\"[x\")\n\tif err == nil {\n\t\tt.Error(\"expected error for bad pattern; got none\")\n\t}\n\ttemplate := New(\"root\")\n\t_, err = template.ParseGlob(\"testdata/file*.tmpl\")\n\tif err != nil {\n\t\tt.Fatalf(\"error parsing files: %v\", err)\n\t}\n\ttestExecute(multiExecTests, template, t)\n}",
    "filename": "/usr/local/go/src/text/template/multi_test.go",
    "line": 140
  },
  {
    "id": 288,
    "text": "func TestParseFS(t *testing.T) {\n\tfs := os.DirFS(\"testdata\")\n\n\t{\n\t\t_, err := ParseFS(fs, \"DOES NOT EXIST\")\n\t\tif err == nil {\n\t\t\tt.Error(\"expected error for non-existent file; got none\")\n\t\t}\n\t}\n\n\t{\n\t\ttemplate := New(\"root\")\n\t\t_, err := template.ParseFS(fs, \"file1.tmpl\", \"file2.tmpl\")\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"error parsing files: %v\", err)\n\t\t}\n\t\ttestExecute(multiExecTests, template, t)\n\t}\n\n\t{\n\t\ttemplate := New(\"root\")\n\t\t_, err := template.ParseFS(fs, \"file*.tmpl\")\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"error parsing files: %v\", err)\n\t\t}\n\t\ttestExecute(multiExecTests, template, t)\n\t}\n}",
    "filename": "/usr/local/go/src/text/template/multi_test.go",
    "line": 157
  },
  {
    "id": 289,
    "text": "func TestParseFilesWithData(t *testing.T) {\n\ttemplate, err := New(\"root\").ParseFiles(\"testdata/tmpl1.tmpl\", \"testdata/tmpl2.tmpl\")\n\tif err != nil {\n\t\tt.Fatalf(\"error parsing files: %v\", err)\n\t}\n\ttestExecute(templateFileExecTests, template, t)\n}",
    "filename": "/usr/local/go/src/text/template/multi_test.go",
    "line": 192
  },
  {
    "id": 290,
    "text": "func TestParseGlobWithData(t *testing.T) {\n\ttemplate, err := New(\"root\").ParseGlob(\"testdata/tmpl*.tmpl\")\n\tif err != nil {\n\t\tt.Fatalf(\"error parsing files: %v\", err)\n\t}\n\ttestExecute(templateFileExecTests, template, t)\n}",
    "filename": "/usr/local/go/src/text/template/multi_test.go",
    "line": 200
  },
  {
    "id": 291,
    "text": "func TestClone(t *testing.T) {\n\t// Create some templates and clone the root.\n\troot, err := New(\"root\").Parse(cloneText1)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\t_, err = root.Parse(cloneText2)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\troot.Parse(cloneText5)\n\troot.Option(\"missingkey=error\")\n\tclone := Must(root.Clone())\n\t// Add variants to both.\n\t_, err = root.Parse(cloneText3)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\t_, err = clone.Parse(cloneText4)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\t// Verify that the clone is self-consistent.\n\tfor k, v := range clone.tmpl {\n\t\tif k == clone.name \u0026\u0026 v.tmpl[k] != clone {\n\t\t\tt.Error(\"clone does not contain root\")\n\t\t}\n\t\tif v != v.tmpl[v.name] {\n\t\t\tt.Errorf(\"clone does not contain self for %q\", k)\n\t\t}\n\t}\n\t// Execute root.\n\tvar b strings.Builder\n\terr = root.ExecuteTemplate(\u0026b, \"a\", 0)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif b.String() != \"broot\" {\n\t\tt.Errorf(\"expected %q got %q\", \"broot\", b.String())\n\t}\n\t// Execute copy.\n\tb.Reset()\n\terr = clone.ExecuteTemplate(\u0026b, \"a\", 0)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif b.String() != \"bclone\" {\n\t\tt.Errorf(\"expected %q got %q\", \"bclone\", b.String())\n\t}\n\tb.Reset()\n\trootErr := root.ExecuteTemplate(\u0026b, \"e\", map[string]any{})\n\tcloneErr := clone.ExecuteTemplate(\u0026b, \"e\", map[string]any{})\n\tif cloneErr == nil {\n\t\tt.Errorf(\"expected error from missing key in cloned template\")\n\t} else if got, want := cloneErr.Error(), rootErr.Error(); got != want {\n\t\tt.Errorf(\"got %q, wan t %q\", got, want)\n\t}\n}",
    "filename": "/usr/local/go/src/text/template/multi_test.go",
    "line": 216
  },
  {
    "id": 292,
    "text": "func TestAddParseTree(t *testing.T) {\n\t// Create some templates.\n\troot, err := New(\"root\").Parse(cloneText1)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\t_, err = root.Parse(cloneText2)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\t// Add a new parse tree.\n\ttree, err := parse.Parse(\"cloneText3\", cloneText3, \"\", \"\", nil, builtins())\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tadded, err := root.AddParseTree(\"c\", tree[\"c\"])\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\t// Execute.\n\tvar b strings.Builder\n\terr = added.ExecuteTemplate(\u0026b, \"a\", 0)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif b.String() != \"broot\" {\n\t\tt.Errorf(\"expected %q got %q\", \"broot\", b.String())\n\t}\n}",
    "filename": "/usr/local/go/src/text/template/multi_test.go",
    "line": 275
  },
  {
    "id": 293,
    "text": "func TestAddParseTreeToUnparsedTemplate(t *testing.T) {\n\tmaster := \"{{define \\\"master\\\"}}{{end}}\"\n\ttmpl := New(\"master\")\n\ttree, err := parse.Parse(\"master\", master, \"\", \"\", nil)\n\tif err != nil {\n\t\tt.Fatalf(\"unexpected parse err: %v\", err)\n\t}\n\tmasterTree := tree[\"master\"]\n\ttmpl.AddParseTree(\"master\", masterTree) // used to panic\n}",
    "filename": "/usr/local/go/src/text/template/multi_test.go",
    "line": 306
  },
  {
    "id": 294,
    "text": "func TestRedefinition(t *testing.T) {\n\tvar tmpl *Template\n\tvar err error\n\tif tmpl, err = New(\"tmpl1\").Parse(`{{define \"test\"}}foo{{end}}`); err != nil {\n\t\tt.Fatalf(\"parse 1: %v\", err)\n\t}\n\tif _, err = tmpl.Parse(`{{define \"test\"}}bar{{end}}`); err != nil {\n\t\tt.Fatalf(\"got error %v, expected nil\", err)\n\t}\n\tif _, err = tmpl.New(\"tmpl2\").Parse(`{{define \"test\"}}bar{{end}}`); err != nil {\n\t\tt.Fatalf(\"got error %v, expected nil\", err)\n\t}\n}",
    "filename": "/usr/local/go/src/text/template/multi_test.go",
    "line": 317
  },
  {
    "id": 295,
    "text": "func TestEmptyTemplateCloneCrash(t *testing.T) {\n\tt1 := New(\"base\")\n\tt1.Clone() // used to panic\n}",
    "filename": "/usr/local/go/src/text/template/multi_test.go",
    "line": 332
  },
  {
    "id": 296,
    "text": "func TestTemplateLookUp(t *testing.T) {\n\tt1 := New(\"foo\")\n\tif t1.Lookup(\"foo\") != nil {\n\t\tt.Error(\"Lookup returned non-nil value for undefined template foo\")\n\t}\n\tt1.New(\"bar\")\n\tif t1.Lookup(\"bar\") != nil {\n\t\tt.Error(\"Lookup returned non-nil value for undefined template bar\")\n\t}\n\tt1.Parse(`{{define \"foo\"}}test{{end}}`)\n\tif t1.Lookup(\"foo\") == nil {\n\t\tt.Error(\"Lookup returned nil value for defined template\")\n\t}\n}",
    "filename": "/usr/local/go/src/text/template/multi_test.go",
    "line": 338
  },
  {
    "id": 297,
    "text": "func TestNew(t *testing.T) {\n\t// template with same name already exists\n\tt1, _ := New(\"test\").Parse(`{{define \"test\"}}foo{{end}}`)\n\tt2 := t1.New(\"test\")\n\n\tif t1.common != t2.common {\n\t\tt.Errorf(\"t1 \u0026 t2 didn't share common struct; got %v != %v\", t1.common, t2.common)\n\t}\n\tif t1.Tree == nil {\n\t\tt.Error(\"defined template got nil Tree\")\n\t}\n\tif t2.Tree != nil {\n\t\tt.Error(\"undefined template got non-nil Tree\")\n\t}\n\n\tcontainsT1 := false\n\tfor _, tmpl := range t1.Templates() {\n\t\tif tmpl == t2 {\n\t\t\tt.Error(\"Templates included undefined template\")\n\t\t}\n\t\tif tmpl == t1 {\n\t\t\tcontainsT1 = true\n\t\t}\n\t}\n\tif !containsT1 {\n\t\tt.Error(\"Templates didn't include defined template\")\n\t}\n}",
    "filename": "/usr/local/go/src/text/template/multi_test.go",
    "line": 353
  },
  {
    "id": 298,
    "text": "func TestParse(t *testing.T) {\n\t// In multiple calls to Parse with the same receiver template, only one call\n\t// can contain text other than space, comments, and template definitions\n\tt1 := New(\"test\")\n\tif _, err := t1.Parse(`{{define \"test\"}}{{end}}`); err != nil {\n\t\tt.Fatalf(\"parsing test: %s\", err)\n\t}\n\tif _, err := t1.Parse(`{{define \"test\"}}{{/* this is a comment */}}{{end}}`); err != nil {\n\t\tt.Fatalf(\"parsing test: %s\", err)\n\t}\n\tif _, err := t1.Parse(`{{define \"test\"}}foo{{end}}`); err != nil {\n\t\tt.Fatalf(\"parsing test: %s\", err)\n\t}\n}",
    "filename": "/usr/local/go/src/text/template/multi_test.go",
    "line": 382
  },
  {
    "id": 299,
    "text": "func TestEmptyTemplate(t *testing.T) {\n\tcases := []struct {\n\t\tdefn []string\n\t\tin   string\n\t\twant string\n\t}{\n\t\t{[]string{\"x\", \"y\"}, \"\", \"y\"},\n\t\t{[]string{\"\"}, \"once\", \"\"},\n\t\t{[]string{\"\", \"\"}, \"twice\", \"\"},\n\t\t{[]string{\"{{.}}\", \"{{.}}\"}, \"twice\", \"twice\"},\n\t\t{[]string{\"{{/* a comment */}}\", \"{{/* a comment */}}\"}, \"comment\", \"\"},\n\t\t{[]string{\"{{.}}\", \"\"}, \"twice\", \"\"},\n\t}\n\n\tfor i, c := range cases {\n\t\troot := New(\"root\")\n\n\t\tvar (\n\t\t\tm   *Template\n\t\t\terr error\n\t\t)\n\t\tfor _, d := range c.defn {\n\t\t\tm, err = root.New(c.in).Parse(d)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatal(err)\n\t\t\t}\n\t\t}\n\t\tbuf := \u0026strings.Builder{}\n\t\tif err := m.Execute(buf, c.in); err != nil {\n\t\t\tt.Error(i, err)\n\t\t\tcontinue\n\t\t}\n\t\tif buf.String() != c.want {\n\t\t\tt.Errorf(\"expected string %q: got %q\", c.want, buf.String())\n\t\t}\n\t}\n}",
    "filename": "/usr/local/go/src/text/template/multi_test.go",
    "line": 397
  },
  {
    "id": 300,
    "text": "func TestIssue19294(t *testing.T) {\n\t// The empty block in \"xhtml\" should be replaced during execution\n\t// by the contents of \"stylesheet\", but if the internal map associating\n\t// names with templates is built in the wrong order, the empty block\n\t// looks non-empty and this doesn't happen.\n\tvar inlined = map[string]string{\n\t\t\"stylesheet\": `{{define \"stylesheet\"}}stylesheet{{end}}`,\n\t\t\"xhtml\":      `{{block \"stylesheet\" .}}{{end}}`,\n\t}\n\tall := []string{\"stylesheet\", \"xhtml\"}\n\tfor i := 0; i \u003c 100; i++ {\n\t\tres, err := New(\"title.xhtml\").Parse(`{{template \"xhtml\" .}}`)\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tfor _, name := range all {\n\t\t\t_, err := res.New(name).Parse(inlined[name])\n\t\t\tif err != nil {\n\t\t\t\tt.Fatal(err)\n\t\t\t}\n\t\t}\n\t\tvar buf strings.Builder\n\t\tres.Execute(\u0026buf, 0)\n\t\tif buf.String() != \"stylesheet\" {\n\t\t\tt.Fatalf(\"iteration %d: got %q; expected %q\", i, buf.String(), \"stylesheet\")\n\t\t}\n\t}\n}",
    "filename": "/usr/local/go/src/text/template/multi_test.go",
    "line": 438
  },
  {
    "id": 301,
    "text": "func TestAddToZeroTemplate(t *testing.T) {\n\ttree, err := parse.Parse(\"c\", cloneText3, \"\", \"\", nil, builtins())\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tvar tmpl Template\n\ttmpl.AddParseTree(\"x\", tree[\"c\"])\n}",
    "filename": "/usr/local/go/src/text/template/multi_test.go",
    "line": 468
  },
  {
    "id": 302,
    "text": "func (t *Template) Option(opt ...string) *Template {\n\tt.init()\n\tfor _, s := range opt {\n\t\tt.setOption(s)\n\t}\n\treturn t\n}",
    "filename": "/usr/local/go/src/text/template/option.go",
    "line": 42
  },
  {
    "id": 303,
    "text": "func (t *Template) setOption(opt string) {\n\tif opt == \"\" {\n\t\tpanic(\"empty option string\")\n\t}\n\t// key=value\n\tif key, value, ok := strings.Cut(opt, \"=\"); ok {\n\t\tswitch key {\n\t\tcase \"missingkey\":\n\t\t\tswitch value {\n\t\t\tcase \"invalid\", \"default\":\n\t\t\t\tt.option.missingKey = mapInvalid\n\t\t\t\treturn\n\t\t\tcase \"zero\":\n\t\t\t\tt.option.missingKey = mapZeroValue\n\t\t\t\treturn\n\t\t\tcase \"error\":\n\t\t\t\tt.option.missingKey = mapError\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t}\n\tpanic(\"unrecognized option: \" + opt)\n}",
    "filename": "/usr/local/go/src/text/template/option.go",
    "line": 50
  },
  {
    "id": 304,
    "text": "func (i item) String() string {\n\tswitch {\n\tcase i.typ == itemEOF:\n\t\treturn \"EOF\"\n\tcase i.typ == itemError:\n\t\treturn i.val\n\tcase i.typ \u003e itemKeyword:\n\t\treturn fmt.Sprintf(\"\u003c%s\u003e\", i.val)\n\tcase len(i.val) \u003e 10:\n\t\treturn fmt.Sprintf(\"%.10q...\", i.val)\n\t}\n\treturn fmt.Sprintf(\"%q\", i.val)\n}",
    "filename": "/usr/local/go/src/text/template/parse/lex.go",
    "line": 22
  },
  {
    "id": 305,
    "text": "func (l *lexer) next() rune {\n\tif int(l.pos) \u003e= len(l.input) {\n\t\tl.atEOF = true\n\t\treturn eof\n\t}\n\tr, w := utf8.DecodeRuneInString(l.input[l.pos:])\n\tl.pos += Pos(w)\n\tif r == '\\n' {\n\t\tl.line++\n\t}\n\treturn r\n}",
    "filename": "/usr/local/go/src/text/template/parse/lex.go",
    "line": 137
  },
  {
    "id": 306,
    "text": "func (l *lexer) peek() rune {\n\tr := l.next()\n\tl.backup()\n\treturn r\n}",
    "filename": "/usr/local/go/src/text/template/parse/lex.go",
    "line": 151
  },
  {
    "id": 307,
    "text": "func (l *lexer) backup() {\n\tif !l.atEOF \u0026\u0026 l.pos \u003e 0 {\n\t\tr, w := utf8.DecodeLastRuneInString(l.input[:l.pos])\n\t\tl.pos -= Pos(w)\n\t\t// Correct newline count.\n\t\tif r == '\\n' {\n\t\t\tl.line--\n\t\t}\n\t}\n}",
    "filename": "/usr/local/go/src/text/template/parse/lex.go",
    "line": 158
  },
  {
    "id": 308,
    "text": "func (l *lexer) thisItem(t itemType) item {\n\ti := item{t, l.start, l.input[l.start:l.pos], l.startLine}\n\tl.start = l.pos\n\tl.startLine = l.line\n\treturn i\n}",
    "filename": "/usr/local/go/src/text/template/parse/lex.go",
    "line": 171
  },
  {
    "id": 309,
    "text": "func (l *lexer) emit(t itemType) stateFn {\n\treturn l.emitItem(l.thisItem(t))\n}",
    "filename": "/usr/local/go/src/text/template/parse/lex.go",
    "line": 179
  },
  {
    "id": 310,
    "text": "func (l *lexer) emitItem(i item) stateFn {\n\tl.item = i\n\treturn nil\n}",
    "filename": "/usr/local/go/src/text/template/parse/lex.go",
    "line": 184
  },
  {
    "id": 311,
    "text": "func (l *lexer) ignore() {\n\tl.line += strings.Count(l.input[l.start:l.pos], \"\\n\")\n\tl.start = l.pos\n\tl.startLine = l.line\n}",
    "filename": "/usr/local/go/src/text/template/parse/lex.go",
    "line": 192
  },
  {
    "id": 312,
    "text": "func (l *lexer) accept(valid string) bool {\n\tif strings.ContainsRune(valid, l.next()) {\n\t\treturn true\n\t}\n\tl.backup()\n\treturn false\n}",
    "filename": "/usr/local/go/src/text/template/parse/lex.go",
    "line": 199
  },
  {
    "id": 313,
    "text": "func (l *lexer) acceptRun(valid string) {\n\tfor strings.ContainsRune(valid, l.next()) {\n\t}\n\tl.backup()\n}",
    "filename": "/usr/local/go/src/text/template/parse/lex.go",
    "line": 208
  },
  {
    "id": 314,
    "text": "func (l *lexer) errorf(format string, args ...any) stateFn {\n\tl.item = item{itemError, l.start, fmt.Sprintf(format, args...), l.startLine}\n\tl.start = 0\n\tl.pos = 0\n\tl.input = l.input[:0]\n\treturn nil\n}",
    "filename": "/usr/local/go/src/text/template/parse/lex.go",
    "line": 216
  },
  {
    "id": 315,
    "text": "func (l *lexer) nextItem() item {\n\tl.item = item{itemEOF, l.pos, \"EOF\", l.startLine}\n\tstate := lexText\n\tif l.insideAction {\n\t\tstate = lexInsideAction\n\t}\n\tfor {\n\t\tstate = state(l)\n\t\tif state == nil {\n\t\t\treturn l.item\n\t\t}\n\t}\n}",
    "filename": "/usr/local/go/src/text/template/parse/lex.go",
    "line": 226
  },
  {
    "id": 316,
    "text": "func lex(name, input, left, right string) *lexer {\n\tif left == \"\" {\n\t\tleft = leftDelim\n\t}\n\tif right == \"\" {\n\t\tright = rightDelim\n\t}\n\tl := \u0026lexer{\n\t\tname:         name,\n\t\tinput:        input,\n\t\tleftDelim:    left,\n\t\trightDelim:   right,\n\t\tline:         1,\n\t\tstartLine:    1,\n\t\tinsideAction: false,\n\t}\n\treturn l\n}",
    "filename": "/usr/local/go/src/text/template/parse/lex.go",
    "line": 241
  },
  {
    "id": 317,
    "text": "func lexText(l *lexer) stateFn {\n\tif x := strings.Index(l.input[l.pos:], l.leftDelim); x \u003e= 0 {\n\t\tif x \u003e 0 {\n\t\t\tl.pos += Pos(x)\n\t\t\t// Do we trim any trailing space?\n\t\t\ttrimLength := Pos(0)\n\t\t\tdelimEnd := l.pos + Pos(len(l.leftDelim))\n\t\t\tif hasLeftTrimMarker(l.input[delimEnd:]) {\n\t\t\t\ttrimLength = rightTrimLength(l.input[l.start:l.pos])\n\t\t\t}\n\t\t\tl.pos -= trimLength\n\t\t\tl.line += strings.Count(l.input[l.start:l.pos], \"\\n\")\n\t\t\ti := l.thisItem(itemText)\n\t\t\tl.pos += trimLength\n\t\t\tl.ignore()\n\t\t\tif len(i.val) \u003e 0 {\n\t\t\t\treturn l.emitItem(i)\n\t\t\t}\n\t\t}\n\t\treturn lexLeftDelim\n\t}\n\tl.pos = Pos(len(l.input))\n\t// Correctly reached EOF.\n\tif l.pos \u003e l.start {\n\t\tl.line += strings.Count(l.input[l.start:l.pos], \"\\n\")\n\t\treturn l.emit(itemText)\n\t}\n\treturn l.emit(itemEOF)\n}",
    "filename": "/usr/local/go/src/text/template/parse/lex.go",
    "line": 270
  },
  {
    "id": 318,
    "text": "func rightTrimLength(s string) Pos {\n\treturn Pos(len(s) - len(strings.TrimRight(s, spaceChars)))\n}",
    "filename": "/usr/local/go/src/text/template/parse/lex.go",
    "line": 301
  },
  {
    "id": 319,
    "text": "func (l *lexer) atRightDelim() (delim, trimSpaces bool) {\n\tif hasRightTrimMarker(l.input[l.pos:]) \u0026\u0026 strings.HasPrefix(l.input[l.pos+trimMarkerLen:], l.rightDelim) { // With trim marker.\n\t\treturn true, true\n\t}\n\tif strings.HasPrefix(l.input[l.pos:], l.rightDelim) { // Without trim marker.\n\t\treturn true, false\n\t}\n\treturn false, false\n}",
    "filename": "/usr/local/go/src/text/template/parse/lex.go",
    "line": 306
  },
  {
    "id": 320,
    "text": "func leftTrimLength(s string) Pos {\n\treturn Pos(len(s) - len(strings.TrimLeft(s, spaceChars)))\n}",
    "filename": "/usr/local/go/src/text/template/parse/lex.go",
    "line": 317
  },
  {
    "id": 321,
    "text": "func lexLeftDelim(l *lexer) stateFn {\n\tl.pos += Pos(len(l.leftDelim))\n\ttrimSpace := hasLeftTrimMarker(l.input[l.pos:])\n\tafterMarker := Pos(0)\n\tif trimSpace {\n\t\tafterMarker = trimMarkerLen\n\t}\n\tif strings.HasPrefix(l.input[l.pos+afterMarker:], leftComment) {\n\t\tl.pos += afterMarker\n\t\tl.ignore()\n\t\treturn lexComment\n\t}\n\ti := l.thisItem(itemLeftDelim)\n\tl.insideAction = true\n\tl.pos += afterMarker\n\tl.ignore()\n\tl.parenDepth = 0\n\treturn l.emitItem(i)\n}",
    "filename": "/usr/local/go/src/text/template/parse/lex.go",
    "line": 323
  },
  {
    "id": 322,
    "text": "func lexComment(l *lexer) stateFn {\n\tl.pos += Pos(len(leftComment))\n\tx := strings.Index(l.input[l.pos:], rightComment)\n\tif x \u003c 0 {\n\t\treturn l.errorf(\"unclosed comment\")\n\t}\n\tl.pos += Pos(x + len(rightComment))\n\tdelim, trimSpace := l.atRightDelim()\n\tif !delim {\n\t\treturn l.errorf(\"comment ends before closing delimiter\")\n\t}\n\tl.line += strings.Count(l.input[l.start:l.pos], \"\\n\")\n\ti := l.thisItem(itemComment)\n\tif trimSpace {\n\t\tl.pos += trimMarkerLen\n\t}\n\tl.pos += Pos(len(l.rightDelim))\n\tif trimSpace {\n\t\tl.pos += leftTrimLength(l.input[l.pos:])\n\t}\n\tl.ignore()\n\tif l.options.emitComment {\n\t\treturn l.emitItem(i)\n\t}\n\treturn lexText\n}",
    "filename": "/usr/local/go/src/text/template/parse/lex.go",
    "line": 344
  },
  {
    "id": 323,
    "text": "func lexRightDelim(l *lexer) stateFn {\n\t_, trimSpace := l.atRightDelim()\n\tif trimSpace {\n\t\tl.pos += trimMarkerLen\n\t\tl.ignore()\n\t}\n\tl.pos += Pos(len(l.rightDelim))\n\ti := l.thisItem(itemRightDelim)\n\tif trimSpace {\n\t\tl.pos += leftTrimLength(l.input[l.pos:])\n\t\tl.ignore()\n\t}\n\tl.insideAction = false\n\treturn l.emitItem(i)\n}",
    "filename": "/usr/local/go/src/text/template/parse/lex.go",
    "line": 372
  },
  {
    "id": 324,
    "text": "func lexInsideAction(l *lexer) stateFn {\n\t// Either number, quoted string, or identifier.\n\t// Spaces separate arguments; runs of spaces turn into itemSpace.\n\t// Pipe symbols separate and are emitted.\n\tdelim, _ := l.atRightDelim()\n\tif delim {\n\t\tif l.parenDepth == 0 {\n\t\t\treturn lexRightDelim\n\t\t}\n\t\treturn l.errorf(\"unclosed left paren\")\n\t}\n\tswitch r := l.next(); {\n\tcase r == eof:\n\t\treturn l.errorf(\"unclosed action\")\n\tcase isSpace(r):\n\t\tl.backup() // Put space back in case we have \" -}}\".\n\t\treturn lexSpace\n\tcase r == '=':\n\t\treturn l.emit(itemAssign)\n\tcase r == ':':\n\t\tif l.next() != '=' {\n\t\t\treturn l.errorf(\"expected :=\")\n\t\t}\n\t\treturn l.emit(itemDeclare)\n\tcase r == '|':\n\t\treturn l.emit(itemPipe)\n\tcase r == '\"':\n\t\treturn lexQuote\n\tcase r == '`':\n\t\treturn lexRawQuote\n\tcase r == '$':\n\t\treturn lexVariable\n\tcase r == '\\'':\n\t\treturn lexChar\n\tcase r == '.':\n\t\t// special look-ahead for \".field\" so we don't break l.backup().\n\t\tif l.pos \u003c Pos(len(l.input)) {\n\t\t\tr := l.input[l.pos]\n\t\t\tif r \u003c '0' || '9' \u003c r {\n\t\t\t\treturn lexField\n\t\t\t}\n\t\t}\n\t\tfallthrough // '.' can start a number.\n\tcase r == '+' || r == '-' || ('0' \u003c= r \u0026\u0026 r \u003c= '9'):\n\t\tl.backup()\n\t\treturn lexNumber\n\tcase isAlphaNumeric(r):\n\t\tl.backup()\n\t\treturn lexIdentifier\n\tcase r == '(':\n\t\tl.parenDepth++\n\t\treturn l.emit(itemLeftParen)\n\tcase r == ')':\n\t\tl.parenDepth--\n\t\tif l.parenDepth \u003c 0 {\n\t\t\treturn l.errorf(\"unexpected right paren\")\n\t\t}\n\t\treturn l.emit(itemRightParen)\n\tcase r \u003c= unicode.MaxASCII \u0026\u0026 unicode.IsPrint(r):\n\t\treturn l.emit(itemChar)\n\tdefault:\n\t\treturn l.errorf(\"unrecognized character in action: %#U\", r)\n\t}\n}",
    "filename": "/usr/local/go/src/text/template/parse/lex.go",
    "line": 389
  },
  {
    "id": 325,
    "text": "func lexSpace(l *lexer) stateFn {\n\tvar r rune\n\tvar numSpaces int\n\tfor {\n\t\tr = l.peek()\n\t\tif !isSpace(r) {\n\t\t\tbreak\n\t\t}\n\t\tl.next()\n\t\tnumSpaces++\n\t}\n\t// Be careful about a trim-marked closing delimiter, which has a minus\n\t// after a space. We know there is a space, so check for the '-' that might follow.\n\tif hasRightTrimMarker(l.input[l.pos-1:]) \u0026\u0026 strings.HasPrefix(l.input[l.pos-1+trimMarkerLen:], l.rightDelim) {\n\t\tl.backup() // Before the space.\n\t\tif numSpaces == 1 {\n\t\t\treturn lexRightDelim // On the delim, so go right to that.\n\t\t}\n\t}\n\treturn l.emit(itemSpace)\n}",
    "filename": "/usr/local/go/src/text/template/parse/lex.go",
    "line": 457
  },
  {
    "id": 326,
    "text": "func lexIdentifier(l *lexer) stateFn {\n\tfor {\n\t\tswitch r := l.next(); {\n\t\tcase isAlphaNumeric(r):\n\t\t\t// absorb.\n\t\tdefault:\n\t\t\tl.backup()\n\t\t\tword := l.input[l.start:l.pos]\n\t\t\tif !l.atTerminator() {\n\t\t\t\treturn l.errorf(\"bad character %#U\", r)\n\t\t\t}\n\t\t\tswitch {\n\t\t\tcase key[word] \u003e itemKeyword:\n\t\t\t\titem := key[word]\n\t\t\t\tif item == itemBreak \u0026\u0026 !l.options.breakOK || item == itemContinue \u0026\u0026 !l.options.continueOK {\n\t\t\t\t\treturn l.emit(itemIdentifier)\n\t\t\t\t}\n\t\t\t\treturn l.emit(item)\n\t\t\tcase word[0] == '.':\n\t\t\t\treturn l.emit(itemField)\n\t\t\tcase word == \"true\", word == \"false\":\n\t\t\t\treturn l.emit(itemBool)\n\t\t\tdefault:\n\t\t\t\treturn l.emit(itemIdentifier)\n\t\t\t}\n\t\t}\n\t}\n}",
    "filename": "/usr/local/go/src/text/template/parse/lex.go",
    "line": 480
  },
  {
    "id": 327,
    "text": "func lexField(l *lexer) stateFn {\n\treturn lexFieldOrVariable(l, itemField)\n}",
    "filename": "/usr/local/go/src/text/template/parse/lex.go",
    "line": 511
  },
  {
    "id": 328,
    "text": "func lexVariable(l *lexer) stateFn {\n\tif l.atTerminator() { // Nothing interesting follows -\u003e \"$\".\n\t\treturn l.emit(itemVariable)\n\t}\n\treturn lexFieldOrVariable(l, itemVariable)\n}",
    "filename": "/usr/local/go/src/text/template/parse/lex.go",
    "line": 517
  },
  {
    "id": 329,
    "text": "func lexFieldOrVariable(l *lexer, typ itemType) stateFn {\n\tif l.atTerminator() { // Nothing interesting follows -\u003e \".\" or \"$\".\n\t\tif typ == itemVariable {\n\t\t\treturn l.emit(itemVariable)\n\t\t}\n\t\treturn l.emit(itemDot)\n\t}\n\tvar r rune\n\tfor {\n\t\tr = l.next()\n\t\tif !isAlphaNumeric(r) {\n\t\t\tl.backup()\n\t\t\tbreak\n\t\t}\n\t}\n\tif !l.atTerminator() {\n\t\treturn l.errorf(\"bad character %#U\", r)\n\t}\n\treturn l.emit(typ)\n}",
    "filename": "/usr/local/go/src/text/template/parse/lex.go",
    "line": 526
  },
  {
    "id": 330,
    "text": "func (l *lexer) atTerminator() bool {\n\tr := l.peek()\n\tif isSpace(r) {\n\t\treturn true\n\t}\n\tswitch r {\n\tcase eof, '.', ',', '|', ':', ')', '(':\n\t\treturn true\n\t}\n\treturn strings.HasPrefix(l.input[l.pos:], l.rightDelim)\n}",
    "filename": "/usr/local/go/src/text/template/parse/lex.go",
    "line": 551
  },
  {
    "id": 331,
    "text": "func lexChar(l *lexer) stateFn {\nLoop:\n\tfor {\n\t\tswitch l.next() {\n\t\tcase '\\\\':\n\t\t\tif r := l.next(); r != eof \u0026\u0026 r != '\\n' {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tfallthrough\n\t\tcase eof, '\\n':\n\t\t\treturn l.errorf(\"unterminated character constant\")\n\t\tcase '\\'':\n\t\t\tbreak Loop\n\t\t}\n\t}\n\treturn l.emit(itemCharConstant)\n}",
    "filename": "/usr/local/go/src/text/template/parse/lex.go",
    "line": 565
  },
  {
    "id": 332,
    "text": "func lexNumber(l *lexer) stateFn {\n\tif !l.scanNumber() {\n\t\treturn l.errorf(\"bad number syntax: %q\", l.input[l.start:l.pos])\n\t}\n\tif sign := l.peek(); sign == '+' || sign == '-' {\n\t\t// Complex: 1+2i. No spaces, must end in 'i'.\n\t\tif !l.scanNumber() || l.input[l.pos-1] != 'i' {\n\t\t\treturn l.errorf(\"bad number syntax: %q\", l.input[l.start:l.pos])\n\t\t}\n\t\treturn l.emit(itemComplex)\n\t}\n\treturn l.emit(itemNumber)\n}",
    "filename": "/usr/local/go/src/text/template/parse/lex.go",
    "line": 587
  },
  {
    "id": 333,
    "text": "func (l *lexer) scanNumber() bool {\n\t// Optional leading sign.\n\tl.accept(\"+-\")\n\t// Is it hex?\n\tdigits := \"0123456789_\"\n\tif l.accept(\"0\") {\n\t\t// Note: Leading 0 does not mean octal in floats.\n\t\tif l.accept(\"xX\") {\n\t\t\tdigits = \"0123456789abcdefABCDEF_\"\n\t\t} else if l.accept(\"oO\") {\n\t\t\tdigits = \"01234567_\"\n\t\t} else if l.accept(\"bB\") {\n\t\t\tdigits = \"01_\"\n\t\t}\n\t}\n\tl.acceptRun(digits)\n\tif l.accept(\".\") {\n\t\tl.acceptRun(digits)\n\t}\n\tif len(digits) == 10+1 \u0026\u0026 l.accept(\"eE\") {\n\t\tl.accept(\"+-\")\n\t\tl.acceptRun(\"0123456789_\")\n\t}\n\tif len(digits) == 16+6+1 \u0026\u0026 l.accept(\"pP\") {\n\t\tl.accept(\"+-\")\n\t\tl.acceptRun(\"0123456789_\")\n\t}\n\t// Is it imaginary?\n\tl.accept(\"i\")\n\t// Next thing mustn't be alphanumeric.\n\tif isAlphaNumeric(l.peek()) {\n\t\tl.next()\n\t\treturn false\n\t}\n\treturn true\n}",
    "filename": "/usr/local/go/src/text/template/parse/lex.go",
    "line": 601
  },
  {
    "id": 334,
    "text": "func lexQuote(l *lexer) stateFn {\nLoop:\n\tfor {\n\t\tswitch l.next() {\n\t\tcase '\\\\':\n\t\t\tif r := l.next(); r != eof \u0026\u0026 r != '\\n' {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tfallthrough\n\t\tcase eof, '\\n':\n\t\t\treturn l.errorf(\"unterminated quoted string\")\n\t\tcase '\"':\n\t\t\tbreak Loop\n\t\t}\n\t}\n\treturn l.emit(itemString)\n}",
    "filename": "/usr/local/go/src/text/template/parse/lex.go",
    "line": 639
  },
  {
    "id": 335,
    "text": "func lexRawQuote(l *lexer) stateFn {\nLoop:\n\tfor {\n\t\tswitch l.next() {\n\t\tcase eof:\n\t\t\treturn l.errorf(\"unterminated raw quoted string\")\n\t\tcase '`':\n\t\t\tbreak Loop\n\t\t}\n\t}\n\treturn l.emit(itemRawString)\n}",
    "filename": "/usr/local/go/src/text/template/parse/lex.go",
    "line": 658
  },
  {
    "id": 336,
    "text": "func isSpace(r rune) bool {\n\treturn r == ' ' || r == '\\t' || r == '\\r' || r == '\\n'\n}",
    "filename": "/usr/local/go/src/text/template/parse/lex.go",
    "line": 672
  },
  {
    "id": 337,
    "text": "func isAlphaNumeric(r rune) bool {\n\treturn r == '_' || unicode.IsLetter(r) || unicode.IsDigit(r)\n}",
    "filename": "/usr/local/go/src/text/template/parse/lex.go",
    "line": 677
  },
  {
    "id": 338,
    "text": "func hasLeftTrimMarker(s string) bool {\n\treturn len(s) \u003e= 2 \u0026\u0026 s[0] == trimMarker \u0026\u0026 isSpace(rune(s[1]))\n}",
    "filename": "/usr/local/go/src/text/template/parse/lex.go",
    "line": 681
  },
  {
    "id": 339,
    "text": "func hasRightTrimMarker(s string) bool {\n\treturn len(s) \u003e= 2 \u0026\u0026 isSpace(rune(s[0])) \u0026\u0026 s[1] == trimMarker\n}",
    "filename": "/usr/local/go/src/text/template/parse/lex.go",
    "line": 685
  },
  {
    "id": 340,
    "text": "func (i itemType) String() string {\n\ts := itemName[i]\n\tif s == \"\" {\n\t\treturn fmt.Sprintf(\"item%d\", int(i))\n\t}\n\treturn s\n}",
    "filename": "/usr/local/go/src/text/template/parse/lex_test.go",
    "line": 50
  },
  {
    "id": 341,
    "text": "func mkItem(typ itemType, text string) item {\n\treturn item{\n\t\ttyp: typ,\n\t\tval: text,\n\t}\n}",
    "filename": "/usr/local/go/src/text/template/parse/lex_test.go",
    "line": 64
  },
  {
    "id": 342,
    "text": "func collect(t *lexTest, left, right string) (items []item) {\n\tl := lex(t.name, t.input, left, right)\n\tl.options = lexOptions{\n\t\temitComment: true,\n\t\tbreakOK:     true,\n\t\tcontinueOK:  true,\n\t}\n\tfor {\n\t\titem := l.nextItem()\n\t\titems = append(items, item)\n\t\tif item.typ == itemEOF || item.typ == itemError {\n\t\t\tbreak\n\t\t}\n\t}\n\treturn\n}",
    "filename": "/usr/local/go/src/text/template/parse/lex_test.go",
    "line": 395
  },
  {
    "id": 343,
    "text": "func equal(i1, i2 []item, checkPos bool) bool {\n\tif len(i1) != len(i2) {\n\t\treturn false\n\t}\n\tfor k := range i1 {\n\t\tif i1[k].typ != i2[k].typ {\n\t\t\treturn false\n\t\t}\n\t\tif i1[k].val != i2[k].val {\n\t\t\treturn false\n\t\t}\n\t\tif checkPos \u0026\u0026 i1[k].pos != i2[k].pos {\n\t\t\treturn false\n\t\t}\n\t\tif checkPos \u0026\u0026 i1[k].line != i2[k].line {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}",
    "filename": "/usr/local/go/src/text/template/parse/lex_test.go",
    "line": 412
  },
  {
    "id": 344,
    "text": "func TestLex(t *testing.T) {\n\tfor _, test := range lexTests {\n\t\titems := collect(\u0026test, \"\", \"\")\n\t\tif !equal(items, test.items, false) {\n\t\t\tt.Errorf(\"%s: got\\n\\t%+v\\nexpected\\n\\t%v\", test.name, items, test.items)\n\t\t\treturn // TODO\n\t\t}\n\t\tt.Log(test.name, \"OK\")\n\t}\n}",
    "filename": "/usr/local/go/src/text/template/parse/lex_test.go",
    "line": 433
  },
  {
    "id": 345,
    "text": "func TestDelims(t *testing.T) {\n\tfor _, test := range lexDelimTests {\n\t\titems := collect(\u0026test, \"$$\", \"@@\")\n\t\tif !equal(items, test.items, false) {\n\t\t\tt.Errorf(\"%s: got\\n\\t%v\\nexpected\\n\\t%v\", test.name, items, test.items)\n\t\t}\n\t}\n}",
    "filename": "/usr/local/go/src/text/template/parse/lex_test.go",
    "line": 469
  },
  {
    "id": 346,
    "text": "func TestDelimsAlphaNumeric(t *testing.T) {\n\ttest := lexTest{\"right delimiter with alphanumeric start\", \"{{hub .host hub}}\", []item{\n\t\tmkItem(itemLeftDelim, \"{{hub\"),\n\t\tmkItem(itemSpace, \" \"),\n\t\tmkItem(itemField, \".host\"),\n\t\tmkItem(itemSpace, \" \"),\n\t\tmkItem(itemRightDelim, \"hub}}\"),\n\t\ttEOF,\n\t}}\n\titems := collect(\u0026test, \"{{hub\", \"hub}}\")\n\n\tif !equal(items, test.items, false) {\n\t\tt.Errorf(\"%s: got\\n\\t%v\\nexpected\\n\\t%v\", test.name, items, test.items)\n\t}\n}",
    "filename": "/usr/local/go/src/text/template/parse/lex_test.go",
    "line": 478
  },
  {
    "id": 347,
    "text": "func TestDelimsAndMarkers(t *testing.T) {\n\ttest := lexTest{\"delims that look like markers\", \"{{- .x -}} {{- - .x - -}}\", []item{\n\t\tmkItem(itemLeftDelim, \"{{- \"),\n\t\tmkItem(itemField, \".x\"),\n\t\tmkItem(itemRightDelim, \" -}}\"),\n\t\tmkItem(itemLeftDelim, \"{{- \"),\n\t\tmkItem(itemField, \".x\"),\n\t\tmkItem(itemRightDelim, \" -}}\"),\n\t\ttEOF,\n\t}}\n\titems := collect(\u0026test, \"{{- \", \" -}}\")\n\n\tif !equal(items, test.items, false) {\n\t\tt.Errorf(\"%s: got\\n\\t%v\\nexpected\\n\\t%v\", test.name, items, test.items)\n\t}\n}",
    "filename": "/usr/local/go/src/text/template/parse/lex_test.go",
    "line": 494
  },
  {
    "id": 348,
    "text": "func TestPos(t *testing.T) {\n\tfor _, test := range lexPosTests {\n\t\titems := collect(\u0026test, \"\", \"\")\n\t\tif !equal(items, test.items, true) {\n\t\t\tt.Errorf(\"%s: got\\n\\t%v\\nexpected\\n\\t%v\", test.name, items, test.items)\n\t\t\tif len(items) == len(test.items) {\n\t\t\t\t// Detailed print; avoid item.String() to expose the position value.\n\t\t\t\tfor i := range items {\n\t\t\t\t\tif !equal(items[i:i+1], test.items[i:i+1], true) {\n\t\t\t\t\t\ti1 := items[i]\n\t\t\t\t\t\ti2 := test.items[i]\n\t\t\t\t\t\tt.Errorf(\"\\t#%d: got {%v %d %q %d} expected {%v %d %q %d}\",\n\t\t\t\t\t\t\ti, i1.typ, i1.pos, i1.val, i1.line, i2.typ, i2.pos, i2.val, i2.line)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}",
    "filename": "/usr/local/go/src/text/template/parse/lex_test.go",
    "line": 562
  },
  {
    "id": 349,
    "text": "func (t *Tree) parseLexer(lex *lexer) (tree *Tree, err error) {\n\tdefer t.recover(\u0026err)\n\tt.ParseName = t.Name\n\tt.startParse(nil, lex, map[string]*Tree{})\n\tt.parse()\n\tt.add()\n\tt.stopParse()\n\treturn t, nil\n}",
    "filename": "/usr/local/go/src/text/template/parse/lex_test.go",
    "line": 584
  },
  {
    "id": 350,
    "text": "func (p Pos) Position() Pos {\n\treturn p\n}",
    "filename": "/usr/local/go/src/text/template/parse/node.go",
    "line": 42
  },
  {
    "id": 351,
    "text": "func (t NodeType) Type() NodeType {\n\treturn t\n}",
    "filename": "/usr/local/go/src/text/template/parse/node.go",
    "line": 48
  },
  {
    "id": 352,
    "text": "func (t *Tree) newList(pos Pos) *ListNode {\n\treturn \u0026ListNode{tr: t, NodeType: NodeList, Pos: pos}\n}",
    "filename": "/usr/local/go/src/text/template/parse/node.go",
    "line": 88
  },
  {
    "id": 353,
    "text": "func (l *ListNode) append(n Node) {\n\tl.Nodes = append(l.Nodes, n)\n}",
    "filename": "/usr/local/go/src/text/template/parse/node.go",
    "line": 92
  },
  {
    "id": 354,
    "text": "func (l *ListNode) tree() *Tree {\n\treturn l.tr\n}",
    "filename": "/usr/local/go/src/text/template/parse/node.go",
    "line": 96
  },
  {
    "id": 355,
    "text": "func (l *ListNode) String() string {\n\tvar sb strings.Builder\n\tl.writeTo(\u0026sb)\n\treturn sb.String()\n}",
    "filename": "/usr/local/go/src/text/template/parse/node.go",
    "line": 100
  },
  {
    "id": 356,
    "text": "func (l *ListNode) writeTo(sb *strings.Builder) {\n\tfor _, n := range l.Nodes {\n\t\tn.writeTo(sb)\n\t}\n}",
    "filename": "/usr/local/go/src/text/template/parse/node.go",
    "line": 106
  },
  {
    "id": 357,
    "text": "func (l *ListNode) CopyList() *ListNode {\n\tif l == nil {\n\t\treturn l\n\t}\n\tn := l.tr.newList(l.Pos)\n\tfor _, elem := range l.Nodes {\n\t\tn.append(elem.Copy())\n\t}\n\treturn n\n}",
    "filename": "/usr/local/go/src/text/template/parse/node.go",
    "line": 112
  },
  {
    "id": 358,
    "text": "func (l *ListNode) Copy() Node {\n\treturn l.CopyList()\n}",
    "filename": "/usr/local/go/src/text/template/parse/node.go",
    "line": 123
  },
  {
    "id": 359,
    "text": "func (t *Tree) newText(pos Pos, text string) *TextNode {\n\treturn \u0026TextNode{tr: t, NodeType: NodeText, Pos: pos, Text: []byte(text)}\n}",
    "filename": "/usr/local/go/src/text/template/parse/node.go",
    "line": 135
  },
  {
    "id": 360,
    "text": "func (t *TextNode) String() string {\n\treturn fmt.Sprintf(textFormat, t.Text)\n}",
    "filename": "/usr/local/go/src/text/template/parse/node.go",
    "line": 139
  },
  {
    "id": 361,
    "text": "func (t *TextNode) writeTo(sb *strings.Builder) {\n\tsb.WriteString(t.String())\n}",
    "filename": "/usr/local/go/src/text/template/parse/node.go",
    "line": 143
  },
  {
    "id": 362,
    "text": "func (t *TextNode) tree() *Tree {\n\treturn t.tr\n}",
    "filename": "/usr/local/go/src/text/template/parse/node.go",
    "line": 147
  },
  {
    "id": 363,
    "text": "func (t *TextNode) Copy() Node {\n\treturn \u0026TextNode{tr: t.tr, NodeType: NodeText, Pos: t.Pos, Text: append([]byte{}, t.Text...)}\n}",
    "filename": "/usr/local/go/src/text/template/parse/node.go",
    "line": 151
  },
  {
    "id": 364,
    "text": "func (t *Tree) newComment(pos Pos, text string) *CommentNode {\n\treturn \u0026CommentNode{tr: t, NodeType: NodeComment, Pos: pos, Text: text}\n}",
    "filename": "/usr/local/go/src/text/template/parse/node.go",
    "line": 163
  },
  {
    "id": 365,
    "text": "func (c *CommentNode) String() string {\n\tvar sb strings.Builder\n\tc.writeTo(\u0026sb)\n\treturn sb.String()\n}",
    "filename": "/usr/local/go/src/text/template/parse/node.go",
    "line": 167
  },
  {
    "id": 366,
    "text": "func (c *CommentNode) writeTo(sb *strings.Builder) {\n\tsb.WriteString(\"{{\")\n\tsb.WriteString(c.Text)\n\tsb.WriteString(\"}}\")\n}",
    "filename": "/usr/local/go/src/text/template/parse/node.go",
    "line": 173
  },
  {
    "id": 367,
    "text": "func (c *CommentNode) tree() *Tree {\n\treturn c.tr\n}",
    "filename": "/usr/local/go/src/text/template/parse/node.go",
    "line": 179
  },
  {
    "id": 368,
    "text": "func (c *CommentNode) Copy() Node {\n\treturn \u0026CommentNode{tr: c.tr, NodeType: NodeComment, Pos: c.Pos, Text: c.Text}\n}",
    "filename": "/usr/local/go/src/text/template/parse/node.go",
    "line": 183
  },
  {
    "id": 369,
    "text": "func (t *Tree) newPipeline(pos Pos, line int, vars []*VariableNode) *PipeNode {\n\treturn \u0026PipeNode{tr: t, NodeType: NodePipe, Pos: pos, Line: line, Decl: vars}\n}",
    "filename": "/usr/local/go/src/text/template/parse/node.go",
    "line": 198
  },
  {
    "id": 370,
    "text": "func (p *PipeNode) append(command *CommandNode) {\n\tp.Cmds = append(p.Cmds, command)\n}",
    "filename": "/usr/local/go/src/text/template/parse/node.go",
    "line": 202
  },
  {
    "id": 371,
    "text": "func (p *PipeNode) String() string {\n\tvar sb strings.Builder\n\tp.writeTo(\u0026sb)\n\treturn sb.String()\n}",
    "filename": "/usr/local/go/src/text/template/parse/node.go",
    "line": 206
  },
  {
    "id": 372,
    "text": "func (p *PipeNode) writeTo(sb *strings.Builder) {\n\tif len(p.Decl) \u003e 0 {\n\t\tfor i, v := range p.Decl {\n\t\t\tif i \u003e 0 {\n\t\t\t\tsb.WriteString(\", \")\n\t\t\t}\n\t\t\tv.writeTo(sb)\n\t\t}\n\t\tif p.IsAssign {\n\t\t\tsb.WriteString(\" = \")\n\t\t} else {\n\t\t\tsb.WriteString(\" := \")\n\t\t}\n\t}\n\tfor i, c := range p.Cmds {\n\t\tif i \u003e 0 {\n\t\t\tsb.WriteString(\" | \")\n\t\t}\n\t\tc.writeTo(sb)\n\t}\n}",
    "filename": "/usr/local/go/src/text/template/parse/node.go",
    "line": 212
  },
  {
    "id": 373,
    "text": "func (p *PipeNode) tree() *Tree {\n\treturn p.tr\n}",
    "filename": "/usr/local/go/src/text/template/parse/node.go",
    "line": 234
  },
  {
    "id": 374,
    "text": "func (p *PipeNode) CopyPipe() *PipeNode {\n\tif p == nil {\n\t\treturn p\n\t}\n\tvars := make([]*VariableNode, len(p.Decl))\n\tfor i, d := range p.Decl {\n\t\tvars[i] = d.Copy().(*VariableNode)\n\t}\n\tn := p.tr.newPipeline(p.Pos, p.Line, vars)\n\tn.IsAssign = p.IsAssign\n\tfor _, c := range p.Cmds {\n\t\tn.append(c.Copy().(*CommandNode))\n\t}\n\treturn n\n}",
    "filename": "/usr/local/go/src/text/template/parse/node.go",
    "line": 238
  },
  {
    "id": 375,
    "text": "func (p *PipeNode) Copy() Node {\n\treturn p.CopyPipe()\n}",
    "filename": "/usr/local/go/src/text/template/parse/node.go",
    "line": 254
  },
  {
    "id": 376,
    "text": "func (t *Tree) newAction(pos Pos, line int, pipe *PipeNode) *ActionNode {\n\treturn \u0026ActionNode{tr: t, NodeType: NodeAction, Pos: pos, Line: line, Pipe: pipe}\n}",
    "filename": "/usr/local/go/src/text/template/parse/node.go",
    "line": 269
  },
  {
    "id": 377,
    "text": "func (a *ActionNode) String() string {\n\tvar sb strings.Builder\n\ta.writeTo(\u0026sb)\n\treturn sb.String()\n}",
    "filename": "/usr/local/go/src/text/template/parse/node.go",
    "line": 273
  },
  {
    "id": 378,
    "text": "func (a *ActionNode) writeTo(sb *strings.Builder) {\n\tsb.WriteString(\"{{\")\n\ta.Pipe.writeTo(sb)\n\tsb.WriteString(\"}}\")\n}",
    "filename": "/usr/local/go/src/text/template/parse/node.go",
    "line": 279
  },
  {
    "id": 379,
    "text": "func (a *ActionNode) tree() *Tree {\n\treturn a.tr\n}",
    "filename": "/usr/local/go/src/text/template/parse/node.go",
    "line": 285
  },
  {
    "id": 380,
    "text": "func (a *ActionNode) Copy() Node {\n\treturn a.tr.newAction(a.Pos, a.Line, a.Pipe.CopyPipe())\n}",
    "filename": "/usr/local/go/src/text/template/parse/node.go",
    "line": 289
  },
  {
    "id": 381,
    "text": "func (t *Tree) newCommand(pos Pos) *CommandNode {\n\treturn \u0026CommandNode{tr: t, NodeType: NodeCommand, Pos: pos}\n}",
    "filename": "/usr/local/go/src/text/template/parse/node.go",
    "line": 301
  },
  {
    "id": 382,
    "text": "func (c *CommandNode) append(arg Node) {\n\tc.Args = append(c.Args, arg)\n}",
    "filename": "/usr/local/go/src/text/template/parse/node.go",
    "line": 305
  },
  {
    "id": 383,
    "text": "func (c *CommandNode) String() string {\n\tvar sb strings.Builder\n\tc.writeTo(\u0026sb)\n\treturn sb.String()\n}",
    "filename": "/usr/local/go/src/text/template/parse/node.go",
    "line": 309
  },
  {
    "id": 384,
    "text": "func (c *CommandNode) writeTo(sb *strings.Builder) {\n\tfor i, arg := range c.Args {\n\t\tif i \u003e 0 {\n\t\t\tsb.WriteByte(' ')\n\t\t}\n\t\tif arg, ok := arg.(*PipeNode); ok {\n\t\t\tsb.WriteByte('(')\n\t\t\targ.writeTo(sb)\n\t\t\tsb.WriteByte(')')\n\t\t\tcontinue\n\t\t}\n\t\targ.writeTo(sb)\n\t}\n}",
    "filename": "/usr/local/go/src/text/template/parse/node.go",
    "line": 315
  },
  {
    "id": 385,
    "text": "func (c *CommandNode) tree() *Tree {\n\treturn c.tr\n}",
    "filename": "/usr/local/go/src/text/template/parse/node.go",
    "line": 330
  },
  {
    "id": 386,
    "text": "func (c *CommandNode) Copy() Node {\n\tif c == nil {\n\t\treturn c\n\t}\n\tn := c.tr.newCommand(c.Pos)\n\tfor _, c := range c.Args {\n\t\tn.append(c.Copy())\n\t}\n\treturn n\n}",
    "filename": "/usr/local/go/src/text/template/parse/node.go",
    "line": 334
  },
  {
    "id": 387,
    "text": "func NewIdentifier(ident string) *IdentifierNode {\n\treturn \u0026IdentifierNode{NodeType: NodeIdentifier, Ident: ident}\n}",
    "filename": "/usr/local/go/src/text/template/parse/node.go",
    "line": 354
  },
  {
    "id": 388,
    "text": "func (i *IdentifierNode) SetPos(pos Pos) *IdentifierNode {\n\ti.Pos = pos\n\treturn i\n}",
    "filename": "/usr/local/go/src/text/template/parse/node.go",
    "line": 361
  },
  {
    "id": 389,
    "text": "func (i *IdentifierNode) SetTree(t *Tree) *IdentifierNode {\n\ti.tr = t\n\treturn i\n}",
    "filename": "/usr/local/go/src/text/template/parse/node.go",
    "line": 369
  },
  {
    "id": 390,
    "text": "func (i *IdentifierNode) String() string {\n\treturn i.Ident\n}",
    "filename": "/usr/local/go/src/text/template/parse/node.go",
    "line": 374
  },
  {
    "id": 391,
    "text": "func (i *IdentifierNode) writeTo(sb *strings.Builder) {\n\tsb.WriteString(i.String())\n}",
    "filename": "/usr/local/go/src/text/template/parse/node.go",
    "line": 378
  },
  {
    "id": 392,
    "text": "func (i *IdentifierNode) tree() *Tree {\n\treturn i.tr\n}",
    "filename": "/usr/local/go/src/text/template/parse/node.go",
    "line": 382
  },
  {
    "id": 393,
    "text": "func (i *IdentifierNode) Copy() Node {\n\treturn NewIdentifier(i.Ident).SetTree(i.tr).SetPos(i.Pos)\n}",
    "filename": "/usr/local/go/src/text/template/parse/node.go",
    "line": 386
  },
  {
    "id": 394,
    "text": "func (t *Tree) newVariable(pos Pos, ident string) *VariableNode {\n\treturn \u0026VariableNode{tr: t, NodeType: NodeVariable, Pos: pos, Ident: strings.Split(ident, \".\")}\n}",
    "filename": "/usr/local/go/src/text/template/parse/node.go",
    "line": 399
  },
  {
    "id": 395,
    "text": "func (v *VariableNode) String() string {\n\tvar sb strings.Builder\n\tv.writeTo(\u0026sb)\n\treturn sb.String()\n}",
    "filename": "/usr/local/go/src/text/template/parse/node.go",
    "line": 403
  },
  {
    "id": 396,
    "text": "func (v *VariableNode) writeTo(sb *strings.Builder) {\n\tfor i, id := range v.Ident {\n\t\tif i \u003e 0 {\n\t\t\tsb.WriteByte('.')\n\t\t}\n\t\tsb.WriteString(id)\n\t}\n}",
    "filename": "/usr/local/go/src/text/template/parse/node.go",
    "line": 409
  },
  {
    "id": 397,
    "text": "func (v *VariableNode) tree() *Tree {\n\treturn v.tr\n}",
    "filename": "/usr/local/go/src/text/template/parse/node.go",
    "line": 418
  },
  {
    "id": 398,
    "text": "func (v *VariableNode) Copy() Node {\n\treturn \u0026VariableNode{tr: v.tr, NodeType: NodeVariable, Pos: v.Pos, Ident: append([]string{}, v.Ident...)}\n}",
    "filename": "/usr/local/go/src/text/template/parse/node.go",
    "line": 422
  },
  {
    "id": 399,
    "text": "func (t *Tree) newDot(pos Pos) *DotNode {\n\treturn \u0026DotNode{tr: t, NodeType: NodeDot, Pos: pos}\n}",
    "filename": "/usr/local/go/src/text/template/parse/node.go",
    "line": 433
  },
  {
    "id": 400,
    "text": "func (d *DotNode) Type() NodeType {\n\t// Override method on embedded NodeType for API compatibility.\n\t// TODO: Not really a problem; could change API without effect but\n\t// api tool complains.\n\treturn NodeDot\n}",
    "filename": "/usr/local/go/src/text/template/parse/node.go",
    "line": 437
  },
  {
    "id": 401,
    "text": "func (d *DotNode) String() string {\n\treturn \".\"\n}",
    "filename": "/usr/local/go/src/text/template/parse/node.go",
    "line": 444
  },
  {
    "id": 402,
    "text": "func (d *DotNode) writeTo(sb *strings.Builder) {\n\tsb.WriteString(d.String())\n}",
    "filename": "/usr/local/go/src/text/template/parse/node.go",
    "line": 448
  },
  {
    "id": 403,
    "text": "func (d *DotNode) tree() *Tree {\n\treturn d.tr\n}",
    "filename": "/usr/local/go/src/text/template/parse/node.go",
    "line": 452
  },
  {
    "id": 404,
    "text": "func (d *DotNode) Copy() Node {\n\treturn d.tr.newDot(d.Pos)\n}",
    "filename": "/usr/local/go/src/text/template/parse/node.go",
    "line": 456
  },
  {
    "id": 405,
    "text": "func (t *Tree) newNil(pos Pos) *NilNode {\n\treturn \u0026NilNode{tr: t, NodeType: NodeNil, Pos: pos}\n}",
    "filename": "/usr/local/go/src/text/template/parse/node.go",
    "line": 467
  },
  {
    "id": 406,
    "text": "func (n *NilNode) Type() NodeType {\n\t// Override method on embedded NodeType for API compatibility.\n\t// TODO: Not really a problem; could change API without effect but\n\t// api tool complains.\n\treturn NodeNil\n}",
    "filename": "/usr/local/go/src/text/template/parse/node.go",
    "line": 471
  },
  {
    "id": 407,
    "text": "func (n *NilNode) String() string {\n\treturn \"nil\"\n}",
    "filename": "/usr/local/go/src/text/template/parse/node.go",
    "line": 478
  },
  {
    "id": 408,
    "text": "func (n *NilNode) writeTo(sb *strings.Builder) {\n\tsb.WriteString(n.String())\n}",
    "filename": "/usr/local/go/src/text/template/parse/node.go",
    "line": 482
  },
  {
    "id": 409,
    "text": "func (n *NilNode) tree() *Tree {\n\treturn n.tr\n}",
    "filename": "/usr/local/go/src/text/template/parse/node.go",
    "line": 486
  },
  {
    "id": 410,
    "text": "func (n *NilNode) Copy() Node {\n\treturn n.tr.newNil(n.Pos)\n}",
    "filename": "/usr/local/go/src/text/template/parse/node.go",
    "line": 490
  },
  {
    "id": 411,
    "text": "func (t *Tree) newField(pos Pos, ident string) *FieldNode {\n\treturn \u0026FieldNode{tr: t, NodeType: NodeField, Pos: pos, Ident: strings.Split(ident[1:], \".\")} // [1:] to drop leading period\n}",
    "filename": "/usr/local/go/src/text/template/parse/node.go",
    "line": 504
  },
  {
    "id": 412,
    "text": "func (f *FieldNode) String() string {\n\tvar sb strings.Builder\n\tf.writeTo(\u0026sb)\n\treturn sb.String()\n}",
    "filename": "/usr/local/go/src/text/template/parse/node.go",
    "line": 508
  },
  {
    "id": 413,
    "text": "func (f *FieldNode) writeTo(sb *strings.Builder) {\n\tfor _, id := range f.Ident {\n\t\tsb.WriteByte('.')\n\t\tsb.WriteString(id)\n\t}\n}",
    "filename": "/usr/local/go/src/text/template/parse/node.go",
    "line": 514
  },
  {
    "id": 414,
    "text": "func (f *FieldNode) tree() *Tree {\n\treturn f.tr\n}",
    "filename": "/usr/local/go/src/text/template/parse/node.go",
    "line": 521
  },
  {
    "id": 415,
    "text": "func (f *FieldNode) Copy() Node {\n\treturn \u0026FieldNode{tr: f.tr, NodeType: NodeField, Pos: f.Pos, Ident: append([]string{}, f.Ident...)}\n}",
    "filename": "/usr/local/go/src/text/template/parse/node.go",
    "line": 525
  },
  {
    "id": 416,
    "text": "func (t *Tree) newChain(pos Pos, node Node) *ChainNode {\n\treturn \u0026ChainNode{tr: t, NodeType: NodeChain, Pos: pos, Node: node}\n}",
    "filename": "/usr/local/go/src/text/template/parse/node.go",
    "line": 540
  },
  {
    "id": 417,
    "text": "func (c *ChainNode) Add(field string) {\n\tif len(field) == 0 || field[0] != '.' {\n\t\tpanic(\"no dot in field\")\n\t}\n\tfield = field[1:] // Remove leading dot.\n\tif field == \"\" {\n\t\tpanic(\"empty field\")\n\t}\n\tc.Field = append(c.Field, field)\n}",
    "filename": "/usr/local/go/src/text/template/parse/node.go",
    "line": 545
  },
  {
    "id": 418,
    "text": "func (c *ChainNode) String() string {\n\tvar sb strings.Builder\n\tc.writeTo(\u0026sb)\n\treturn sb.String()\n}",
    "filename": "/usr/local/go/src/text/template/parse/node.go",
    "line": 556
  },
  {
    "id": 419,
    "text": "func (c *ChainNode) writeTo(sb *strings.Builder) {\n\tif _, ok := c.Node.(*PipeNode); ok {\n\t\tsb.WriteByte('(')\n\t\tc.Node.writeTo(sb)\n\t\tsb.WriteByte(')')\n\t} else {\n\t\tc.Node.writeTo(sb)\n\t}\n\tfor _, field := range c.Field {\n\t\tsb.WriteByte('.')\n\t\tsb.WriteString(field)\n\t}\n}",
    "filename": "/usr/local/go/src/text/template/parse/node.go",
    "line": 562
  },
  {
    "id": 420,
    "text": "func (c *ChainNode) tree() *Tree {\n\treturn c.tr\n}",
    "filename": "/usr/local/go/src/text/template/parse/node.go",
    "line": 576
  },
  {
    "id": 421,
    "text": "func (c *ChainNode) Copy() Node {\n\treturn \u0026ChainNode{tr: c.tr, NodeType: NodeChain, Pos: c.Pos, Node: c.Node, Field: append([]string{}, c.Field...)}\n}",
    "filename": "/usr/local/go/src/text/template/parse/node.go",
    "line": 580
  },
  {
    "id": 422,
    "text": "func (t *Tree) newBool(pos Pos, true bool) *BoolNode {\n\treturn \u0026BoolNode{tr: t, NodeType: NodeBool, Pos: pos, True: true}\n}",
    "filename": "/usr/local/go/src/text/template/parse/node.go",
    "line": 592
  },
  {
    "id": 423,
    "text": "func (b *BoolNode) String() string {\n\tif b.True {\n\t\treturn \"true\"\n\t}\n\treturn \"false\"\n}",
    "filename": "/usr/local/go/src/text/template/parse/node.go",
    "line": 596
  },
  {
    "id": 424,
    "text": "func (b *BoolNode) writeTo(sb *strings.Builder) {\n\tsb.WriteString(b.String())\n}",
    "filename": "/usr/local/go/src/text/template/parse/node.go",
    "line": 603
  },
  {
    "id": 425,
    "text": "func (b *BoolNode) tree() *Tree {\n\treturn b.tr\n}",
    "filename": "/usr/local/go/src/text/template/parse/node.go",
    "line": 607
  },
  {
    "id": 426,
    "text": "func (b *BoolNode) Copy() Node {\n\treturn b.tr.newBool(b.Pos, b.True)\n}",
    "filename": "/usr/local/go/src/text/template/parse/node.go",
    "line": 611
  },
  {
    "id": 427,
    "text": "func (t *Tree) newNumber(pos Pos, text string, typ itemType) (*NumberNode, error) {\n\tn := \u0026NumberNode{tr: t, NodeType: NodeNumber, Pos: pos, Text: text}\n\tswitch typ {\n\tcase itemCharConstant:\n\t\trune, _, tail, err := strconv.UnquoteChar(text[1:], text[0])\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tif tail != \"'\" {\n\t\t\treturn nil, fmt.Errorf(\"malformed character constant: %s\", text)\n\t\t}\n\t\tn.Int64 = int64(rune)\n\t\tn.IsInt = true\n\t\tn.Uint64 = uint64(rune)\n\t\tn.IsUint = true\n\t\tn.Float64 = float64(rune) // odd but those are the rules.\n\t\tn.IsFloat = true\n\t\treturn n, nil\n\tcase itemComplex:\n\t\t// fmt.Sscan can parse the pair, so let it do the work.\n\t\tif _, err := fmt.Sscan(text, \u0026n.Complex128); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tn.IsComplex = true\n\t\tn.simplifyComplex()\n\t\treturn n, nil\n\t}\n\t// Imaginary constants can only be complex unless they are zero.\n\tif len(text) \u003e 0 \u0026\u0026 text[len(text)-1] == 'i' {\n\t\tf, err := strconv.ParseFloat(text[:len(text)-1], 64)\n\t\tif err == nil {\n\t\t\tn.IsComplex = true\n\t\t\tn.Complex128 = complex(0, f)\n\t\t\tn.simplifyComplex()\n\t\t\treturn n, nil\n\t\t}\n\t}\n\t// Do integer test first so we get 0x123 etc.\n\tu, err := strconv.ParseUint(text, 0, 64) // will fail for -0; fixed below.\n\tif err == nil {\n\t\tn.IsUint = true\n\t\tn.Uint64 = u\n\t}\n\ti, err := strconv.ParseInt(text, 0, 64)\n\tif err == nil {\n\t\tn.IsInt = true\n\t\tn.Int64 = i\n\t\tif i == 0 {\n\t\t\tn.IsUint = true // in case of -0.\n\t\t\tn.Uint64 = u\n\t\t}\n\t}\n\t// If an integer extraction succeeded, promote the float.\n\tif n.IsInt {\n\t\tn.IsFloat = true\n\t\tn.Float64 = float64(n.Int64)\n\t} else if n.IsUint {\n\t\tn.IsFloat = true\n\t\tn.Float64 = float64(n.Uint64)\n\t} else {\n\t\tf, err := strconv.ParseFloat(text, 64)\n\t\tif err == nil {\n\t\t\t// If we parsed it as a float but it looks like an integer,\n\t\t\t// it's a huge number too large to fit in an int. Reject it.\n\t\t\tif !strings.ContainsAny(text, \".eEpP\") {\n\t\t\t\treturn nil, fmt.Errorf(\"integer overflow: %q\", text)\n\t\t\t}\n\t\t\tn.IsFloat = true\n\t\t\tn.Float64 = f\n\t\t\t// If a floating-point extraction succeeded, extract the int if needed.\n\t\t\tif !n.IsInt \u0026\u0026 float64(int64(f)) == f {\n\t\t\t\tn.IsInt = true\n\t\t\t\tn.Int64 = int64(f)\n\t\t\t}\n\t\t\tif !n.IsUint \u0026\u0026 float64(uint64(f)) == f {\n\t\t\t\tn.IsUint = true\n\t\t\t\tn.Uint64 = uint64(f)\n\t\t\t}\n\t\t}\n\t}\n\tif !n.IsInt \u0026\u0026 !n.IsUint \u0026\u0026 !n.IsFloat {\n\t\treturn nil, fmt.Errorf(\"illegal number syntax: %q\", text)\n\t}\n\treturn n, nil\n}",
    "filename": "/usr/local/go/src/text/template/parse/node.go",
    "line": 633
  },
  {
    "id": 428,
    "text": "func (n *NumberNode) simplifyComplex() {\n\tn.IsFloat = imag(n.Complex128) == 0\n\tif n.IsFloat {\n\t\tn.Float64 = real(n.Complex128)\n\t\tn.IsInt = float64(int64(n.Float64)) == n.Float64\n\t\tif n.IsInt {\n\t\t\tn.Int64 = int64(n.Float64)\n\t\t}\n\t\tn.IsUint = float64(uint64(n.Float64)) == n.Float64\n\t\tif n.IsUint {\n\t\t\tn.Uint64 = uint64(n.Float64)\n\t\t}\n\t}\n}",
    "filename": "/usr/local/go/src/text/template/parse/node.go",
    "line": 721
  },
  {
    "id": 429,
    "text": "func (n *NumberNode) String() string {\n\treturn n.Text\n}",
    "filename": "/usr/local/go/src/text/template/parse/node.go",
    "line": 736
  },
  {
    "id": 430,
    "text": "func (n *NumberNode) writeTo(sb *strings.Builder) {\n\tsb.WriteString(n.String())\n}",
    "filename": "/usr/local/go/src/text/template/parse/node.go",
    "line": 740
  },
  {
    "id": 431,
    "text": "func (n *NumberNode) tree() *Tree {\n\treturn n.tr\n}",
    "filename": "/usr/local/go/src/text/template/parse/node.go",
    "line": 744
  },
  {
    "id": 432,
    "text": "func (n *NumberNode) Copy() Node {\n\tnn := new(NumberNode)\n\t*nn = *n // Easy, fast, correct.\n\treturn nn\n}",
    "filename": "/usr/local/go/src/text/template/parse/node.go",
    "line": 748
  },
  {
    "id": 433,
    "text": "func (t *Tree) newString(pos Pos, orig, text string) *StringNode {\n\treturn \u0026StringNode{tr: t, NodeType: NodeString, Pos: pos, Quoted: orig, Text: text}\n}",
    "filename": "/usr/local/go/src/text/template/parse/node.go",
    "line": 763
  },
  {
    "id": 434,
    "text": "func (s *StringNode) String() string {\n\treturn s.Quoted\n}",
    "filename": "/usr/local/go/src/text/template/parse/node.go",
    "line": 767
  },
  {
    "id": 435,
    "text": "func (s *StringNode) writeTo(sb *strings.Builder) {\n\tsb.WriteString(s.String())\n}",
    "filename": "/usr/local/go/src/text/template/parse/node.go",
    "line": 771
  },
  {
    "id": 436,
    "text": "func (s *StringNode) tree() *Tree {\n\treturn s.tr\n}",
    "filename": "/usr/local/go/src/text/template/parse/node.go",
    "line": 775
  },
  {
    "id": 437,
    "text": "func (s *StringNode) Copy() Node {\n\treturn s.tr.newString(s.Pos, s.Quoted, s.Text)\n}",
    "filename": "/usr/local/go/src/text/template/parse/node.go",
    "line": 779
  },
  {
    "id": 438,
    "text": "func (t *Tree) newEnd(pos Pos) *endNode {\n\treturn \u0026endNode{tr: t, NodeType: nodeEnd, Pos: pos}\n}",
    "filename": "/usr/local/go/src/text/template/parse/node.go",
    "line": 791
  },
  {
    "id": 439,
    "text": "func (e *endNode) String() string {\n\treturn \"{{end}}\"\n}",
    "filename": "/usr/local/go/src/text/template/parse/node.go",
    "line": 795
  },
  {
    "id": 440,
    "text": "func (e *endNode) writeTo(sb *strings.Builder) {\n\tsb.WriteString(e.String())\n}",
    "filename": "/usr/local/go/src/text/template/parse/node.go",
    "line": 799
  },
  {
    "id": 441,
    "text": "func (e *endNode) tree() *Tree {\n\treturn e.tr\n}",
    "filename": "/usr/local/go/src/text/template/parse/node.go",
    "line": 803
  },
  {
    "id": 442,
    "text": "func (e *endNode) Copy() Node {\n\treturn e.tr.newEnd(e.Pos)\n}",
    "filename": "/usr/local/go/src/text/template/parse/node.go",
    "line": 807
  },
  {
    "id": 443,
    "text": "func (t *Tree) newElse(pos Pos, line int) *elseNode {\n\treturn \u0026elseNode{tr: t, NodeType: nodeElse, Pos: pos, Line: line}\n}",
    "filename": "/usr/local/go/src/text/template/parse/node.go",
    "line": 819
  },
  {
    "id": 444,
    "text": "func (e *elseNode) Type() NodeType {\n\treturn nodeElse\n}",
    "filename": "/usr/local/go/src/text/template/parse/node.go",
    "line": 823
  },
  {
    "id": 445,
    "text": "func (e *elseNode) String() string {\n\treturn \"{{else}}\"\n}",
    "filename": "/usr/local/go/src/text/template/parse/node.go",
    "line": 827
  },
  {
    "id": 446,
    "text": "func (e *elseNode) writeTo(sb *strings.Builder) {\n\tsb.WriteString(e.String())\n}",
    "filename": "/usr/local/go/src/text/template/parse/node.go",
    "line": 831
  },
  {
    "id": 447,
    "text": "func (e *elseNode) tree() *Tree {\n\treturn e.tr\n}",
    "filename": "/usr/local/go/src/text/template/parse/node.go",
    "line": 835
  },
  {
    "id": 448,
    "text": "func (e *elseNode) Copy() Node {\n\treturn e.tr.newElse(e.Pos, e.Line)\n}",
    "filename": "/usr/local/go/src/text/template/parse/node.go",
    "line": 839
  },
  {
    "id": 449,
    "text": "func (b *BranchNode) String() string {\n\tvar sb strings.Builder\n\tb.writeTo(\u0026sb)\n\treturn sb.String()\n}",
    "filename": "/usr/local/go/src/text/template/parse/node.go",
    "line": 854
  },
  {
    "id": 450,
    "text": "func (b *BranchNode) writeTo(sb *strings.Builder) {\n\tname := \"\"\n\tswitch b.NodeType {\n\tcase NodeIf:\n\t\tname = \"if\"\n\tcase NodeRange:\n\t\tname = \"range\"\n\tcase NodeWith:\n\t\tname = \"with\"\n\tdefault:\n\t\tpanic(\"unknown branch type\")\n\t}\n\tsb.WriteString(\"{{\")\n\tsb.WriteString(name)\n\tsb.WriteByte(' ')\n\tb.Pipe.writeTo(sb)\n\tsb.WriteString(\"}}\")\n\tb.List.writeTo(sb)\n\tif b.ElseList != nil {\n\t\tsb.WriteString(\"{{else}}\")\n\t\tb.ElseList.writeTo(sb)\n\t}\n\tsb.WriteString(\"{{end}}\")\n}",
    "filename": "/usr/local/go/src/text/template/parse/node.go",
    "line": 860
  },
  {
    "id": 451,
    "text": "func (b *BranchNode) tree() *Tree {\n\treturn b.tr\n}",
    "filename": "/usr/local/go/src/text/template/parse/node.go",
    "line": 885
  },
  {
    "id": 452,
    "text": "func (b *BranchNode) Copy() Node {\n\tswitch b.NodeType {\n\tcase NodeIf:\n\t\treturn b.tr.newIf(b.Pos, b.Line, b.Pipe, b.List, b.ElseList)\n\tcase NodeRange:\n\t\treturn b.tr.newRange(b.Pos, b.Line, b.Pipe, b.List, b.ElseList)\n\tcase NodeWith:\n\t\treturn b.tr.newWith(b.Pos, b.Line, b.Pipe, b.List, b.ElseList)\n\tdefault:\n\t\tpanic(\"unknown branch type\")\n\t}\n}",
    "filename": "/usr/local/go/src/text/template/parse/node.go",
    "line": 889
  },
  {
    "id": 453,
    "text": "func (t *Tree) newIf(pos Pos, line int, pipe *PipeNode, list, elseList *ListNode) *IfNode {\n\treturn \u0026IfNode{BranchNode{tr: t, NodeType: NodeIf, Pos: pos, Line: line, Pipe: pipe, List: list, ElseList: elseList}}\n}",
    "filename": "/usr/local/go/src/text/template/parse/node.go",
    "line": 907
  },
  {
    "id": 454,
    "text": "func (i *IfNode) Copy() Node {\n\treturn i.tr.newIf(i.Pos, i.Line, i.Pipe.CopyPipe(), i.List.CopyList(), i.ElseList.CopyList())\n}",
    "filename": "/usr/local/go/src/text/template/parse/node.go",
    "line": 911
  },
  {
    "id": 455,
    "text": "func (t *Tree) newBreak(pos Pos, line int) *BreakNode {\n\treturn \u0026BreakNode{tr: t, NodeType: NodeBreak, Pos: pos, Line: line}\n}",
    "filename": "/usr/local/go/src/text/template/parse/node.go",
    "line": 923
  },
  {
    "id": 456,
    "text": "func (b *BreakNode) Copy() Node                  { return b.tr.newBreak(b.Pos, b.Line) }",
    "filename": "/usr/local/go/src/text/template/parse/node.go",
    "line": 927
  },
  {
    "id": 457,
    "text": "func (b *BreakNode) String() string              { return \"{{break}}\" }",
    "filename": "/usr/local/go/src/text/template/parse/node.go",
    "line": 928
  },
  {
    "id": 458,
    "text": "func (b *BreakNode) tree() *Tree                 { return b.tr }",
    "filename": "/usr/local/go/src/text/template/parse/node.go",
    "line": 929
  },
  {
    "id": 459,
    "text": "func (b *BreakNode) writeTo(sb *strings.Builder) { sb.WriteString(\"{{break}}\") }",
    "filename": "/usr/local/go/src/text/template/parse/node.go",
    "line": 930
  },
  {
    "id": 460,
    "text": "func (t *Tree) newContinue(pos Pos, line int) *ContinueNode {\n\treturn \u0026ContinueNode{tr: t, NodeType: NodeContinue, Pos: pos, Line: line}\n}",
    "filename": "/usr/local/go/src/text/template/parse/node.go",
    "line": 940
  },
  {
    "id": 461,
    "text": "func (c *ContinueNode) Copy() Node                  { return c.tr.newContinue(c.Pos, c.Line) }",
    "filename": "/usr/local/go/src/text/template/parse/node.go",
    "line": 944
  },
  {
    "id": 462,
    "text": "func (c *ContinueNode) String() string              { return \"{{continue}}\" }",
    "filename": "/usr/local/go/src/text/template/parse/node.go",
    "line": 945
  },
  {
    "id": 463,
    "text": "func (c *ContinueNode) tree() *Tree                 { return c.tr }",
    "filename": "/usr/local/go/src/text/template/parse/node.go",
    "line": 946
  },
  {
    "id": 464,
    "text": "func (c *ContinueNode) writeTo(sb *strings.Builder) { sb.WriteString(\"{{continue}}\") }",
    "filename": "/usr/local/go/src/text/template/parse/node.go",
    "line": 947
  },
  {
    "id": 465,
    "text": "func (t *Tree) newRange(pos Pos, line int, pipe *PipeNode, list, elseList *ListNode) *RangeNode {\n\treturn \u0026RangeNode{BranchNode{tr: t, NodeType: NodeRange, Pos: pos, Line: line, Pipe: pipe, List: list, ElseList: elseList}}\n}",
    "filename": "/usr/local/go/src/text/template/parse/node.go",
    "line": 954
  },
  {
    "id": 466,
    "text": "func (r *RangeNode) Copy() Node {\n\treturn r.tr.newRange(r.Pos, r.Line, r.Pipe.CopyPipe(), r.List.CopyList(), r.ElseList.CopyList())\n}",
    "filename": "/usr/local/go/src/text/template/parse/node.go",
    "line": 958
  },
  {
    "id": 467,
    "text": "func (t *Tree) newWith(pos Pos, line int, pipe *PipeNode, list, elseList *ListNode) *WithNode {\n\treturn \u0026WithNode{BranchNode{tr: t, NodeType: NodeWith, Pos: pos, Line: line, Pipe: pipe, List: list, ElseList: elseList}}\n}",
    "filename": "/usr/local/go/src/text/template/parse/node.go",
    "line": 967
  },
  {
    "id": 468,
    "text": "func (w *WithNode) Copy() Node {\n\treturn w.tr.newWith(w.Pos, w.Line, w.Pipe.CopyPipe(), w.List.CopyList(), w.ElseList.CopyList())\n}",
    "filename": "/usr/local/go/src/text/template/parse/node.go",
    "line": 971
  },
  {
    "id": 469,
    "text": "func (t *Tree) newTemplate(pos Pos, line int, name string, pipe *PipeNode) *TemplateNode {\n\treturn \u0026TemplateNode{tr: t, NodeType: NodeTemplate, Pos: pos, Line: line, Name: name, Pipe: pipe}\n}",
    "filename": "/usr/local/go/src/text/template/parse/node.go",
    "line": 985
  },
  {
    "id": 470,
    "text": "func (t *TemplateNode) String() string {\n\tvar sb strings.Builder\n\tt.writeTo(\u0026sb)\n\treturn sb.String()\n}",
    "filename": "/usr/local/go/src/text/template/parse/node.go",
    "line": 989
  },
  {
    "id": 471,
    "text": "func (t *TemplateNode) writeTo(sb *strings.Builder) {\n\tsb.WriteString(\"{{template \")\n\tsb.WriteString(strconv.Quote(t.Name))\n\tif t.Pipe != nil {\n\t\tsb.WriteByte(' ')\n\t\tt.Pipe.writeTo(sb)\n\t}\n\tsb.WriteString(\"}}\")\n}",
    "filename": "/usr/local/go/src/text/template/parse/node.go",
    "line": 995
  },
  {
    "id": 472,
    "text": "func (t *TemplateNode) tree() *Tree {\n\treturn t.tr\n}",
    "filename": "/usr/local/go/src/text/template/parse/node.go",
    "line": 1005
  },
  {
    "id": 473,
    "text": "func (t *TemplateNode) Copy() Node {\n\treturn t.tr.newTemplate(t.Pos, t.Line, t.Name, t.Pipe.CopyPipe())\n}",
    "filename": "/usr/local/go/src/text/template/parse/node.go",
    "line": 1009
  },
  {
    "id": 474,
    "text": "func init() {\n\tif runtime.GOARCH == \"wasm\" {\n\t\tmaxStackDepth = 1000\n\t}\n}",
    "filename": "/usr/local/go/src/text/template/parse/parse.go",
    "line": 51
  },
  {
    "id": 475,
    "text": "func (t *Tree) Copy() *Tree {\n\tif t == nil {\n\t\treturn nil\n\t}\n\treturn \u0026Tree{\n\t\tName:      t.Name,\n\t\tParseName: t.ParseName,\n\t\tRoot:      t.Root.CopyList(),\n\t\ttext:      t.text,\n\t}\n}",
    "filename": "/usr/local/go/src/text/template/parse/parse.go",
    "line": 58
  },
  {
    "id": 476,
    "text": "func Parse(name, text, leftDelim, rightDelim string, funcs ...map[string]any) (map[string]*Tree, error) {\n\ttreeSet := make(map[string]*Tree)\n\tt := New(name)\n\tt.text = text\n\t_, err := t.Parse(text, leftDelim, rightDelim, treeSet, funcs...)\n\treturn treeSet, err\n}",
    "filename": "/usr/local/go/src/text/template/parse/parse.go",
    "line": 74
  },
  {
    "id": 477,
    "text": "func (t *Tree) next() item {\n\tif t.peekCount \u003e 0 {\n\t\tt.peekCount--\n\t} else {\n\t\tt.token[0] = t.lex.nextItem()\n\t}\n\treturn t.token[t.peekCount]\n}",
    "filename": "/usr/local/go/src/text/template/parse/parse.go",
    "line": 83
  },
  {
    "id": 478,
    "text": "func (t *Tree) backup() {\n\tt.peekCount++\n}",
    "filename": "/usr/local/go/src/text/template/parse/parse.go",
    "line": 93
  },
  {
    "id": 479,
    "text": "func (t *Tree) backup2(t1 item) {\n\tt.token[1] = t1\n\tt.peekCount = 2\n}",
    "filename": "/usr/local/go/src/text/template/parse/parse.go",
    "line": 99
  },
  {
    "id": 480,
    "text": "func (t *Tree) backup3(t2, t1 item) { // Reverse order: we're pushing back.\n\tt.token[1] = t1\n\tt.token[2] = t2\n\tt.peekCount = 3\n}",
    "filename": "/usr/local/go/src/text/template/parse/parse.go",
    "line": 106
  },
  {
    "id": 481,
    "text": "func (t *Tree) peek() item {\n\tif t.peekCount \u003e 0 {\n\t\treturn t.token[t.peekCount-1]\n\t}\n\tt.peekCount = 1\n\tt.token[0] = t.lex.nextItem()\n\treturn t.token[0]\n}",
    "filename": "/usr/local/go/src/text/template/parse/parse.go",
    "line": 113
  },
  {
    "id": 482,
    "text": "func (t *Tree) nextNonSpace() (token item) {\n\tfor {\n\t\ttoken = t.next()\n\t\tif token.typ != itemSpace {\n\t\t\tbreak\n\t\t}\n\t}\n\treturn token\n}",
    "filename": "/usr/local/go/src/text/template/parse/parse.go",
    "line": 123
  },
  {
    "id": 483,
    "text": "func (t *Tree) peekNonSpace() item {\n\ttoken := t.nextNonSpace()\n\tt.backup()\n\treturn token\n}",
    "filename": "/usr/local/go/src/text/template/parse/parse.go",
    "line": 134
  },
  {
    "id": 484,
    "text": "func New(name string, funcs ...map[string]any) *Tree {\n\treturn \u0026Tree{\n\t\tName:  name,\n\t\tfuncs: funcs,\n\t}\n}",
    "filename": "/usr/local/go/src/text/template/parse/parse.go",
    "line": 143
  },
  {
    "id": 485,
    "text": "func (t *Tree) ErrorContext(n Node) (location, context string) {\n\tpos := int(n.Position())\n\ttree := n.tree()\n\tif tree == nil {\n\t\ttree = t\n\t}\n\ttext := tree.text[:pos]\n\tbyteNum := strings.LastIndex(text, \"\\n\")\n\tif byteNum == -1 {\n\t\tbyteNum = pos // On first line.\n\t} else {\n\t\tbyteNum++ // After the newline.\n\t\tbyteNum = pos - byteNum\n\t}\n\tlineNum := 1 + strings.Count(text, \"\\n\")\n\tcontext = n.String()\n\treturn fmt.Sprintf(\"%s:%d:%d\", tree.ParseName, lineNum, byteNum), context\n}",
    "filename": "/usr/local/go/src/text/template/parse/parse.go",
    "line": 153
  },
  {
    "id": 486,
    "text": "func (t *Tree) errorf(format string, args ...any) {\n\tt.Root = nil\n\tformat = fmt.Sprintf(\"template: %s:%d: %s\", t.ParseName, t.token[0].line, format)\n\tpanic(fmt.Errorf(format, args...))\n}",
    "filename": "/usr/local/go/src/text/template/parse/parse.go",
    "line": 173
  },
  {
    "id": 487,
    "text": "func (t *Tree) error(err error) {\n\tt.errorf(\"%s\", err)\n}",
    "filename": "/usr/local/go/src/text/template/parse/parse.go",
    "line": 180
  },
  {
    "id": 488,
    "text": "func (t *Tree) expect(expected itemType, context string) item {\n\ttoken := t.nextNonSpace()\n\tif token.typ != expected {\n\t\tt.unexpected(token, context)\n\t}\n\treturn token\n}",
    "filename": "/usr/local/go/src/text/template/parse/parse.go",
    "line": 185
  },
  {
    "id": 489,
    "text": "func (t *Tree) expectOneOf(expected1, expected2 itemType, context string) item {\n\ttoken := t.nextNonSpace()\n\tif token.typ != expected1 \u0026\u0026 token.typ != expected2 {\n\t\tt.unexpected(token, context)\n\t}\n\treturn token\n}",
    "filename": "/usr/local/go/src/text/template/parse/parse.go",
    "line": 194
  },
  {
    "id": 490,
    "text": "func (t *Tree) unexpected(token item, context string) {\n\tif token.typ == itemError {\n\t\textra := \"\"\n\t\tif t.actionLine != 0 \u0026\u0026 t.actionLine != token.line {\n\t\t\textra = fmt.Sprintf(\" in action started at %s:%d\", t.ParseName, t.actionLine)\n\t\t\tif strings.HasSuffix(token.val, \" action\") {\n\t\t\t\textra = extra[len(\" in action\"):] // avoid \"action in action\"\n\t\t\t}\n\t\t}\n\t\tt.errorf(\"%s%s\", token, extra)\n\t}\n\tt.errorf(\"unexpected %s in %s\", token, context)\n}",
    "filename": "/usr/local/go/src/text/template/parse/parse.go",
    "line": 203
  },
  {
    "id": 491,
    "text": "func (t *Tree) recover(errp *error) {\n\te := recover()\n\tif e != nil {\n\t\tif _, ok := e.(runtime.Error); ok {\n\t\t\tpanic(e)\n\t\t}\n\t\tif t != nil {\n\t\t\tt.stopParse()\n\t\t}\n\t\t*errp = e.(error)\n\t}\n}",
    "filename": "/usr/local/go/src/text/template/parse/parse.go",
    "line": 218
  },
  {
    "id": 492,
    "text": "func (t *Tree) startParse(funcs []map[string]any, lex *lexer, treeSet map[string]*Tree) {\n\tt.Root = nil\n\tt.lex = lex\n\tt.vars = []string{\"$\"}\n\tt.funcs = funcs\n\tt.treeSet = treeSet\n\tt.stackDepth = 0\n\tlex.options = lexOptions{\n\t\temitComment: t.Mode\u0026ParseComments != 0,\n\t\tbreakOK:     !t.hasFunction(\"break\"),\n\t\tcontinueOK:  !t.hasFunction(\"continue\"),\n\t}\n}",
    "filename": "/usr/local/go/src/text/template/parse/parse.go",
    "line": 232
  },
  {
    "id": 493,
    "text": "func (t *Tree) stopParse() {\n\tt.lex = nil\n\tt.vars = nil\n\tt.funcs = nil\n\tt.treeSet = nil\n}",
    "filename": "/usr/local/go/src/text/template/parse/parse.go",
    "line": 247
  },
  {
    "id": 494,
    "text": "func (t *Tree) Parse(text, leftDelim, rightDelim string, treeSet map[string]*Tree, funcs ...map[string]any) (tree *Tree, err error) {\n\tdefer t.recover(\u0026err)\n\tt.ParseName = t.Name\n\tlexer := lex(t.Name, text, leftDelim, rightDelim)\n\tt.startParse(funcs, lexer, treeSet)\n\tt.text = text\n\tt.parse()\n\tt.add()\n\tt.stopParse()\n\treturn t, nil\n}",
    "filename": "/usr/local/go/src/text/template/parse/parse.go",
    "line": 258
  },
  {
    "id": 495,
    "text": "func (t *Tree) add() {\n\ttree := t.treeSet[t.Name]\n\tif tree == nil || IsEmptyTree(tree.Root) {\n\t\tt.treeSet[t.Name] = t\n\t\treturn\n\t}\n\tif !IsEmptyTree(t.Root) {\n\t\tt.errorf(\"template: multiple definition of template %q\", t.Name)\n\t}\n}",
    "filename": "/usr/local/go/src/text/template/parse/parse.go",
    "line": 271
  },
  {
    "id": 496,
    "text": "func IsEmptyTree(n Node) bool {\n\tswitch n := n.(type) {\n\tcase nil:\n\t\treturn true\n\tcase *ActionNode:\n\tcase *CommentNode:\n\t\treturn true\n\tcase *IfNode:\n\tcase *ListNode:\n\t\tfor _, node := range n.Nodes {\n\t\t\tif !IsEmptyTree(node) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\tcase *RangeNode:\n\tcase *TemplateNode:\n\tcase *TextNode:\n\t\treturn len(bytes.TrimSpace(n.Text)) == 0\n\tcase *WithNode:\n\tdefault:\n\t\tpanic(\"unknown node: \" + n.String())\n\t}\n\treturn false\n}",
    "filename": "/usr/local/go/src/text/template/parse/parse.go",
    "line": 283
  },
  {
    "id": 497,
    "text": "func (t *Tree) parse() {\n\tt.Root = t.newList(t.peek().pos)\n\tfor t.peek().typ != itemEOF {\n\t\tif t.peek().typ == itemLeftDelim {\n\t\t\tdelim := t.next()\n\t\t\tif t.nextNonSpace().typ == itemDefine {\n\t\t\t\tnewT := New(\"definition\") // name will be updated once we know it.\n\t\t\t\tnewT.text = t.text\n\t\t\t\tnewT.Mode = t.Mode\n\t\t\t\tnewT.ParseName = t.ParseName\n\t\t\t\tnewT.startParse(t.funcs, t.lex, t.treeSet)\n\t\t\t\tnewT.parseDefinition()\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tt.backup2(delim)\n\t\t}\n\t\tswitch n := t.textOrAction(); n.Type() {\n\t\tcase nodeEnd, nodeElse:\n\t\t\tt.errorf(\"unexpected %s\", n)\n\t\tdefault:\n\t\t\tt.Root.append(n)\n\t\t}\n\t}\n}",
    "filename": "/usr/local/go/src/text/template/parse/parse.go",
    "line": 312
  },
  {
    "id": 498,
    "text": "func (t *Tree) parseDefinition() {\n\tconst context = \"define clause\"\n\tname := t.expectOneOf(itemString, itemRawString, context)\n\tvar err error\n\tt.Name, err = strconv.Unquote(name.val)\n\tif err != nil {\n\t\tt.error(err)\n\t}\n\tt.expect(itemRightDelim, context)\n\tvar end Node\n\tt.Root, end = t.itemList()\n\tif end.Type() != nodeEnd {\n\t\tt.errorf(\"unexpected %s in %s\", end, context)\n\t}\n\tt.add()\n\tt.stopParse()\n}",
    "filename": "/usr/local/go/src/text/template/parse/parse.go",
    "line": 340
  },
  {
    "id": 499,
    "text": "func (t *Tree) itemList() (list *ListNode, next Node) {\n\tlist = t.newList(t.peekNonSpace().pos)\n\tfor t.peekNonSpace().typ != itemEOF {\n\t\tn := t.textOrAction()\n\t\tswitch n.Type() {\n\t\tcase nodeEnd, nodeElse:\n\t\t\treturn list, n\n\t\t}\n\t\tlist.append(n)\n\t}\n\tt.errorf(\"unexpected EOF\")\n\treturn\n}",
    "filename": "/usr/local/go/src/text/template/parse/parse.go",
    "line": 363
  },
  {
    "id": 500,
    "text": "func (t *Tree) textOrAction() Node {\n\tswitch token := t.nextNonSpace(); token.typ {\n\tcase itemText:\n\t\treturn t.newText(token.pos, token.val)\n\tcase itemLeftDelim:\n\t\tt.actionLine = token.line\n\t\tdefer t.clearActionLine()\n\t\treturn t.action()\n\tcase itemComment:\n\t\treturn t.newComment(token.pos, token.val)\n\tdefault:\n\t\tt.unexpected(token, \"input\")\n\t}\n\treturn nil\n}",
    "filename": "/usr/local/go/src/text/template/parse/parse.go",
    "line": 380
  },
  {
    "id": 501,
    "text": "func (t *Tree) clearActionLine() {\n\tt.actionLine = 0\n}",
    "filename": "/usr/local/go/src/text/template/parse/parse.go",
    "line": 396
  },
  {
    "id": 502,
    "text": "func (t *Tree) action() (n Node) {\n\tswitch token := t.nextNonSpace(); token.typ {\n\tcase itemBlock:\n\t\treturn t.blockControl()\n\tcase itemBreak:\n\t\treturn t.breakControl(token.pos, token.line)\n\tcase itemContinue:\n\t\treturn t.continueControl(token.pos, token.line)\n\tcase itemElse:\n\t\treturn t.elseControl()\n\tcase itemEnd:\n\t\treturn t.endControl()\n\tcase itemIf:\n\t\treturn t.ifControl()\n\tcase itemRange:\n\t\treturn t.rangeControl()\n\tcase itemTemplate:\n\t\treturn t.templateControl()\n\tcase itemWith:\n\t\treturn t.withControl()\n\t}\n\tt.backup()\n\ttoken := t.peek()\n\t// Do not pop variables; they persist until \"end\".\n\treturn t.newAction(token.pos, token.line, t.pipeline(\"command\", itemRightDelim))\n}",
    "filename": "/usr/local/go/src/text/template/parse/parse.go",
    "line": 407
  },
  {
    "id": 503,
    "text": "func (t *Tree) breakControl(pos Pos, line int) Node {\n\tif token := t.nextNonSpace(); token.typ != itemRightDelim {\n\t\tt.unexpected(token, \"{{break}}\")\n\t}\n\tif t.rangeDepth == 0 {\n\t\tt.errorf(\"{{break}} outside {{range}}\")\n\t}\n\treturn t.newBreak(pos, line)\n}",
    "filename": "/usr/local/go/src/text/template/parse/parse.go",
    "line": 439
  },
  {
    "id": 504,
    "text": "func (t *Tree) continueControl(pos Pos, line int) Node {\n\tif token := t.nextNonSpace(); token.typ != itemRightDelim {\n\t\tt.unexpected(token, \"{{continue}}\")\n\t}\n\tif t.rangeDepth == 0 {\n\t\tt.errorf(\"{{continue}} outside {{range}}\")\n\t}\n\treturn t.newContinue(pos, line)\n}",
    "filename": "/usr/local/go/src/text/template/parse/parse.go",
    "line": 454
  },
  {
    "id": 505,
    "text": "func (t *Tree) pipeline(context string, end itemType) (pipe *PipeNode) {\n\ttoken := t.peekNonSpace()\n\tpipe = t.newPipeline(token.pos, token.line, nil)\n\t// Are there declarations or assignments?\ndecls:\n\tif v := t.peekNonSpace(); v.typ == itemVariable {\n\t\tt.next()\n\t\t// Since space is a token, we need 3-token look-ahead here in the worst case:\n\t\t// in \"$x foo\" we need to read \"foo\" (as opposed to \":=\") to know that $x is an\n\t\t// argument variable rather than a declaration. So remember the token\n\t\t// adjacent to the variable so we can push it back if necessary.\n\t\ttokenAfterVariable := t.peek()\n\t\tnext := t.peekNonSpace()\n\t\tswitch {\n\t\tcase next.typ == itemAssign, next.typ == itemDeclare:\n\t\t\tpipe.IsAssign = next.typ == itemAssign\n\t\t\tt.nextNonSpace()\n\t\t\tpipe.Decl = append(pipe.Decl, t.newVariable(v.pos, v.val))\n\t\t\tt.vars = append(t.vars, v.val)\n\t\tcase next.typ == itemChar \u0026\u0026 next.val == \",\":\n\t\t\tt.nextNonSpace()\n\t\t\tpipe.Decl = append(pipe.Decl, t.newVariable(v.pos, v.val))\n\t\t\tt.vars = append(t.vars, v.val)\n\t\t\tif context == \"range\" \u0026\u0026 len(pipe.Decl) \u003c 2 {\n\t\t\t\tswitch t.peekNonSpace().typ {\n\t\t\t\tcase itemVariable, itemRightDelim, itemRightParen:\n\t\t\t\t\t// second initialized variable in a range pipeline\n\t\t\t\t\tgoto decls\n\t\t\t\tdefault:\n\t\t\t\t\tt.errorf(\"range can only initialize variables\")\n\t\t\t\t}\n\t\t\t}\n\t\t\tt.errorf(\"too many declarations in %s\", context)\n\t\tcase tokenAfterVariable.typ == itemSpace:\n\t\t\tt.backup3(v, tokenAfterVariable)\n\t\tdefault:\n\t\t\tt.backup2(v)\n\t\t}\n\t}\n\tfor {\n\t\tswitch token := t.nextNonSpace(); token.typ {\n\t\tcase end:\n\t\t\t// At this point, the pipeline is complete\n\t\t\tt.checkPipeline(pipe, context)\n\t\t\treturn\n\t\tcase itemBool, itemCharConstant, itemComplex, itemDot, itemField, itemIdentifier,\n\t\t\titemNumber, itemNil, itemRawString, itemString, itemVariable, itemLeftParen:\n\t\t\tt.backup()\n\t\t\tpipe.append(t.command())\n\t\tdefault:\n\t\t\tt.unexpected(token, context)\n\t\t}\n\t}\n}",
    "filename": "/usr/local/go/src/text/template/parse/parse.go",
    "line": 467
  },
  {
    "id": 506,
    "text": "func (t *Tree) checkPipeline(pipe *PipeNode, context string) {\n\t// Reject empty pipelines\n\tif len(pipe.Cmds) == 0 {\n\t\tt.errorf(\"missing value for %s\", context)\n\t}\n\t// Only the first command of a pipeline can start with a non executable operand\n\tfor i, c := range pipe.Cmds[1:] {\n\t\tswitch c.Args[0].Type() {\n\t\tcase NodeBool, NodeDot, NodeNil, NodeNumber, NodeString:\n\t\t\t// With A|B|C, pipeline stage 2 is B\n\t\t\tt.errorf(\"non executable command in pipeline stage %d\", i+2)\n\t\t}\n\t}\n}",
    "filename": "/usr/local/go/src/text/template/parse/parse.go",
    "line": 522
  },
  {
    "id": 507,
    "text": "func (t *Tree) parseControl(context string) (pos Pos, line int, pipe *PipeNode, list, elseList *ListNode) {\n\tdefer t.popVars(len(t.vars))\n\tpipe = t.pipeline(context, itemRightDelim)\n\tif context == \"range\" {\n\t\tt.rangeDepth++\n\t}\n\tvar next Node\n\tlist, next = t.itemList()\n\tif context == \"range\" {\n\t\tt.rangeDepth--\n\t}\n\tswitch next.Type() {\n\tcase nodeEnd: //done\n\tcase nodeElse:\n\t\t// Special case for \"else if\" and \"else with\".\n\t\t// If the \"else\" is followed immediately by an \"if\" or \"with\",\n\t\t// the elseControl will have left the \"if\" or \"with\" token pending. Treat\n\t\t//\t{{if a}}_{{else if b}}_{{end}}\n\t\t//  {{with a}}_{{else with b}}_{{end}}\n\t\t// as\n\t\t//\t{{if a}}_{{else}}{{if b}}_{{end}}{{end}}\n\t\t//  {{with a}}_{{else}}{{with b}}_{{end}}{{end}}.\n\t\t// To do this, parse the \"if\" or \"with\" as usual and stop at it {{end}};\n\t\t// the subsequent{{end}} is assumed. This technique works even for long if-else-if chains.\n\t\tif context == \"if\" \u0026\u0026 t.peek().typ == itemIf {\n\t\t\tt.next() // Consume the \"if\" token.\n\t\t\telseList = t.newList(next.Position())\n\t\t\telseList.append(t.ifControl())\n\t\t} else if context == \"with\" \u0026\u0026 t.peek().typ == itemWith {\n\t\t\tt.next()\n\t\t\telseList = t.newList(next.Position())\n\t\t\telseList.append(t.withControl())\n\t\t} else {\n\t\t\telseList, next = t.itemList()\n\t\t\tif next.Type() != nodeEnd {\n\t\t\t\tt.errorf(\"expected end; found %s\", next)\n\t\t\t}\n\t\t}\n\t}\n\treturn pipe.Position(), pipe.Line, pipe, list, elseList\n}",
    "filename": "/usr/local/go/src/text/template/parse/parse.go",
    "line": 537
  },
  {
    "id": 508,
    "text": "func (t *Tree) ifControl() Node {\n\treturn t.newIf(t.parseControl(\"if\"))\n}",
    "filename": "/usr/local/go/src/text/template/parse/parse.go",
    "line": 585
  },
  {
    "id": 509,
    "text": "func (t *Tree) rangeControl() Node {\n\tr := t.newRange(t.parseControl(\"range\"))\n\treturn r\n}",
    "filename": "/usr/local/go/src/text/template/parse/parse.go",
    "line": 595
  },
  {
    "id": 510,
    "text": "func (t *Tree) withControl() Node {\n\treturn t.newWith(t.parseControl(\"with\"))\n}",
    "filename": "/usr/local/go/src/text/template/parse/parse.go",
    "line": 606
  },
  {
    "id": 511,
    "text": "func (t *Tree) endControl() Node {\n\treturn t.newEnd(t.expect(itemRightDelim, \"end\").pos)\n}",
    "filename": "/usr/local/go/src/text/template/parse/parse.go",
    "line": 615
  },
  {
    "id": 512,
    "text": "func (t *Tree) elseControl() Node {\n\tpeek := t.peekNonSpace()\n\t// The \"{{else if ... \" and \"{{else with ...\" will be\n\t// treated as \"{{else}}{{if ...\" and \"{{else}}{{with ...\".\n\t// So return the else node here.\n\tif peek.typ == itemIf || peek.typ == itemWith {\n\t\treturn t.newElse(peek.pos, peek.line)\n\t}\n\ttoken := t.expect(itemRightDelim, \"else\")\n\treturn t.newElse(token.pos, token.line)\n}",
    "filename": "/usr/local/go/src/text/template/parse/parse.go",
    "line": 624
  },
  {
    "id": 513,
    "text": "func (t *Tree) blockControl() Node {\n\tconst context = \"block clause\"\n\n\ttoken := t.nextNonSpace()\n\tname := t.parseTemplateName(token, context)\n\tpipe := t.pipeline(context, itemRightDelim)\n\n\tblock := New(name) // name will be updated once we know it.\n\tblock.text = t.text\n\tblock.Mode = t.Mode\n\tblock.ParseName = t.ParseName\n\tblock.startParse(t.funcs, t.lex, t.treeSet)\n\tvar end Node\n\tblock.Root, end = block.itemList()\n\tif end.Type() != nodeEnd {\n\t\tt.errorf(\"unexpected %s in %s\", end, context)\n\t}\n\tblock.add()\n\tblock.stopParse()\n\n\treturn t.newTemplate(token.pos, token.line, name, pipe)\n}",
    "filename": "/usr/local/go/src/text/template/parse/parse.go",
    "line": 643
  },
  {
    "id": 514,
    "text": "func (t *Tree) templateControl() Node {\n\tconst context = \"template clause\"\n\ttoken := t.nextNonSpace()\n\tname := t.parseTemplateName(token, context)\n\tvar pipe *PipeNode\n\tif t.nextNonSpace().typ != itemRightDelim {\n\t\tt.backup()\n\t\t// Do not pop variables; they persist until \"end\".\n\t\tpipe = t.pipeline(context, itemRightDelim)\n\t}\n\treturn t.newTemplate(token.pos, token.line, name, pipe)\n}",
    "filename": "/usr/local/go/src/text/template/parse/parse.go",
    "line": 672
  },
  {
    "id": 515,
    "text": "func (t *Tree) parseTemplateName(token item, context string) (name string) {\n\tswitch token.typ {\n\tcase itemString, itemRawString:\n\t\ts, err := strconv.Unquote(token.val)\n\t\tif err != nil {\n\t\t\tt.error(err)\n\t\t}\n\t\tname = s\n\tdefault:\n\t\tt.unexpected(token, context)\n\t}\n\treturn\n}",
    "filename": "/usr/local/go/src/text/template/parse/parse.go",
    "line": 685
  },
  {
    "id": 516,
    "text": "func (t *Tree) command() *CommandNode {\n\tcmd := t.newCommand(t.peekNonSpace().pos)\n\tfor {\n\t\tt.peekNonSpace() // skip leading spaces.\n\t\toperand := t.operand()\n\t\tif operand != nil {\n\t\t\tcmd.append(operand)\n\t\t}\n\t\tswitch token := t.next(); token.typ {\n\t\tcase itemSpace:\n\t\t\tcontinue\n\t\tcase itemRightDelim, itemRightParen:\n\t\t\tt.backup()\n\t\tcase itemPipe:\n\t\t\t// nothing here; break loop below\n\t\tdefault:\n\t\t\tt.unexpected(token, \"operand\")\n\t\t}\n\t\tbreak\n\t}\n\tif len(cmd.Args) == 0 {\n\t\tt.errorf(\"empty command\")\n\t}\n\treturn cmd\n}",
    "filename": "/usr/local/go/src/text/template/parse/parse.go",
    "line": 705
  },
  {
    "id": 517,
    "text": "func (t *Tree) operand() Node {\n\tnode := t.term()\n\tif node == nil {\n\t\treturn nil\n\t}\n\tif t.peek().typ == itemField {\n\t\tchain := t.newChain(t.peek().pos, node)\n\t\tfor t.peek().typ == itemField {\n\t\t\tchain.Add(t.next().val)\n\t\t}\n\t\t// Compatibility with original API: If the term is of type NodeField\n\t\t// or NodeVariable, just put more fields on the original.\n\t\t// Otherwise, keep the Chain node.\n\t\t// Obvious parsing errors involving literal values are detected here.\n\t\t// More complex error cases will have to be handled at execution time.\n\t\tswitch node.Type() {\n\t\tcase NodeField:\n\t\t\tnode = t.newField(chain.Position(), chain.String())\n\t\tcase NodeVariable:\n\t\t\tnode = t.newVariable(chain.Position(), chain.String())\n\t\tcase NodeBool, NodeString, NodeNumber, NodeNil, NodeDot:\n\t\t\tt.errorf(\"unexpected . after term %q\", node.String())\n\t\tdefault:\n\t\t\tnode = chain\n\t\t}\n\t}\n\treturn node\n}",
    "filename": "/usr/local/go/src/text/template/parse/parse.go",
    "line": 738
  },
  {
    "id": 518,
    "text": "func (t *Tree) term() Node {\n\tswitch token := t.nextNonSpace(); token.typ {\n\tcase itemIdentifier:\n\t\tcheckFunc := t.Mode\u0026SkipFuncCheck == 0\n\t\tif checkFunc \u0026\u0026 !t.hasFunction(token.val) {\n\t\t\tt.errorf(\"function %q not defined\", token.val)\n\t\t}\n\t\treturn NewIdentifier(token.val).SetTree(t).SetPos(token.pos)\n\tcase itemDot:\n\t\treturn t.newDot(token.pos)\n\tcase itemNil:\n\t\treturn t.newNil(token.pos)\n\tcase itemVariable:\n\t\treturn t.useVar(token.pos, token.val)\n\tcase itemField:\n\t\treturn t.newField(token.pos, token.val)\n\tcase itemBool:\n\t\treturn t.newBool(token.pos, token.val == \"true\")\n\tcase itemCharConstant, itemComplex, itemNumber:\n\t\tnumber, err := t.newNumber(token.pos, token.val, token.typ)\n\t\tif err != nil {\n\t\t\tt.error(err)\n\t\t}\n\t\treturn number\n\tcase itemLeftParen:\n\t\tif t.stackDepth \u003e= maxStackDepth {\n\t\t\tt.errorf(\"max expression depth exceeded\")\n\t\t}\n\t\tt.stackDepth++\n\t\tdefer func() { t.stackDepth-- }()\n\t\treturn t.pipeline(\"parenthesized pipeline\", itemRightParen)\n\tcase itemString, itemRawString:\n\t\ts, err := strconv.Unquote(token.val)\n\t\tif err != nil {\n\t\t\tt.error(err)\n\t\t}\n\t\treturn t.newString(token.pos, token.val, s)\n\t}\n\tt.backup()\n\treturn nil\n}",
    "filename": "/usr/local/go/src/text/template/parse/parse.go",
    "line": 778
  },
  {
    "id": 519,
    "text": "func (t *Tree) hasFunction(name string) bool {\n\tfor _, funcMap := range t.funcs {\n\t\tif funcMap == nil {\n\t\t\tcontinue\n\t\t}\n\t\tif funcMap[name] != nil {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}",
    "filename": "/usr/local/go/src/text/template/parse/parse.go",
    "line": 821
  },
  {
    "id": 520,
    "text": "func (t *Tree) popVars(n int) {\n\tt.vars = t.vars[:n]\n}",
    "filename": "/usr/local/go/src/text/template/parse/parse.go",
    "line": 834
  },
  {
    "id": 521,
    "text": "func (t *Tree) useVar(pos Pos, name string) Node {\n\tv := t.newVariable(pos, name)\n\tfor _, varName := range t.vars {\n\t\tif varName == v.Ident[0] {\n\t\t\treturn v\n\t\t}\n\t}\n\tt.errorf(\"undefined variable %q\", v.Ident[0])\n\treturn nil\n}",
    "filename": "/usr/local/go/src/text/template/parse/parse.go",
    "line": 840
  },
  {
    "id": 522,
    "text": "func init() {\n\t// Use a small stack limit for testing to avoid creating huge expressions.\n\tmaxStackDepth = 3\n}",
    "filename": "/usr/local/go/src/text/template/parse/parse_test.go",
    "line": 89
  },
  {
    "id": 523,
    "text": "func TestNumberParse(t *testing.T) {\n\tfor _, test := range numberTests {\n\t\t// If fmt.Sscan thinks it's complex, it's complex. We can't trust the output\n\t\t// because imaginary comes out as a number.\n\t\tvar c complex128\n\t\ttyp := itemNumber\n\t\tvar tree *Tree\n\t\tif test.text[0] == '\\'' {\n\t\t\ttyp = itemCharConstant\n\t\t} else {\n\t\t\t_, err := fmt.Sscan(test.text, \u0026c)\n\t\t\tif err == nil {\n\t\t\t\ttyp = itemComplex\n\t\t\t}\n\t\t}\n\t\tn, err := tree.newNumber(0, test.text, typ)\n\t\tok := test.isInt || test.isUint || test.isFloat || test.isComplex\n\t\tif ok \u0026\u0026 err != nil {\n\t\t\tt.Errorf(\"unexpected error for %q: %s\", test.text, err)\n\t\t\tcontinue\n\t\t}\n\t\tif !ok \u0026\u0026 err == nil {\n\t\t\tt.Errorf(\"expected error for %q\", test.text)\n\t\t\tcontinue\n\t\t}\n\t\tif !ok {\n\t\t\tif *debug {\n\t\t\t\tfmt.Printf(\"%s\\n\\t%s\\n\", test.text, err)\n\t\t\t}\n\t\t\tcontinue\n\t\t}\n\t\tif n.IsComplex != test.isComplex {\n\t\t\tt.Errorf(\"complex incorrect for %q; should be %t\", test.text, test.isComplex)\n\t\t}\n\t\tif test.isInt {\n\t\t\tif !n.IsInt {\n\t\t\t\tt.Errorf(\"expected integer for %q\", test.text)\n\t\t\t}\n\t\t\tif n.Int64 != test.int64 {\n\t\t\t\tt.Errorf(\"int64 for %q should be %d Is %d\", test.text, test.int64, n.Int64)\n\t\t\t}\n\t\t} else if n.IsInt {\n\t\t\tt.Errorf(\"did not expect integer for %q\", test.text)\n\t\t}\n\t\tif test.isUint {\n\t\t\tif !n.IsUint {\n\t\t\t\tt.Errorf(\"expected unsigned integer for %q\", test.text)\n\t\t\t}\n\t\t\tif n.Uint64 != test.uint64 {\n\t\t\t\tt.Errorf(\"uint64 for %q should be %d Is %d\", test.text, test.uint64, n.Uint64)\n\t\t\t}\n\t\t} else if n.IsUint {\n\t\t\tt.Errorf(\"did not expect unsigned integer for %q\", test.text)\n\t\t}\n\t\tif test.isFloat {\n\t\t\tif !n.IsFloat {\n\t\t\t\tt.Errorf(\"expected float for %q\", test.text)\n\t\t\t}\n\t\t\tif n.Float64 != test.float64 {\n\t\t\t\tt.Errorf(\"float64 for %q should be %g Is %g\", test.text, test.float64, n.Float64)\n\t\t\t}\n\t\t} else if n.IsFloat {\n\t\t\tt.Errorf(\"did not expect float for %q\", test.text)\n\t\t}\n\t\tif test.isComplex {\n\t\t\tif !n.IsComplex {\n\t\t\t\tt.Errorf(\"expected complex for %q\", test.text)\n\t\t\t}\n\t\t\tif n.Complex128 != test.complex128 {\n\t\t\t\tt.Errorf(\"complex128 for %q should be %g Is %g\", test.text, test.complex128, n.Complex128)\n\t\t\t}\n\t\t} else if n.IsComplex {\n\t\t\tt.Errorf(\"did not expect complex for %q\", test.text)\n\t\t}\n\t}\n}",
    "filename": "/usr/local/go/src/text/template/parse/parse_test.go",
    "line": 94
  },
  {
    "id": 524,
    "text": "func testParse(doCopy bool, t *testing.T) {\n\ttextFormat = \"%q\"\n\tdefer func() { textFormat = \"%s\" }()\n\tfor _, test := range parseTests {\n\t\ttmpl, err := New(test.name).Parse(test.input, \"\", \"\", make(map[string]*Tree), builtins)\n\t\tswitch {\n\t\tcase err == nil \u0026\u0026 !test.ok:\n\t\t\tt.Errorf(\"%q: expected error; got none\", test.name)\n\t\t\tcontinue\n\t\tcase err != nil \u0026\u0026 test.ok:\n\t\t\tt.Errorf(\"%q: unexpected error: %v\", test.name, err)\n\t\t\tcontinue\n\t\tcase err != nil \u0026\u0026 !test.ok:\n\t\t\t// expected error, got one\n\t\t\tif *debug {\n\t\t\t\tfmt.Printf(\"%s: %s\\n\\t%s\\n\", test.name, test.input, err)\n\t\t\t}\n\t\t\tcontinue\n\t\t}\n\t\tvar result string\n\t\tif doCopy {\n\t\t\tresult = tmpl.Root.Copy().String()\n\t\t} else {\n\t\t\tresult = tmpl.Root.String()\n\t\t}\n\t\tif result != test.result {\n\t\t\tt.Errorf(\"%s=(%q): got\\n\\t%v\\nexpected\\n\\t%v\", test.name, test.input, result, test.result)\n\t\t}\n\t}\n}",
    "filename": "/usr/local/go/src/text/template/parse/parse_test.go",
    "line": 351
  },
  {
    "id": 525,
    "text": "func TestParse(t *testing.T) {\n\ttestParse(false, t)\n}",
    "filename": "/usr/local/go/src/text/template/parse/parse_test.go",
    "line": 382
  },
  {
    "id": 526,
    "text": "func TestParseCopy(t *testing.T) {\n\ttestParse(true, t)\n}",
    "filename": "/usr/local/go/src/text/template/parse/parse_test.go",
    "line": 387
  },
  {
    "id": 527,
    "text": "func TestParseWithComments(t *testing.T) {\n\ttextFormat = \"%q\"\n\tdefer func() { textFormat = \"%s\" }()\n\ttests := [...]parseTest{\n\t\t{\"comment\", \"{{/*\\n\\n\\n*/}}\", noError, \"{{/*\\n\\n\\n*/}}\"},\n\t\t{\"comment trim left\", \"x \\r\\n\\t{{- /* hi */}}\", noError, `\"x\"{{/* hi */}}`},\n\t\t{\"comment trim right\", \"{{/* hi */ -}}\\n\\n\\ty\", noError, `{{/* hi */}}\"y\"`},\n\t\t{\"comment trim left and right\", \"x \\r\\n\\t{{- /* */ -}}\\n\\n\\ty\", noError, `\"x\"{{/* */}}\"y\"`},\n\t}\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\ttr := New(test.name)\n\t\t\ttr.Mode = ParseComments\n\t\t\ttmpl, err := tr.Parse(test.input, \"\", \"\", make(map[string]*Tree))\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"%q: expected error; got none\", test.name)\n\t\t\t}\n\t\t\tif result := tmpl.Root.String(); result != test.result {\n\t\t\t\tt.Errorf(\"%s=(%q): got\\n\\t%v\\nexpected\\n\\t%v\", test.name, test.input, result, test.result)\n\t\t\t}\n\t\t})\n\t}\n}",
    "filename": "/usr/local/go/src/text/template/parse/parse_test.go",
    "line": 391
  },
  {
    "id": 528,
    "text": "func TestKeywordsAndFuncs(t *testing.T) {\n\t// Check collisions between functions and new keywords like 'break'. When a\n\t// break function is provided, the parser should treat 'break' as a function,\n\t// not a keyword.\n\ttextFormat = \"%q\"\n\tdefer func() { textFormat = \"%s\" }()\n\n\tinp := `{{range .X}}{{break 20}}{{end}}`\n\t{\n\t\t// 'break' is a defined function, don't treat it as a keyword: it should\n\t\t// accept an argument successfully.\n\t\tvar funcsWithKeywordFunc = map[string]any{\n\t\t\t\"break\": func(in any) any { return in },\n\t\t}\n\t\ttmpl, err := New(\"\").Parse(inp, \"\", \"\", make(map[string]*Tree), funcsWithKeywordFunc)\n\t\tif err != nil || tmpl == nil {\n\t\t\tt.Errorf(\"with break func: unexpected error: %v\", err)\n\t\t}\n\t}\n\n\t{\n\t\t// No function called 'break'; treat it as a keyword. Results in a parse\n\t\t// error.\n\t\ttmpl, err := New(\"\").Parse(inp, \"\", \"\", make(map[string]*Tree), make(map[string]any))\n\t\tif err == nil || tmpl != nil {\n\t\t\tt.Errorf(\"without break func: expected error; got none\")\n\t\t}\n\t}\n}",
    "filename": "/usr/local/go/src/text/template/parse/parse_test.go",
    "line": 415
  },
  {
    "id": 529,
    "text": "func TestSkipFuncCheck(t *testing.T) {\n\toldTextFormat := textFormat\n\ttextFormat = \"%q\"\n\tdefer func() { textFormat = oldTextFormat }()\n\ttr := New(\"skip func check\")\n\ttr.Mode = SkipFuncCheck\n\ttmpl, err := tr.Parse(\"{{fn 1 2}}\", \"\", \"\", make(map[string]*Tree))\n\tif err != nil {\n\t\tt.Fatalf(\"unexpected error: %v\", err)\n\t}\n\texpected := \"{{fn 1 2}}\"\n\tif result := tmpl.Root.String(); result != expected {\n\t\tt.Errorf(\"got\\n\\t%v\\nexpected\\n\\t%v\", result, expected)\n\t}\n}",
    "filename": "/usr/local/go/src/text/template/parse/parse_test.go",
    "line": 445
  },
  {
    "id": 530,
    "text": "func TestIsEmpty(t *testing.T) {\n\tif !IsEmptyTree(nil) {\n\t\tt.Errorf(\"nil tree is not empty\")\n\t}\n\tfor _, test := range isEmptyTests {\n\t\ttree, err := New(\"root\").Parse(test.input, \"\", \"\", make(map[string]*Tree), nil)\n\t\tif err != nil {\n\t\t\tt.Errorf(\"%q: unexpected error: %v\", test.name, err)\n\t\t\tcontinue\n\t\t}\n\t\tif empty := IsEmptyTree(tree.Root); empty != test.empty {\n\t\t\tt.Errorf(\"%q: expected %t got %t\", test.name, test.empty, empty)\n\t\t}\n\t}\n}",
    "filename": "/usr/local/go/src/text/template/parse/parse_test.go",
    "line": 478
  },
  {
    "id": 531,
    "text": "func TestErrorContextWithTreeCopy(t *testing.T) {\n\ttree, err := New(\"root\").Parse(\"{{if true}}{{end}}\", \"\", \"\", make(map[string]*Tree), nil)\n\tif err != nil {\n\t\tt.Fatalf(\"unexpected tree parse failure: %v\", err)\n\t}\n\ttreeCopy := tree.Copy()\n\twantLocation, wantContext := tree.ErrorContext(tree.Root.Nodes[0])\n\tgotLocation, gotContext := treeCopy.ErrorContext(treeCopy.Root.Nodes[0])\n\tif wantLocation != gotLocation {\n\t\tt.Errorf(\"wrong error location want %q got %q\", wantLocation, gotLocation)\n\t}\n\tif wantContext != gotContext {\n\t\tt.Errorf(\"wrong error location want %q got %q\", wantContext, gotContext)\n\t}\n}",
    "filename": "/usr/local/go/src/text/template/parse/parse_test.go",
    "line": 494
  },
  {
    "id": 532,
    "text": "func TestErrors(t *testing.T) {\n\tfor _, test := range errorTests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\t_, err := New(test.name).Parse(test.input, \"\", \"\", make(map[string]*Tree))\n\t\t\tif err == nil {\n\t\t\t\tt.Fatalf(\"expected error %q, got nil\", test.result)\n\t\t\t}\n\t\t\tif !strings.Contains(err.Error(), test.result) {\n\t\t\t\tt.Fatalf(\"error %q does not contain %q\", err, test.result)\n\t\t\t}\n\t\t})\n\t}\n}",
    "filename": "/usr/local/go/src/text/template/parse/parse_test.go",
    "line": 613
  },
  {
    "id": 533,
    "text": "func TestBlock(t *testing.T) {\n\tconst (\n\t\tinput = `a{{block \"inner\" .}}bar{{.}}baz{{end}}b`\n\t\touter = `a{{template \"inner\" .}}b`\n\t\tinner = `bar{{.}}baz`\n\t)\n\ttreeSet := make(map[string]*Tree)\n\ttmpl, err := New(\"outer\").Parse(input, \"\", \"\", treeSet, nil)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif g, w := tmpl.Root.String(), outer; g != w {\n\t\tt.Errorf(\"outer template = %q, want %q\", g, w)\n\t}\n\tinTmpl := treeSet[\"inner\"]\n\tif inTmpl == nil {\n\t\tt.Fatal(\"block did not define template\")\n\t}\n\tif g, w := inTmpl.Root.String(), inner; g != w {\n\t\tt.Errorf(\"inner template = %q, want %q\", g, w)\n\t}\n}",
    "filename": "/usr/local/go/src/text/template/parse/parse_test.go",
    "line": 627
  },
  {
    "id": 534,
    "text": "func TestLineNum(t *testing.T) {\n\t// const count = 100\n\tconst count = 3\n\ttext := strings.Repeat(\"{{printf 1234}}\\n\", count)\n\ttree, err := New(\"bench\").Parse(text, \"\", \"\", make(map[string]*Tree), builtins)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\t// Check the line numbers. Each line is an action containing a template, followed by text.\n\t// That's two nodes per line.\n\tnodes := tree.Root.Nodes\n\tfor i := 0; i \u003c len(nodes); i += 2 {\n\t\tline := 1 + i/2\n\t\t// Action first.\n\t\taction := nodes[i].(*ActionNode)\n\t\tif action.Line != line {\n\t\t\tt.Errorf(\"line %d: action is line %d\", line, action.Line)\n\t\t}\n\t\tpipe := action.Pipe\n\t\tif pipe.Line != line {\n\t\t\tt.Errorf(\"line %d: pipe is line %d\", line, pipe.Line)\n\t\t}\n\t}\n}",
    "filename": "/usr/local/go/src/text/template/parse/parse_test.go",
    "line": 650
  },
  {
    "id": 535,
    "text": "func BenchmarkParseLarge(b *testing.B) {\n\ttext := strings.Repeat(\"{{1234}}\\n\", 10000)\n\tfor i := 0; i \u003c b.N; i++ {\n\t\t_, err := New(\"bench\").Parse(text, \"\", \"\", make(map[string]*Tree), builtins)\n\t\tif err != nil {\n\t\t\tb.Fatal(err)\n\t\t}\n\t}\n}",
    "filename": "/usr/local/go/src/text/template/parse/parse_test.go",
    "line": 675
  },
  {
    "id": 536,
    "text": "func BenchmarkVariableString(b *testing.B) {\n\tv := \u0026VariableNode{\n\t\tIdent: []string{\"$\", \"A\", \"BB\", \"CCC\", \"THIS_IS_THE_VARIABLE_BEING_PROCESSED\"},\n\t}\n\tb.ResetTimer()\n\tb.ReportAllocs()\n\tfor i := 0; i \u003c b.N; i++ {\n\t\tsinkv = v.String()\n\t}\n\tif sinkv == \"\" {\n\t\tb.Fatal(\"Benchmark was not run\")\n\t}\n}",
    "filename": "/usr/local/go/src/text/template/parse/parse_test.go",
    "line": 687
  },
  {
    "id": 537,
    "text": "func BenchmarkListString(b *testing.B) {\n\ttext := `\n{{(printf .Field1.Field2.Field3).Value}}\n{{$x := (printf .Field1.Field2.Field3).Value}}\n{{$y := (printf $x.Field1.Field2.Field3).Value}}\n{{$z := $y.Field1.Field2.Field3}}\n{{if contains $y $z}}\n\t{{printf \"%q\" $y}}\n{{else}}\n\t{{printf \"%q\" $x}}\n{{end}}\n{{with $z.Field1 | contains \"boring\"}}\n\t{{printf \"%q\" . | printf \"%s\"}}\n{{else}}\n\t{{printf \"%d %d %d\" 11 11 11}}\n\t{{printf \"%d %d %s\" 22 22 $x.Field1.Field2.Field3 | printf \"%s\"}}\n\t{{printf \"%v\" (contains $z.Field1.Field2 $y)}}\n{{end}}\n`\n\ttree, err := New(\"bench\").Parse(text, \"\", \"\", make(map[string]*Tree), builtins)\n\tif err != nil {\n\t\tb.Fatal(err)\n\t}\n\tb.ResetTimer()\n\tb.ReportAllocs()\n\tfor i := 0; i \u003c b.N; i++ {\n\t\tsinkl = tree.Root.String()\n\t}\n\tif sinkl == \"\" {\n\t\tb.Fatal(\"Benchmark was not run\")\n\t}\n}",
    "filename": "/usr/local/go/src/text/template/parse/parse_test.go",
    "line": 701
  },
  {
    "id": 538,
    "text": "func New(name string) *Template {\n\tt := \u0026Template{\n\t\tname: name,\n\t}\n\tt.init()\n\treturn t\n}",
    "filename": "/usr/local/go/src/text/template/template.go",
    "line": 39
  },
  {
    "id": 539,
    "text": "func (t *Template) Name() string {\n\treturn t.name\n}",
    "filename": "/usr/local/go/src/text/template/template.go",
    "line": 48
  },
  {
    "id": 540,
    "text": "func (t *Template) New(name string) *Template {\n\tt.init()\n\tnt := \u0026Template{\n\t\tname:       name,\n\t\tcommon:     t.common,\n\t\tleftDelim:  t.leftDelim,\n\t\trightDelim: t.rightDelim,\n\t}\n\treturn nt\n}",
    "filename": "/usr/local/go/src/text/template/template.go",
    "line": 59
  },
  {
    "id": 541,
    "text": "func (t *Template) init() {\n\tif t.common == nil {\n\t\tc := new(common)\n\t\tc.tmpl = make(map[string]*Template)\n\t\tc.parseFuncs = make(FuncMap)\n\t\tc.execFuncs = make(map[string]reflect.Value)\n\t\tt.common = c\n\t}\n}",
    "filename": "/usr/local/go/src/text/template/template.go",
    "line": 71
  },
  {
    "id": 542,
    "text": "func (t *Template) Clone() (*Template, error) {\n\tnt := t.copy(nil)\n\tnt.init()\n\tif t.common == nil {\n\t\treturn nt, nil\n\t}\n\tnt.option = t.option\n\tt.muTmpl.RLock()\n\tdefer t.muTmpl.RUnlock()\n\tfor k, v := range t.tmpl {\n\t\tif k == t.name {\n\t\t\tnt.tmpl[t.name] = nt\n\t\t\tcontinue\n\t\t}\n\t\t// The associated templates share nt's common structure.\n\t\ttmpl := v.copy(nt.common)\n\t\tnt.tmpl[k] = tmpl\n\t}\n\tt.muFuncs.RLock()\n\tdefer t.muFuncs.RUnlock()\n\tmaps.Copy(nt.parseFuncs, t.parseFuncs)\n\tmaps.Copy(nt.execFuncs, t.execFuncs)\n\treturn nt, nil\n}",
    "filename": "/usr/local/go/src/text/template/template.go",
    "line": 87
  },
  {
    "id": 543,
    "text": "func (t *Template) copy(c *common) *Template {\n\treturn \u0026Template{\n\t\tname:       t.name,\n\t\tTree:       t.Tree,\n\t\tcommon:     c,\n\t\tleftDelim:  t.leftDelim,\n\t\trightDelim: t.rightDelim,\n\t}\n}",
    "filename": "/usr/local/go/src/text/template/template.go",
    "line": 113
  },
  {
    "id": 544,
    "text": "func (t *Template) AddParseTree(name string, tree *parse.Tree) (*Template, error) {\n\tt.init()\n\tt.muTmpl.Lock()\n\tdefer t.muTmpl.Unlock()\n\tnt := t\n\tif name != t.name {\n\t\tnt = t.New(name)\n\t}\n\t// Even if nt == t, we need to install it in the common.tmpl map.\n\tif t.associate(nt, tree) || nt.Tree == nil {\n\t\tnt.Tree = tree\n\t}\n\treturn nt, nil\n}",
    "filename": "/usr/local/go/src/text/template/template.go",
    "line": 127
  },
  {
    "id": 545,
    "text": "func (t *Template) Templates() []*Template {\n\tif t.common == nil {\n\t\treturn nil\n\t}\n\t// Return a slice so we don't expose the map.\n\tt.muTmpl.RLock()\n\tdefer t.muTmpl.RUnlock()\n\tm := make([]*Template, 0, len(t.tmpl))\n\tfor _, v := range t.tmpl {\n\t\tm = append(m, v)\n\t}\n\treturn m\n}",
    "filename": "/usr/local/go/src/text/template/template.go",
    "line": 143
  },
  {
    "id": 546,
    "text": "func (t *Template) Delims(left, right string) *Template {\n\tt.init()\n\tt.leftDelim = left\n\tt.rightDelim = right\n\treturn t\n}",
    "filename": "/usr/local/go/src/text/template/template.go",
    "line": 162
  },
  {
    "id": 547,
    "text": "func (t *Template) Funcs(funcMap FuncMap) *Template {\n\tt.init()\n\tt.muFuncs.Lock()\n\tdefer t.muFuncs.Unlock()\n\taddValueFuncs(t.execFuncs, funcMap)\n\taddFuncs(t.parseFuncs, funcMap)\n\treturn t\n}",
    "filename": "/usr/local/go/src/text/template/template.go",
    "line": 175
  },
  {
    "id": 548,
    "text": "func (t *Template) Lookup(name string) *Template {\n\tif t.common == nil {\n\t\treturn nil\n\t}\n\tt.muTmpl.RLock()\n\tdefer t.muTmpl.RUnlock()\n\treturn t.tmpl[name]\n}",
    "filename": "/usr/local/go/src/text/template/template.go",
    "line": 186
  },
  {
    "id": 549,
    "text": "func (t *Template) Parse(text string) (*Template, error) {\n\tt.init()\n\tt.muFuncs.RLock()\n\ttrees, err := parse.Parse(t.name, text, t.leftDelim, t.rightDelim, t.parseFuncs, builtins())\n\tt.muFuncs.RUnlock()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\t// Add the newly parsed trees, including the one for t, into our common structure.\n\tfor name, tree := range trees {\n\t\tif _, err := t.AddParseTree(name, tree); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\treturn t, nil\n}",
    "filename": "/usr/local/go/src/text/template/template.go",
    "line": 205
  },
  {
    "id": 550,
    "text": "func (t *Template) associate(new *Template, tree *parse.Tree) bool {\n\tif new.common != t.common {\n\t\tpanic(\"internal error: associate not common\")\n\t}\n\tif old := t.tmpl[new.name]; old != nil \u0026\u0026 parse.IsEmptyTree(tree.Root) \u0026\u0026 old.Tree != nil {\n\t\t// If a template by that name exists,\n\t\t// don't replace it with an empty template.\n\t\treturn false\n\t}\n\tt.tmpl[new.name] = new\n\treturn true\n}",
    "filename": "/usr/local/go/src/text/template/template.go",
    "line": 225
  }
]